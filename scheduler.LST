CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 1   


CX51 COMPILER V7.50, COMPILATION OF MODULE SCHEDULER
OBJECT MODULE PLACED IN scheduler.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\CX51.EXE scheduler.c LARGE OBJECTADVANCED ROM(HUGE) OPTIMIZE(SIZE) BROWSE DEBUG

line level    source

   1          //#undef _DEBUG_TRACE
   2          #define SCHEDULER_C
   3          #include "device.h"
   4          #include "common.h"
   5          #include "scheduler.h"
   6          #include "DataExchange.h"
   7          #include "Casher.h"
   8          #include "timer.h"
   9          #include "string.h"
  10          #include "debug.h"
  11          #include "serial1.h"
  12          #include "serial.h"
  13          #include "procotol.h"
  14          #include "Coiner.h"
  15          #include "IOInput.h"
  16          #include "global.h"
  17          #include "mobile.h"
  18          #include "lifterApi.h"
  19          
  20          
  21          
  22          extern uchar xdata SystemStatus;
  23          extern u_int  xdata HardWareErr;
  24          uchar xdata ZhkCasherStatus;
  25          uchar xdata CoinerStatus;
  26          
  27          extern unsigned char VPMission_Button_RPT( unsigned char type, unsigned char value );
  28          extern bit IfGameKeyOn( void );
  29          
  30          ///纸币器状态值
  31          #define CASHER_STATUS_NULL      0
  32          #define CASHER_STATUS_ACCEPT    1
  33          #define CASHER_STATUS_ENABLE    2
  34          #define CASHER_STATUS_DISABLE   3
  35          #define CASHER_STATUS_REJECT    4
  36          #define CASHER_STATUS_QUERY     5
  37          
  38          ///硬币器状态值
  39          #define COINER_STATUS_NULL      0
  40          #define COINER_STATUS_ENABLE    1
  41          #define COINER_STATUS_DISABLE   2
  42          #define COINER_STATUS_RESET     3
  43          
  44          #define DOWNMSGACKTIMEOUT       30
  45          
  46          uchar ZhkSchedulerAddTask( struct COMMTASK xdata* NewTask );
  47          // 添加调度任务
  48          bit ZhkSchedulerIsTaskNull( uchar TaskNum );
  49          // 判断当前任务是否无任务
  50          // 在人物列表中删除任务
  51          uchar ZhkGetSchedulerClock( void );
  52          // 读取调度时钟
  53          
  54          bit ZhkHopper1Query( void );
  55          bit ZhkHopper2Query( void );
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 2   

  56          bit ZhkHopper3Query( void );
  57          //bit ZhkHubQuery( void );
  58          bit ZhkCasherQuery( void );
  59          //作业
  60          bit ZhkNullTask( void );
  61          bit ZhkCasherTask( struct COMMTASK xdata* TaskTemp );
  62          bit ZhkHopperTask( struct COMMTASK xdata* TaskTemp );
  63          bit ZhkLcdTask( struct COMMTASK xdata* TaskTemp );
  64          //bit ZhkHubTask( struct COMMTASK xdata* TaskTemp );
  65          //bit ZhkPrnTask( struct COMMTASK xdata* TaskTemp );
  66          bit ZhkChannelTask( struct COMMTASK xdata* TaskTemp );
  67          
  68          //处理
  69          uchar ZhkHopperMsgProcess( void );
  70          uchar ZhkCasherMsgProcess( void );
  71          //uchar ZhkHubMsgProcess( void );
  72          uchar ZhkLcdMsgProcess( void );
  73          //uchar ZhkPrnMsgProcess( void );
  74          uchar ZhkChannelMsgProcess( void );
  75          
  76          bit ZhkCasherTxMsg( struct COMMTASK xdata* NewTask, uchar xdata Flag  );
  77          bit ZhkHopperTxMsg( struct COMMTASK xdata* NewTask );
  78          bit ZhkLcdTxMsg( struct COMMTASK xdata* NewTask );
  79          //bit ZhkHubTxMsg( struct COMMTASK xdata* NewTask );
  80          //bit ZhkPrnTxMsg( struct COMMTASK xdata* NewTask );
  81          bit ZhkChannelTxMsg( struct COMMTASK xdata* NewTask );
  82          
  83          //uchar CoinerMsgProcess( void );
  84          //bit CoinerTxMsg( struct COMMTASK xdata* TaskTemp );
  85          //bit CoinerTask( struct COMMTASK xdata* TaskTemp );
  86          
  87          void ZhkChannelSwitch( uchar type );
  88          
  89          struct AUTOTASK code ZhkAutoTaskList[] = 
  90          {       
  91                  ID_CASHER  , CASHER_QUERY   ,150 ,
  92                  ID_COINER1 , COINER1_QUERY   ,100 
  93          };      
  94          
  95          //任务计时器
  96          uchar xdata ZhkAutoTaskTimer[ sizeof( ZhkAutoTaskList ) / sizeof( struct AUTOTASK ) ];
  97          //任务许可
  98          uchar xdata ZhkAutoTaskPermission[ sizeof( ZhkAutoTaskList ) / sizeof( struct AUTOTASK ) ];
  99          
 100          
 101          
 102          // 串口设备调度时钟，以秒为单位
 103          uchar xdata ZhkSchedulerId;
 104          // 当前设备任务的设备ID
 105          uchar xdata ZhkSchedulerState;
 106          
 107          struct COMMTASK xdata ZhkReadyTaskList[ 32 ];
 108          // 就绪任务队列
 109          struct COMMTASK xdata CurrentTask;
 110          // 当前占用串口任务编号
 111          
 112          uchar xdata     AlarmFlag = 0;//0为关,1为开
 113          
 114          //是否轮询手机模块控制代码
 115          #ifndef _DEBUG_NO_MOBILE
                      uchar xdata IsPressMobile = 1;
              #endif // _DEBUG_NO_MOBILE
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 3   

 118          
 119          
 120          uchar SchedulerInit( void )
 121          {
 122   1              uchar data i;
 123   1      
 124   1              Hopper1.Id            = ID_HOPPER1;
 125   1              Hopper1.Sn            = 0;
 126   1              Hopper1.CommState     = 0;
 127   1              Hopper1.State         = 0;
 128   1              memset( Hopper1.ExtState, 0, sizeof( Hopper1.ExtState ) );
 129   1      //      Hopper1.ExtState[ 0 ] = 0;
 130   1      //      Hopper1.ExtState[ 1 ] = 0;
 131   1      
 132   1              Hopper2.Id            = ID_HOPPER2;
 133   1              Hopper2.Sn            = 0;
 134   1              Hopper2.CommState     = 0;
 135   1              Hopper2.State         = 0;
 136   1              memset( Hopper2.ExtState, 0, sizeof( Hopper2.ExtState ) );
 137   1      //      Hopper2.ExtState[ 0 ] = 0;
 138   1      //      Hopper2.ExtState[ 1 ] = 0;
 139   1      
 140   1              Hopper3.Id            = ID_HOPPER3;
 141   1              Hopper3.Sn            = 0;
 142   1              Hopper3.CommState     = 0;
 143   1              Hopper3.State         = 0;
 144   1              memset( Hopper3.ExtState, 0, sizeof( Hopper3.ExtState ) );
 145   1      //      Hopper3.ExtState[ 0 ] = 0;
 146   1      //      Hopper3.ExtState[ 1 ] = 0;
 147   1                              
 148   1              Lcd.Id            = ID_LCD;
 149   1              Lcd.Sn            = 1;
 150   1              Lcd.CommState     = 0;
 151   1              Lcd.State         = 0;
 152   1              memset( Lcd.ExtState, 0, sizeof( Lcd.ExtState ) );
 153   1      //      Lcd.ExtState[ 0 ] = 0;
 154   1      //      Lcd.ExtState[ 1 ] = 0;
 155   1              
 156   1              Casher.Id            = ID_CASHER;
 157   1              Casher.Sn            = 1;
 158   1              Casher.CommState     = 0;
 159   1              Casher.State         = 0;
 160   1              memset( Casher.ExtState, 0, sizeof( Casher.ExtState ) );
 161   1      //      Casher.ExtState[ 0 ] = 0;
 162   1      //      Casher.ExtState[ 1 ] = 0;
 163   1      
 164   1      //      Coiner.Id            = ID_COINER1;
 165   1      //      Coiner.Sn            = 1;
 166   1      //      Coiner.CommState     = 0;
 167   1      //      Coiner.State         = 0;
 168   1      //      memset( Coiner.ExtState, 0, sizeof( Coiner.ExtState ) );
 169   1      //      Coiner.ExtState[ 0 ] = 0;
 170   1      //      Coiner.ExtState[ 1 ] = 0;
 171   1      
 172   1      //      Hub.Id            = ID_HUB;
 173   1      //      Hub.Sn            = 1;
 174   1      //      Hub.CommState     = 0;
 175   1      //      Hub.State         = 0;
 176   1      //      memset( Hub.ExtState, 0, sizeof( Hub.ExtState ) );
 177   1      //      Hub.ExtState[ 0 ] = 0;
 178   1      //      Hub.ExtState[ 1 ] = 0;
 179   1      
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 4   

 180   1              Channel.Id            = ID_CHANNEL;
 181   1              Channel.Sn            = 1;
 182   1              Channel.CommState     = 0;
 183   1              Channel.State         = 0;
 184   1              memset( Channel.ExtState, 0, sizeof( Channel.ExtState ) );
 185   1      //      Channel.ExtState[ 0 ] = 0;
 186   1      //      Channel.ExtState[ 1 ] = 0;
 187   1          
 188   1          Selection1.Id         = ID_SELECTION1;
 189   1              Selection1.Sn         = 0;
 190   1              Selection1.CommState  = 0;
 191   1              Selection1.State      = 0;
 192   1              memset( Selection1.ExtState, 0, sizeof( Selection1.ExtState ) );
 193   1      
 194   1              Selection2.Id         = ID_SELECTION2;
 195   1              Selection2.Sn         = 0;
 196   1              Selection2.CommState  = 0;
 197   1              Selection2.State      = 0;
 198   1              memset( Selection2.ExtState, 0, sizeof( Selection2.ExtState ) );
 199   1      
 200   1              Selection3.Id         = ID_SELECTION3;
 201   1              Selection3.Sn         = 0;
 202   1              Selection3.CommState  = 0;
 203   1              Selection3.State      = 0;
 204   1              memset( Selection3.ExtState, 0, sizeof( Selection3.ExtState ) );
 205   1          
 206   1          ACDCModule.Id         = ID_ACDCMODULE;
 207   1              ACDCModule.Sn         = 0;
 208   1          ACDCModule.CommState  = 0;
 209   1          ACDCModule.State      = 0;
 210   1          memset( ACDCModule.ExtState, 0, sizeof( ACDCModule.ExtState ) );
 211   1      
 212   1              memset( ZhkAutoTaskPermission, 0, sizeof( ZhkAutoTaskPermission ) );
 213   1              ZhkCasherStatus = CASHER_STATUS_NULL;
 214   1              
 215   1      //      AlarmTimer = 90;
 216   1      //      AlarmFlag = 0;
 217   1              MaintFlag = 0;
 218   1      
 219   1              ZhkSchedulerId = ID_NULL;
 220   1              ZhkSchedulerState = TASK_NULL;  
 221   1              for( i = 0 ; i < sizeof( ZhkReadyTaskList ) / sizeof( struct COMMTASK ) ; i ++ )                        
 222   1                      memset( &ZhkReadyTaskList[ i ] , 0xFF , sizeof( struct COMMTASK ) );
 223   1      
 224   1      #ifndef _DEBUG_NO_MOBILE
                      ZhkMobileInit();
              #endif // _DEBUG_NO_MOBILE
 227   1      
 228   1              return 1;
 229   1      }
 230          
 231          uchar SchedulerProcess( void )
 232          {
 233   1              struct DEVICE xdata* data CurrentDevice;
 234   1      
 235   1      #ifndef _DEBUG_NO_MOBILE
                      if( IsPressMobile == 1 )
                              ZhkMobileProcess();
              #endif  
 239   1           
 240   1          //----------------------------------------------------------
 241   1          if( ( IfGameKeyOn() )&&(sysVPMission.comLock==0) )
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 5   

 242   1              {
 243   2                      VPMission_Button_RPT( 0, 0 );
 244   2                  //Beep();
 245   2              }
 246   1          //==========================================================
 247   1          
 248   1              //Trace( "SchedulerRouteDevice\n" );
 249   1              // 分析当前任务关联的设备
 250   1      
 251   1      
 252   1              switch( ZhkChkAddr( CurrentTask.Id ) )
 253   1              {
 254   2              case EQUIP_CASHER:
 255   2                      CurrentDevice = &Casher;
 256   2                      break;
 257   2      //      case EQUIP_COINER:
 258   2      //              CurrentDevice = &Coiner;
 259   2      //              break;
 260   2              case EQUIP_LCD:
 261   2                      CurrentDevice = &Lcd;
 262   2                      break;
 263   2      //      case EQUIP_HUB:
 264   2      //              CurrentDevice = &Hub;
 265   2      //              break;
 266   2              case EQUIP_HOPPER:              
 267   2                      switch( CurrentTask.Id - ID_HOPPER1 )
 268   2                      {
 269   3                      case 0:
 270   3                              CurrentDevice = &Hopper1;
 271   3                              break;
 272   3                      case 1:
 273   3                              CurrentDevice = &Hopper2;
 274   3                              break;
 275   3                      case 2:
 276   3                              CurrentDevice = &Hopper3;
 277   3                              break;
 278   3                      default:
 279   3                              ZhkSchedulerState = TASK_NULL;
 280   3                      }
 281   2                      break;  
 282   2              case EQUIP_CHANNEL:
 283   2                      CurrentDevice = &Channel;
 284   2                      break;
 285   2              case EQUIP_SELECTION:           
 286   2                      switch( CurrentTask.Id - ID_SELECTION1 )
 287   2                      {
 288   3                      case 0:
 289   3                              CurrentDevice = &Selection1;
 290   3                              break;
 291   3                      case 1:
 292   3                              CurrentDevice = &Selection2;
 293   3                              break;
 294   3                      case 2:
 295   3                              CurrentDevice = &Selection3;
 296   3                              break;
 297   3                      default:
 298   3                              ZhkSchedulerState = TASK_NULL;
 299   3                      }
 300   2                      break;
 301   2              case EQUIP_ACDCMODULE:
 302   2                  CurrentDevice = &ACDCModule;
 303   2                  break;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 6   

 304   2              default:
 305   2                      ZhkSchedulerState = TASK_NULL;
 306   2              }       
 307   1              // 设备调度流程控制
 308   1              switch( ZhkSchedulerState )
 309   1              {
 310   2              case TASK_NULL:
 311   2                      ZhkNullTask();
 312   2                      break;
 313   2              case TASK_REDAY:
 314   2              case TASK_WAIT:
 315   2              case TASK_REWAIT:
 316   2              case TASK_ERROR:
 317   2              case TASK_FINISH:
 318   2                      if ( CurrentDevice == -1 ) 
 319   2                              ZhkSchedulerState = TASK_NULL;
 320   2                      switch( CurrentTask.Id )
 321   2                      {
 322   3                      case ID_HOPPER1:
 323   3                      case ID_HOPPER2:
 324   3                      case ID_HOPPER3:
 325   3                              ZhkHopperTask( &CurrentTask );
 326   3              //              Trace( "\n ZhkSchedulerState = %bu", ZhkSchedulerState );
 327   3                              break;
 328   3                      case ID_LCD:
 329   3                              ZhkLcdTask( &CurrentTask );
 330   3                              break;          
 331   3                      case ID_CASHER:
 332   3                              //ZhkCasherTask( &CurrentTask );
 333   3                              break;  
 334   3      //              case ID_HUB:
 335   3      //                      ZhkHubTask( &CurrentTask );
 336   3      //                      break;
 337   3      //              case ID_COINER1:
 338   3      //                      CoinerTask( &CurrentTask );
 339   3      //                      break;
 340   3                      case ID_CHANNEL:
 341   3                              #ifdef   _SJJ_//升降机
 342   3                                      ZhkLifterTask(&CurrentTask );   
 343   3                              #else         //普通货道
                                      ZhkChannelTask( &CurrentTask );         
                                      #endif
 346   3                              
 347   3                              break;
 348   3                      case ID_SELECTION1:
 349   3                      case ID_SELECTION2:
 350   3                      case ID_SELECTION3:
 351   3                              ZhkHopperTask( &CurrentTask );
 352   3                      //Trace( "\n ZhkSchedulerState = %bu", ZhkSchedulerState );
 353   3                              break;
 354   3                      case ID_ACDCMODULE:
 355   3                          ZhkHopperTask( &CurrentTask );
 356   3                          break;
 357   3                      default:
 358   3                              ZhkSchedulerState = TASK_NULL; 
 359   3                      }
 360   2                      break;
 361   2              default:
 362   2                      ZhkSchedulerState = TASK_NULL; 
 363   2                      break;
 364   2              }
 365   1        
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 7   

 366   1              return ZhkSchedulerState;       
 367   1      }
 368          
 369          uchar ZhkSchedulerAddTask( struct COMMTASK xdata* NewTask )
 370          {
 371   1              uchar data i;
 372   1      //      Trace( "AddTask:Id=%bx,Cmd=%bx\n" , NewTask->Id,NewTask->Cmd );
 373   1              
 374   1              if( NewTask->Id == ID_CASHER )
 375   1              {
 376   2                      if( Casher.CommState == COMM_TIMEOUT )
 377   2                      {
 378   3                              if( QueryCashTimer != 0 )
 379   3                              {
 380   4      //                              Trace( "\n ZhkSchedulerAddTask ->Do not Add Query Commmand1" );
 381   4                                      ZhkCasherStatus = CASHER_STATUS_NULL;
 382   4                                      Casher.ExtState[13] = 1;
 383   4                                      return 1;
 384   4                              }
 385   3                              else
 386   3                              {
 387   4                                      if( ( Casher.ExtState[ 15 ] == 1 ) && ( Casher.ExtState[ 14 ] != 1 ) )
 388   4                                      {
 389   5              //                              Trace( "\n ZhkSchedulerAddTask ->Do not Add Query Commmand2" );
 390   5                                              ZhkCasherStatus = CASHER_STATUS_NULL;
 391   5                                              Casher.ExtState[13] = 1;
 392   5                                              return 1;
 393   5                                      }
 394   4                              }       
 395   3                      }                               
 396   2      //              Trace( "\n ZhkSchedulerAddTask ->Add Query Commmand" );
 397   2              }
 398   1      
 399   1              for( i = 0 ; i < sizeof( ZhkReadyTaskList ) / sizeof( struct COMMTASK ) ; i ++ )
 400   1              {
 401   2                      if ( ZhkSchedulerIsTaskNull( i ) )
 402   2                      {
 403   3                              MovSramToSram( ( uchar xdata* )NewTask , 
 404   3                                      ( uchar xdata* )&ZhkReadyTaskList[ i ] , 
 405   3                                      sizeof( struct COMMTASK ) );
 406   3                              return 1;
 407   3                      }
 408   2              }
 409   1              return 0;
 410   1      }
 411          
 412          bit ZhkSchedulerIsTaskNull( uchar TaskNum )
 413          {
 414   1              if ( TaskNum >= sizeof( ZhkReadyTaskList ) / sizeof( struct COMMTASK ) )
 415   1                      return 0;
 416   1              return ZhkReadyTaskList[ TaskNum ].Id == ID_NULL;
 417   1              
 418   1      }
 419          
 420          uchar ZhkGetSchedulerClock( void )
 421          {
 422   1              uchar data ch;
 423   1              EA = 0;
 424   1              ch = ZhkSchedulerClock;
 425   1              ZhkSchedulerClock = 0;
 426   1              EA = 1;
 427   1              return ch;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 8   

 428   1      }
 429          
 430          bit ZhkNullTask( void )
 431          {
 432   1              uchar  data i;
 433   1              uchar  data clocktemp;
 434   1              uchar  data PriorityTemp;
 435   1              uchar  data TaskIdTemp;
 436   1              //Trace( "ZhkNullTask\n" );
 437   1              // 更新定时查询任务队列中各个任务的等待就绪时间计数
 438   1              clocktemp = ZhkGetSchedulerClock();
 439   1              for( i = 0 ; i < sizeof( ZhkAutoTaskList ) / sizeof( struct AUTOTASK ) ; i ++ )
 440   1              {
 441   2                      if ( ZhkAutoTaskTimer[ i ] > clocktemp ) 
 442   2                              ZhkAutoTaskTimer[ i ] -= clocktemp;
 443   2                      else
 444   2                      {
 445   3                              ZhkAutoTaskTimer[ i ]  = 0;
 446   3                              if ( ZhkAutoTaskPermission[ i ] == 1 ) 
 447   3                              {
 448   4                      //              Trace( "\n AutoTaskNum=%bu", i );
 449   4                                      ZhkAutoTaskTimer[ i ] = ZhkAutoTaskList[ i ].Cycle;
 450   4                                      switch( ZhkAutoTaskList[ i ].Id )
 451   4                                      {
 452   5                                      //      case ID_COINER1:        
 453   5                                      //              if( CoinerStatus == COINER_STATUS_NULL )
 454   5                                      //                      CoinerQuery();
 455   5                                      //              break;                  
 456   5                                              case ID_CASHER: 
 457   5                                                      if( ZhkCasherStatus == CASHER_STATUS_NULL )
 458   5                                                              ZhkCasherQuery();                                       
 459   5                                                      break;
 460   5                                      }
 461   4                              }
 462   3                      }
 463   2              }
 464   1              //Trace( "PriorityTemp = 0xFF\n" );
 465   1              // 选择任务队列中已经满足就绪条件中的优先级最高的任务
 466   1              PriorityTemp = 0xFF;
 467   1              for( i = 0 ; i < sizeof( ZhkReadyTaskList ) / sizeof( struct COMMTASK ) ; i ++ )
 468   1              {
 469   2                      if ( ZhkSchedulerIsTaskNull( i ) ) 
 470   2                              continue;
 471   2                      if ( PriorityTemp > ZhkReadyTaskList[ i ].Priority )
 472   2                      {
 473   3                              PriorityTemp = ZhkReadyTaskList[ i ].Priority;
 474   3                              TaskIdTemp   = i;
 475   3                      }
 476   2              }                       
 477   1              // 没有就绪任务，返回0
 478   1              if ( PriorityTemp == 0xFF ) 
 479   1                      return 0;
 480   1              
 481   1              memcpy( &CurrentTask , &ZhkReadyTaskList[ TaskIdTemp ] , sizeof( struct COMMTASK ) );
 482   1              ZhkSchedulerState = TASK_REDAY; 
 483   1      
 484   1              for( i = TaskIdTemp ; i < ( sizeof( ZhkReadyTaskList ) / sizeof( struct COMMTASK ) - 1 ) ; i ++ )       
 485   1                      memcpy( &ZhkReadyTaskList[ i ] , &ZhkReadyTaskList[ i + 1 ] , sizeof( struct COMMTASK ) );
 486   1              
 487   1              memset( &ZhkReadyTaskList[ sizeof( ZhkReadyTaskList ) / sizeof( struct COMMTASK ) - 1 ] , 0xFF , sizeof( 
             -struct COMMTASK ) );
 488   1              return 1;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 9   

 489   1      }
 490          //////////////////////////////////////////////////////////////////////////////////////////////
 491          
 492          //////////////////////////////////////////////////////////////////////////////////////////////
 493          bit ZhkHopperTask( struct COMMTASK xdata* TaskTemp )
 494          {
 495   1              uchar data StateTemp;
 496   1              
 497   1              switch( ZhkSchedulerState )
 498   1              {
 499   2              case TASK_NULL:
 500   2                      break;
 501   2              case TASK_REDAY:
 502   2              //Trace( "ZhkHopperTaskBegin\n" );
 503   2                      ZhkChannelSwitch( EQUIP_HOPPER );
 504   2                      if( ZhkHopperTxMsg( TaskTemp ) )
 505   2                              ZhkSchedulerState = TASK_WAIT;
 506   2                      else
 507   2                              ZhkSchedulerState = TASK_FINISH;
 508   2                  //Trace( "\n ZhkHopperTxMsgOK" );           
 509   2                      ZhkDownMsgAckTimer  = 80;
 510   2                      switch( TaskTemp->Id - ID_HOPPER1 )
 511   2                      {
 512   3                      case 0:
 513   3                              Hopper1.CommState = COMM_BUZY;
 514   3                              break;
 515   3                      case 1:
 516   3                              Hopper2.CommState = COMM_BUZY;
 517   3                              break;
 518   3                      case 2:
 519   3                              Hopper3.CommState = COMM_BUZY;
 520   3                              break;
 521   3              case ID_SELECTION1:
 522   3                          Selection1.CommState = COMM_BUZY;
 523   3                              break;
 524   3              case ID_SELECTION2:
 525   3                          Selection2.CommState = COMM_BUZY;
 526   3                              break;
 527   3                      case ID_SELECTION3:
 528   3                          Selection3.CommState = COMM_BUZY;
 529   3                              break;
 530   3                      case ID_ACDCMODULE:
 531   3                          ACDCModule.CommState = COMM_BUZY;
 532   3                          break;
 533   3                      default:
 534   3                              ZhkSchedulerState = TASK_NULL; 
 535   3                      }
 536   2                      break;
 537   2              case TASK_WAIT:
 538   2              //Trace( "\n HOPPERTASK_WAIT" );
 539   2                      StateTemp = ZhkHopperMsgProcess();
 540   2                  //Trace( "\n StateTemp = %bu", StateTemp );
 541   2                      if ( StateTemp == 1 )
 542   2                      {
 543   3                              ZhkSchedulerState = TASK_FINISH;
 544   3                              break;
 545   3                      }
 546   2                      if( ZhkDownMsgAckTimer == 0 )
 547   2                      {
 548   3                  //Trace( "\n HOPPERTASK_WAIT" );    
 549   3                              //发送                  
 550   3                              if ( ZhkHopperTxMsg( TaskTemp ) )
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 10  

 551   3                                      ZhkSchedulerState = TASK_REWAIT;
 552   3                              else
 553   3                                      ZhkSchedulerState = TASK_FINISH;
 554   3                              
 555   3                              if( TaskTemp->Cmd == HOPPER_OUTPUT )
 556   3                                      ZhkDownMsgAckTimer  = 80;           //DOWNMSGACKTIMEOUT;
 557   3                              else if( TaskTemp->Cmd == HOPPER_QUERY )
 558   3                                      ZhkDownMsgAckTimer  = 80;
 559   3                      }               
 560   2                      break;
 561   2              case TASK_REWAIT:
 562   2                  //Trace( "\n HOPPER RETASK_WAIT" );
 563   2                      StateTemp = ZhkHopperMsgProcess();
 564   2                      if ( StateTemp == 1 )
 565   2                      {
 566   3                              ZhkSchedulerState = TASK_FINISH;
 567   3                              break;
 568   3                      }
 569   2                      if ( ZhkDownMsgAckTimer == 0 )
 570   2                      {
 571   3                              ZhkSchedulerState = TASK_ERROR;
 572   3                      }
 573   2                      break;
 574   2              case TASK_FINISH:
 575   2              //Trace( "\n HOPPER TASK_FINISH" );             
 576   2                      switch( TaskTemp->Id - ID_HOPPER1 )
 577   2                      {
 578   3                      case 0:
 579   3                              Hopper1.CommState = COMM_COMMOK;
 580   3                              break;
 581   3                      case 1:
 582   3                              Hopper2.CommState = COMM_COMMOK;
 583   3                              break;
 584   3                      case 2:
 585   3                              Hopper3.CommState = COMM_COMMOK;
 586   3                              break;
 587   3                      case ID_SELECTION1:
 588   3                          Selection1.CommState = COMM_COMMOK;
 589   3                              break;
 590   3              case ID_SELECTION2:
 591   3                          Selection2.CommState = COMM_COMMOK;
 592   3                              break;
 593   3                      case ID_SELECTION3:
 594   3                          Selection3.CommState = COMM_COMMOK;
 595   3                              break;
 596   3                      case ID_ACDCMODULE:
 597   3                          ACDCModule.CommState = COMM_COMMOK;
 598   3                          break;
 599   3                      default:
 600   3                              ZhkSchedulerState = TASK_NULL; 
 601   3                      }
 602   2                      ZhkSchedulerState = TASK_NULL; 
 603   2                      break;
 604   2              case TASK_ERROR:
 605   2                      switch( TaskTemp->Id - ID_HOPPER1 )
 606   2                      {
 607   3                      case 0:
 608   3                              Hopper1.CommState = COMM_TIMEOUT;  //| COMM_COMMOK;
 609   3                              break;
 610   3                      case 1:
 611   3                              Hopper2.CommState = COMM_TIMEOUT;  //| COMM_COMMOK;
 612   3                              break;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 11  

 613   3                      case 2:
 614   3                              Hopper3.CommState = COMM_TIMEOUT;  //| COMM_COMMOK;
 615   3                              break;
 616   3                      case ID_SELECTION1:
 617   3                          Selection1.CommState = COMM_TIMEOUT;
 618   3                              break;
 619   3              case ID_SELECTION2:
 620   3                          Selection2.CommState = COMM_TIMEOUT;
 621   3                              break;
 622   3                      case ID_SELECTION3:
 623   3                          Selection3.CommState = COMM_TIMEOUT;
 624   3                              break;
 625   3                      case ID_ACDCMODULE:
 626   3                          ACDCModule.CommState = COMM_TIMEOUT;
 627   3                          break;
 628   3                      default:
 629   3                              ZhkSchedulerState = TASK_NULL; 
 630   3                      }
 631   2                      ZhkSchedulerState = TASK_NULL; 
 632   2                      break;
 633   2              default:
 634   2                      ZhkSchedulerState = TASK_NULL;
 635   2              }
 636   1              return 1;
 637   1      }
 638          
 639          
 640          bit ZhkLcdTask( struct COMMTASK xdata* TaskTemp )
 641          {
 642   1              uchar data StateTemp;
 643   1              
 644   1              switch( ZhkSchedulerState )
 645   1              {
 646   2              case TASK_NULL:
 647   2                      break;
 648   2              case TASK_REDAY:
 649   2                      ZhkChannelSwitch( EQUIP_LCD );
 650   2                      if ( ZhkLcdTxMsg( TaskTemp ) )
 651   2                              ZhkSchedulerState = TASK_WAIT;
 652   2                      else
 653   2                              ZhkSchedulerState = TASK_FINISH;
 654   2                      ZhkDownMsgAckTimer = 60;
 655   2                      Lcd.CommState   = COMM_BUZY;
 656   2                      break;
 657   2              case TASK_WAIT:
 658   2                      StateTemp = ZhkLcdMsgProcess();
 659   2                      if ( StateTemp == 1 )
 660   2                      {               
 661   3                              ZhkSchedulerState = TASK_FINISH;
 662   3                              break;
 663   3                      }
 664   2                      if ( ZhkDownMsgAckTimer == 0 )
 665   2                      {
 666   3                              Lcd.Sn --;
 667   3                              if ( ZhkLcdTxMsg( TaskTemp ) )                                                  
 668   3                                      ZhkSchedulerState = TASK_REWAIT;
 669   3                      
 670   3                              else                    
 671   3                                      ZhkSchedulerState = TASK_FINISH;                        
 672   3                              ZhkDownMsgAckTimer = DOWNMSGACKTIMEOUT;
 673   3                      }
 674   2                      
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 12  

 675   2                      break;
 676   2              case TASK_REWAIT:               
 677   2                      StateTemp = ZhkLcdMsgProcess();
 678   2                      if ( StateTemp == 1 )
 679   2                      {
 680   3                              ZhkSchedulerState = TASK_FINISH;
 681   3                              break;
 682   3                      }
 683   2                      if ( ZhkDownMsgAckTimer == 0 )
 684   2                      {
 685   3                              ZhkSchedulerState = TASK_ERROR;
 686   3                      }
 687   2                      break;
 688   2              case TASK_FINISH:               
 689   2                      ZhkSchedulerState = TASK_NULL; 
 690   2                      Lcd.CommState     = COMM_COMMOK;
 691   2                      Lcd.ExtState[1] = 0;
 692   2                      break;
 693   2              case TASK_ERROR:
 694   2                      Lcd.CommState  = COMM_TIMEOUT;// | COMM_COMMOK;
 695   2                      ZhkSchedulerState = TASK_NULL; 
 696   2                      Lcd.ExtState[1] = 1;
 697   2                      break;
 698   2              default:
 699   2                      ZhkSchedulerState = TASK_NULL;
 700   2              }
 701   1              return 1;
 702   1      }
 703          
 704          ////////////////////////////////////////////////////////////////////////////////////////////
 705          
 706          ////////////////////////////////////////////////////////////////////////////////////////////
 707          
 708          bit ZhkHopperTxMsg( struct COMMTASK xdata* NewTask )
 709          {
 710   1              uchar data HopperNum;
 711   1              struct DEVICE xdata* data CurrentHopper;  //Why?
 712   1              
 713   1              // 选择出币机构
 714   1              HopperNum = NewTask->Id - ID_HOPPER1;
 715   1              switch( HopperNum )
 716   1              {
 717   2              case 0:
 718   2                      CurrentHopper = &Hopper1;
 719   2              /*      if( Hopper1.Sn < 255 )
 720   2                              Hopper1.Sn++;
 721   2                      else
 722   2                              Hopper1.Sn = 0;*/
 723   2                      break;
 724   2              case 1:
 725   2              //      Trace("\n ZhkHopperTxMsg HopperOutput2");
 726   2                      CurrentHopper = &Hopper2;
 727   2              /*      if( Hopper2.Sn < 255 )
 728   2                              Hopper2.Sn++;
 729   2                      else
 730   2                              Hopper2.Sn = 0;*/
 731   2                      break;
 732   2              case 2:
 733   2                      CurrentHopper = &Hopper3;
 734   2              /*      if( Hopper3.Sn < 255 )
 735   2                              Hopper3.Sn++;
 736   2                      else
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 13  

 737   2                              Hopper3.Sn = 0;*/
 738   2                      break;
 739   2              //----------------------------------------------
 740   2              case ID_SELECTION1:
 741   2                  CurrentHopper = &Selection1;
 742   2                      break;
 743   2          case ID_SELECTION2:
 744   2                  CurrentHopper = &Selection2;
 745   2                      break;
 746   2              case ID_SELECTION3:
 747   2                  CurrentHopper = &Selection3;
 748   2                      break;
 749   2              case ID_ACDCMODULE:
 750   2                  CurrentHopper = &ACDCModule;
 751   2                  break;
 752   2              //===============================================
 753   2              default:
 754   2                      return 0;
 755   2              }
 756   1      //      Trace("\n ZhkHopperTxMsg" );
 757   1              ZhkBusTxMsg( NewTask );         
 758   1              return 1;       
 759   1      }
 760          
 761          bit ZhkLcdTxMsg( struct COMMTASK xdata* NewTask )
 762          {
 763   1              // 更新sn计数
 764   1              Lcd.Sn ++;
 765   1              if ( Lcd.Sn == 0 ) Lcd.Sn ++;
 766   1              NewTask->Sn = Lcd.Sn;
 767   1              ZhkBusTxMsg( NewTask ); 
 768   1              
 769   1              return 1;
 770   1      }
 771          ////////////////////////////////////////////////////////////////////////////////////////////
 772          
 773          ////////////////////////////////////////////////////////////////////////////////////////////
 774          
 775          ////////////////////////////////////////////////////////////////////////////////////////////
 776          
 777          
 778          ////////////////////////////////////////////////////////////////////////////////////////////
 779          uchar ZhkHopperMsgProcess( void )
 780          {       
 781   1          struct COMMTASK xdata AckTask;
 782   1              memset( &AckTask, 0, sizeof( struct COMMTASK ) );
 783   1              memcpy( &AckTask, &CurrentTask, sizeof( struct COMMTASK ) );
 784   1      
 785   1          //Trace( "\n AckTask.Sn = %bu", AckTask.Sn );
 786   1              if ( ZhkBusFrameUnPack( &AckTask ) == 0 )
 787   1              {
 788   2                      return 0;       
 789   2              }
 790   1              switch( CurrentTask.Id - ID_HOPPER1 )
 791   1              {
 792   2                      case 0:
 793   2                      //Trace( "\n AckTask.State = %02bx", AckTask.State );
 794   2                              Hopper1.State = 0;
 795   2                              Hopper1.State = AckTask.State;          
 796   2                              break;
 797   2                      case 1:
 798   2                              Hopper2.State = 0;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 14  

 799   2                              Hopper2.State = AckTask.State;
 800   2                              break;
 801   2                      case 2:
 802   2                              Hopper3.State = 0;
 803   2                              Hopper3.State = AckTask.State;
 804   2                              break;
 805   2                      case ID_SELECTION1:
 806   2                          Selection1.State = 0;
 807   2                              Selection1.State = AckTask.State;
 808   2                              break;
 809   2                      case ID_SELECTION2:
 810   2                          Selection2.State = 0;
 811   2                              Selection2.State = AckTask.State;
 812   2                              break;
 813   2                      case ID_SELECTION3:
 814   2                          Selection3.State = 0;
 815   2                              Selection3.State = AckTask.State;
 816   2                              break;
 817   2                      case ID_ACDCMODULE:
 818   2                          //ACDCModule.State = 0;
 819   2                              ACDCModule.State = AckTask.State;
 820   2                          break;
 821   2              }
 822   1              
 823   1          //Trace( "\n ZhkHopperMsgProcess OK");
 824   1              switch( CurrentTask.Cmd  )
 825   1              {
 826   2                      case HOPPER_OUTPUT:             
 827   2                              break;
 828   2                      case HOPPER_QUERY:
 829   2                              switch( CurrentTask.Id - ID_HOPPER1 )
 830   2                              {
 831   3                              case 0:
 832   3                                      Hopper1.ExtState[ 0 ] = AckTask.Param[ 0 ];
 833   3                                      Hopper1.ExtState[ 1 ] = AckTask.Param[ 1 ];
 834   3                                      break;
 835   3                              case 1:
 836   3                                      Hopper2.ExtState[ 0 ] = AckTask.Param[ 0 ];
 837   3                                      Hopper2.ExtState[ 1 ] = AckTask.Param[ 1 ];
 838   3                                      break;
 839   3                              case 2:
 840   3                                      Hopper3.ExtState[ 0 ] = AckTask.Param[ 0 ];
 841   3                                      Hopper3.ExtState[ 1 ] = AckTask.Param[ 1 ];
 842   3                                      break;
 843   3      
 844   3                              case ID_SELECTION1:
 845   3                                      Selection1.ExtState[ 0 ] = AckTask.Param[ 0 ];
 846   3                                      Selection1.ExtState[ 1 ] = AckTask.Param[ 1 ];
 847   3                                      break;
 848   3                              case ID_SELECTION2:
 849   3                                      Selection2.ExtState[ 0 ] = AckTask.Param[ 0 ];
 850   3                                      Selection2.ExtState[ 1 ] = AckTask.Param[ 1 ];
 851   3                                      break;
 852   3                              case ID_SELECTION3:
 853   3                                      Selection3.ExtState[ 0 ] = AckTask.Param[ 0 ];
 854   3                                      Selection3.ExtState[ 1 ] = AckTask.Param[ 1 ];
 855   3                                      break;
 856   3                  case ID_ACDCMODULE:
 857   3                                      ACDCModule.ExtState[ 0 ] = AckTask.Param[ 0 ];
 858   3                                      ACDCModule.ExtState[ 1 ] = AckTask.Param[ 1 ];
 859   3                                      break;
 860   3                              }
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 15  

 861   2                              break;
 862   2                      default:
 863   2                              return 0;
 864   2              }
 865   1          //Trace( "ZhkHopperMsgProcessOver\n" );
 866   1              return 1;       
 867   1      }
 868          
 869          
 870          uchar ZhkLcdMsgProcess( void )
 871          {
 872   1              struct COMMTASK xdata AckTask;
 873   1              
 874   1              
 875   1              if ( ZhkBusFrameUnPack( &AckTask ) == 0 )
 876   1                      return 0;
 877   1              if ( CurrentTask.Id  != AckTask.Id  ) 
 878   1                      return 0;
 879   1              if ( CurrentTask.Sn  != AckTask.Sn  ) 
 880   1                      return 0;
 881   1              Lcd.State = AckTask.State;
 882   1              switch( CurrentTask.Cmd  )
 883   1              {
 884   2                      case DISPKEY_DISP:              
 885   2                      case DISPKEY_DISPS:
 886   2                      case DISPKEY_SETCURSOR:
 887   2                      case DISPKEY_CURSORSTYLE:
 888   2                      case DISPKEY_DENOTE:
 889   2                      case DISPKEY_SCROLL:
 890   2                      case DISPKEY_CLEAR:
 891   2                      case DISPKEY_LANGUAGE:
 892   2                              break;          
 893   2                      default:
 894   2                              return 0;
 895   2              }
 896   1              return 1;
 897   1      }
 898          ////////////////////////////////////////////////////////////////////////////////////////////
 899          ////////////////////////////////////////////////////////////////////////////////////////////
 900          
 901          uchar TestDeviceBuzy( struct DEVICE xdata* Device )
 902          {
 903   1              return( Device->CommState & COMM_BUZY );
 904   1      }
 905          
 906          uchar TestDeviceTimeOut( struct DEVICE xdata* Device )
 907          {
 908   1              uchar data ch;
 909   1      
 910   1              ch = Device->CommState;
 911   1              Device->CommState &= ~ COMM_TIMEOUT;
 912   1      
 913   1              return( ch & COMM_TIMEOUT );
 914   1      }
 915          
 916          uchar TestDeviceException( struct DEVICE xdata* Device )
 917          {
 918   1              if( ( Device == &Hopper1 ) || ( Device == &Hopper2 ) || ( Device == &Hopper3 ) )
 919   1              {               
 920   2                      if( ( Device->State & 0x16 ) || ( Device->State == 0 ) )
 921   2                              return 0;//正常
 922   2                      else
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 16  

 923   2                              return 1;//故障
 924   2              }
 925   1              else
 926   1                      return( Device->State & 0x40 );
 927   1      }
 928          
 929          uchar TestDeviceCommOK( struct DEVICE xdata* Device )
 930          {
 931   1              uchar data ch;
 932   1              
 933   1              ch = Device->CommState;
 934   1              Device->CommState &= ~ COMM_COMMOK;
 935   1              return( ch & COMM_COMMOK );
 936   1      }
 937          
 938          ////////////////////////////////////////////////////////////////////////////////////////////
 939          //                                                                                        
 940          //         出币机构接口函数
 941          //
 942          ////////////////////////////////////////////////////////////////////////////////////////////
 943          bit Selection1Query( void )
 944          {
 945   1              struct COMMTASK xdata TaskTemp;
 946   1      
 947   1              TaskTemp.Id               = ID_SELECTION1;
 948   1              TaskTemp.Cmd              = HOPPER_QUERY;
 949   1              TaskTemp.Sn                   = Selection1.Sn;
 950   1              TaskTemp.Priority     = PRIORITY_NORMAL;
 951   1              TaskTemp.ParamLen         = 2;
 952   1      
 953   1          //if( HardWareErr > 0 )
 954   1          //只有暂停服务模式，才关闭指示灯;by gzz 20110727
 955   1          if( ( HardWareErr > 0 ) && (sysVPMission.SystemState != 1) )
 956   1              {
 957   2                  TaskTemp.Param[0] = 0; 
 958   2              TaskTemp.Param[1] = 0xff;   
 959   2              }
 960   1              else
 961   1              {
 962   2                      TaskTemp.Param[0] = sysVPMission.sel1ReadyLed;
 963   2                      TaskTemp.Param[1] = sysVPMission.sel1ErrLed;
 964   2          }
 965   1      
 966   1              return ZhkSchedulerAddTask( &TaskTemp );        
 967   1      }
 968          
 969          bit Selection2Query( void )
 970          {
 971   1              struct COMMTASK xdata TaskTemp;
 972   1      
 973   1              TaskTemp.Id               = ID_SELECTION2;
 974   1              TaskTemp.Cmd              = HOPPER_QUERY;
 975   1              TaskTemp.Sn                   = Selection2.Sn;
 976   1              TaskTemp.Priority     = PRIORITY_NORMAL;
 977   1              TaskTemp.ParamLen         = 2;
 978   1      
 979   1              //if( HardWareErr > 0 )
 980   1          //只有暂停服务模式，才关闭指示灯;by gzz 20110727
 981   1          if( ( HardWareErr > 0 ) && (sysVPMission.SystemState != 1) )
 982   1              {
 983   2                  TaskTemp.Param[0] = 0; 
 984   2              TaskTemp.Param[1] = 0xff;   
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 17  

 985   2              }
 986   1              else
 987   1              {
 988   2                      TaskTemp.Param[0] = sysVPMission.sel2ReadyLed;
 989   2                      TaskTemp.Param[1] = sysVPMission.sel2ErrLed;
 990   2          }
 991   1              return ZhkSchedulerAddTask( &TaskTemp );        
 992   1      }
 993          
 994          bit Selection3Query( void )
 995          {
 996   1              struct COMMTASK xdata TaskTemp;
 997   1      
 998   1              TaskTemp.Id               = ID_SELECTION3;
 999   1              TaskTemp.Cmd              = HOPPER_QUERY;
1000   1              TaskTemp.Sn                   = Selection3.Sn;
1001   1              TaskTemp.Priority     = PRIORITY_NORMAL;
1002   1              TaskTemp.ParamLen         = 2;
1003   1      
1004   1              //if( HardWareErr > 0 )
1005   1          //只有暂停服务模式，才关闭指示灯;by gzz 20110727
1006   1          if( ( HardWareErr > 0 ) && (sysVPMission.SystemState != 1) )
1007   1              {
1008   2                  TaskTemp.Param[0] = 0; 
1009   2              TaskTemp.Param[1] = 0xff;   
1010   2              }
1011   1              else
1012   1              {
1013   2                      TaskTemp.Param[0] = sysVPMission.sel3ReadyLed;
1014   2                      TaskTemp.Param[1] = sysVPMission.sel3ErrLed;
1015   2          }
1016   1      
1017   1              return ZhkSchedulerAddTask( &TaskTemp );        
1018   1      }
1019          
1020          bit SelectionQuery( uchar itemNum )
1021          {
1022   1              switch( itemNum )
1023   1              {
1024   2               case 1:
1025   2                      return Selection1Query();
1026   2                      break;
1027   2               case 2:
1028   2                      return Selection2Query();
1029   2                      break;
1030   2               case 3:
1031   2                      return Selection3Query();       
1032   2                      break;
1033   2           case 4:
1034   2              return ACDCModuleQuery();
1035   2              break;
1036   2              }
1037   1              return 1;
1038   1      }
1039          
1040          
1041          bit ACDCModuleQuery( void )
1042          {
1043   1              struct COMMTASK xdata TaskTemp;
1044   1              TaskTemp.Id       = ID_ACDCMODULE;
1045   1              TaskTemp.Cmd      = HOPPER_QUERY;
1046   1              TaskTemp.Sn               = ACDCModule.Sn;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 18  

1047   1              TaskTemp.Priority = PRIORITY_NORMAL;
1048   1              TaskTemp.ParamLen = 2;
1049   1          /*
1050   1              if( HardWareErr > 0 )
1051   1              {
1052   1                  TaskTemp.Param[0] = 0; 
1053   1              TaskTemp.Param[1] = 0;   
1054   1              }
1055   1              else
1056   1              */
1057   1              {
1058   2                      TaskTemp.Param[0] = sysVPMission.ACDCLedCtr;
1059   2                      TaskTemp.Param[1] = sysVPMission.ACDCCompressorCtr;
1060   2          }
1061   1              return ZhkSchedulerAddTask( &TaskTemp );        
1062   1      }
1063          
1064          
1065          bit ZhkHopper1Query( void )
1066          {
1067   1              struct COMMTASK xdata TaskTemp;
1068   1      
1069   1              TaskTemp.Id             = ID_HOPPER1;
1070   1              TaskTemp.Cmd            = HOPPER_QUERY;
1071   1              TaskTemp.Sn             = Hopper1.Sn;
1072   1              TaskTemp.Priority       = PRIORITY_NORMAL;
1073   1              TaskTemp.ParamLen       = 2;
1074   1              TaskTemp.Param[ 0 ]     = 0;
1075   1              TaskTemp.Param[ 1 ]     = 0;
1076   1              return ZhkSchedulerAddTask( &TaskTemp );        
1077   1      }
1078          
1079          bit ZhkHopper2Query( void )
1080          {
1081   1              struct COMMTASK xdata TaskTemp;
1082   1      
1083   1              TaskTemp.Id             = ID_HOPPER2;
1084   1              TaskTemp.Cmd            = HOPPER_QUERY;
1085   1              TaskTemp.Sn             = Hopper2.Sn;
1086   1              TaskTemp.Priority = PRIORITY_NORMAL;
1087   1              TaskTemp.ParamLen       = 2;
1088   1              TaskTemp.Param[ 0 ]     = 0;
1089   1              TaskTemp.Param[ 1 ]     = 0;
1090   1              return ZhkSchedulerAddTask( &TaskTemp );        
1091   1      }
1092          
1093          bit ZhkHopper3Query( void )
1094          {
1095   1              struct COMMTASK xdata TaskTemp;
1096   1      
1097   1              TaskTemp.Id             = ID_HOPPER3;
1098   1              TaskTemp.Cmd            = HOPPER_QUERY;
1099   1              TaskTemp.Sn             = Hopper3.Sn;
1100   1              TaskTemp.Priority = PRIORITY_NORMAL;
1101   1              TaskTemp.ParamLen       = 2;
1102   1              TaskTemp.Param[ 0 ]     = 0;
1103   1              TaskTemp.Param[ 1 ]     = 0;
1104   1              return ZhkSchedulerAddTask( &TaskTemp );        
1105   1      }
1106          
1107          bit HopperQuery( uchar HopperNum )
1108          {
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 19  

1109   1              switch( HopperNum )
1110   1              {
1111   2              case 1:
1112   2                      return ZhkHopper1Query();
1113   2                      break;
1114   2              case 2:
1115   2                      return ZhkHopper2Query();
1116   2                      break;
1117   2               case 3:
1118   2                      return ZhkHopper3Query();       
1119   2                      break;
1120   2              }
1121   1              return 1;
1122   1      }
1123          
1124          
1125          //---------------------------------------------
1126          //Clear SN
1127          bit ZhkHopper1ClearSn( void )
1128          {
1129   1              struct COMMTASK xdata TaskTemp;
1130   1          
1131   1              Hopper1.Sn = 0;
1132   1              TaskTemp.Id    = ID_HOPPER1;
1133   1              TaskTemp.Cmd   = HOPPER_OUTPUT;
1134   1              TaskTemp.Sn        = Hopper1.Sn;
1135   1              TaskTemp.Priority   = PRIORITY_NORMAL;
1136   1              TaskTemp.ParamLen       = 2;
1137   1              TaskTemp.Param[ 0 ] = 0;
1138   1              TaskTemp.Param[ 1 ] = 0;
1139   1              return ZhkSchedulerAddTask( &TaskTemp );        
1140   1      }
1141          
1142          bit ZhkHopper2ClearSn( void )
1143          {
1144   1              struct COMMTASK xdata TaskTemp;
1145   1      
1146   1              Hopper2.Sn = 0;
1147   1              TaskTemp.Id     = ID_HOPPER2;
1148   1              TaskTemp.Cmd    = HOPPER_OUTPUT;
1149   1              TaskTemp.Sn             = Hopper2.Sn;
1150   1              TaskTemp.Priority = PRIORITY_NORMAL;
1151   1              TaskTemp.ParamLen       = 2;
1152   1              TaskTemp.Param[ 0 ]     = 0;
1153   1              TaskTemp.Param[ 1 ]     = 0;
1154   1              return ZhkSchedulerAddTask( &TaskTemp );        
1155   1      }
1156          
1157          bit ZhkHopper3ClearSn( void )
1158          {
1159   1              struct COMMTASK xdata TaskTemp;
1160   1      
1161   1              Hopper3.Sn = 0;
1162   1              TaskTemp.Id     = ID_HOPPER3;
1163   1              TaskTemp.Cmd    = HOPPER_OUTPUT;
1164   1              TaskTemp.Sn             = Hopper3.Sn;
1165   1              TaskTemp.Priority = PRIORITY_NORMAL;
1166   1              TaskTemp.ParamLen       = 2;
1167   1              TaskTemp.Param[ 0 ]     = 0;
1168   1              TaskTemp.Param[ 1 ]     = 0;
1169   1              return ZhkSchedulerAddTask( &TaskTemp );        
1170   1      }
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 20  

1171          
1172          bit HopperClearSn( uchar HopperNum )
1173          {
1174   1              switch( HopperNum )
1175   1              {
1176   2              case 1:
1177   2                      return ZhkHopper1ClearSn();
1178   2                      break;
1179   2              case 2:
1180   2                      return ZhkHopper2ClearSn();
1181   2                      break;
1182   2               case 3:
1183   2                      return ZhkHopper3ClearSn();     
1184   2                      break;
1185   2              }
1186   1              return 1;
1187   1      }
1188          //====================================================
1189          
1190          
1191          bit HopperOutput( uchar HopperNum , uint CoinAmount )
1192          {
1193   1              struct COMMTASK xdata TaskTemp;
1194   1      //      Trace("\nHopperOutput");
1195   1              switch( HopperNum )
1196   1              {
1197   2              case 1:
1198   2                      if ( Hopper1.CommState & COMM_BUZY ) 
1199   2                              return 0;
1200   2              //      Hopper1.CommState = COMM_BUZY;
1201   2                      if ( HopperNum > 8 ) 
1202   2                              return 0;
1203   2      
1204   2                      if( Hopper1.Sn < 255 )
1205   2                              Hopper1.Sn++;
1206   2                      else
1207   2                              Hopper1.Sn = 0;
1208   2      
1209   2                      TaskTemp.Id             = ID_HOPPER1;
1210   2                      TaskTemp.Cmd            = HOPPER_OUTPUT ;
1211   2                      TaskTemp.Sn             = Hopper1.Sn;
1212   2                      TaskTemp.Priority       = PRIORITY1;
1213   2                      TaskTemp.ParamLen       = 2;
1214   2                      TaskTemp.Param[ 0 ]     = CoinAmount % 256;
1215   2                      TaskTemp.Param[ 1 ]     = CoinAmount / 256;
1216   2      
1217   2                      return ZhkSchedulerAddTask( &TaskTemp );
1218   2                      break;
1219   2              case 2:                 
1220   2                      if ( Hopper2.CommState & COMM_BUZY ) 
1221   2                              return 0;
1222   2              //      Hopper2.CommState = COMM_BUZY;
1223   2                      if ( HopperNum > 8 ) 
1224   2                              return 0;
1225   2      
1226   2                       if( Hopper2.Sn < 255 )
1227   2                              Hopper2.Sn++;
1228   2                      else
1229   2                              Hopper2.Sn = 0;
1230   2      
1231   2                      TaskTemp.Id             = ID_HOPPER2;
1232   2                      TaskTemp.Cmd            = HOPPER_OUTPUT ;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 21  

1233   2                      TaskTemp.Sn             = Hopper2.Sn;
1234   2                      TaskTemp.Priority       = PRIORITY1;
1235   2                      TaskTemp.ParamLen       = 2;
1236   2                      TaskTemp.Param[ 0 ]     = CoinAmount % 256;
1237   2                      TaskTemp.Param[ 1 ]     = CoinAmount / 256;
1238   2              //      Trace("\n HopperOutput2");
1239   2                      return ZhkSchedulerAddTask( &TaskTemp );        
1240   2                      break;
1241   2              case 3:
1242   2                      if ( Hopper3.CommState & COMM_BUZY ) 
1243   2                              return 0;
1244   2      //              Hopper3.CommState = COMM_BUZY;
1245   2                      if ( HopperNum > 8 ) 
1246   2                              return 0;
1247   2      
1248   2                      if( Hopper3.Sn < 255 )
1249   2                              Hopper3.Sn++;
1250   2                      else
1251   2                              Hopper3.Sn = 0;
1252   2      
1253   2                      TaskTemp.Id             = ID_HOPPER3;
1254   2                      TaskTemp.Cmd            = HOPPER_OUTPUT ;
1255   2                      TaskTemp.Sn             = Hopper3.Sn;
1256   2                      TaskTemp.Priority       = PRIORITY1;
1257   2                      TaskTemp.ParamLen       = 2;
1258   2                      TaskTemp.Param[ 0 ]     = CoinAmount % 256;
1259   2                      TaskTemp.Param[ 1 ]     = CoinAmount / 256;
1260   2                      return ZhkSchedulerAddTask( &TaskTemp );        
1261   2                      break;
1262   2              }
1263   1      }
1264          
1265          uint HopperGetCoinOut( uchar HopperNum )
1266          {
1267   1              uint data ch;
1268   1              
1269   1              switch( HopperNum )
1270   1              {
1271   2              case 1:
1272   2                      ch = Hopper1.ExtState[ 1 ] * 256 + Hopper1.ExtState[ 0 ];
1273   2                      break;
1274   2              case 2:
1275   2                      ch = Hopper2.ExtState[ 1 ] * 256 + Hopper2.ExtState[ 0 ];
1276   2                      break;
1277   2              case 3:
1278   2                      ch = Hopper3.ExtState[ 1 ] * 256 + Hopper3.ExtState[ 0 ];
1279   2                      break;
1280   2              }
1281   1              return ch;
1282   1      }
1283          ////////////////////////////////////////////////////////////////////////////////////////////
1284          //
1285          //       辅助模块hub
1286          //
1287          ////////////////////////////////////////////////////////////////////////////////////////////
1288          /*
1289          bit DenoteLedLightOn( void )
1290          {
1291                  struct COMMTASK xdata TaskTemp;
1292                  
1293                  TaskTemp.Id             = ID_HUB;
1294                  TaskTemp.Cmd            = HUB_DENOTE;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 22  

1295                  TaskTemp.Sn             = Hub.Sn;
1296                  TaskTemp.Priority       = PRIORITY_NORMAL;
1297                  TaskTemp.ParamLen       = 1;
1298                  TaskTemp.Param[ 0 ]     = 1;
1299                  return ZhkSchedulerAddTask( &TaskTemp );
1300          }
1301          
1302          bit DenoteLedLightOff( void )
1303          {
1304                  struct COMMTASK xdata TaskTemp;
1305                  
1306                  TaskTemp.Id             = ID_HUB;
1307                  TaskTemp.Cmd            = HUB_DENOTE;
1308                  TaskTemp.Sn             = Hub.Sn;
1309                  TaskTemp.Priority       = PRIORITY_NORMAL;
1310                  TaskTemp.ParamLen       = 1;
1311                  TaskTemp.Param[ 0 ]     = 0;
1312                  return ZhkSchedulerAddTask( &TaskTemp );
1313          }
1314          
1315          
1316          bit SetAlertOn( void )
1317          {
1318                  struct COMMTASK xdata TaskTemp;
1319                  
1320                  TaskTemp.Id             = ID_HUB;
1321                  TaskTemp.Cmd            = HUB_BUZZER;
1322                  TaskTemp.Sn             = Hub.Sn;
1323                  TaskTemp.Priority       = PRIORITY_NORMAL;
1324                  TaskTemp.ParamLen       = 1;
1325                  TaskTemp.Param[ 0 ]     = 1;
1326                  return ZhkSchedulerAddTask( &TaskTemp );
1327          }
1328          
1329          bit SetAlertOff( void )
1330          {
1331                  struct COMMTASK xdata TaskTemp;
1332                  
1333                  TaskTemp.Id             = ID_HUB;
1334                  TaskTemp.Cmd            = HUB_BUZZER;
1335                  TaskTemp.Sn             = Hub.Sn;
1336                  TaskTemp.Priority       = PRIORITY_NORMAL;
1337                  TaskTemp.ParamLen       = 1;
1338                  TaskTemp.Param[ 0 ]     = 0;
1339                  return ZhkSchedulerAddTask( &TaskTemp );
1340          }
1341          */
1342          ////////////////////////////////////////////////////////////////////////////////////////////
1343          //
1344          ////////////////////////////////////////////////////////////////////////////////////////////
1345          bit DisplaycharacterSet( uint CharSetCode )
1346          {
1347   1      /*      uchar code* CharSetCodeTable[] = 
1348   1              {
1349   1              "GB2312" ,
1350   1              "WIN1252"
1351   1              };*/
1352   1              struct COMMTASK xdata TaskTemp;
1353   1              
1354   1              memset( &TaskTemp, 0, sizeof(struct COMMTASK) );        
1355   1              TaskTemp.Id             = ID_LCD;
1356   1              TaskTemp.Cmd            = DISPKEY_LANGUAGE;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 23  

1357   1              TaskTemp.Sn             = Lcd.Sn;
1358   1              TaskTemp.Priority       = PRIORITY_NORMAL;
1359   1              switch( CharSetCode )
1360   1              {
1361   2              case CS_GB2312:
1362   2                      memcpy( TaskTemp.Param, "GB2312", 6 );
1363   2      //              strcpy( TaskTemp.Param , CharSetCodeTable[ 0 ] );
1364   2                      TaskTemp.ParamLen = 6;  //strlen( CharSetCodeTable[ 0 ] );
1365   2                      break;
1366   2              case CS_WIN1252:                
1367   2      //              strcpy( TaskTemp.Param , CharSetCodeTable[ 1 ] );
1368   2                      memcpy( TaskTemp.Param, "WIN1252", 7 );
1369   2                      TaskTemp.ParamLen = 7; //strlen( CharSetCodeTable[ 1 ] );
1370   2                      break;
1371   2              default:
1372   2                      return 0;
1373   2              }
1374   1      
1375   1              return ZhkSchedulerAddTask( &TaskTemp );
1376   1      }
1377          
1378          bit DisplayClear( void )
1379          {
1380   1              struct COMMTASK xdata TaskTemp;
1381   1              
1382   1              memset( &TaskTemp, 0, sizeof(struct COMMTASK) );        
1383   1              TaskTemp.Id             = ID_LCD;
1384   1              TaskTemp.Cmd            = DISPKEY_CLEAR;
1385   1              TaskTemp.Sn             = Lcd.Sn;
1386   1              TaskTemp.Priority       = PRIORITY_NORMAL;
1387   1              TaskTemp.ParamLen       = 0;
1388   1      
1389   1              return ZhkSchedulerAddTask( &TaskTemp );
1390   1              
1391   1              
1392   1      }
1393          
1394          bit DisplayString( uchar * Str , const uchar len )
1395          {
1396   1              struct COMMTASK xdata TaskTemp;
1397   1      
1398   1              memset( &TaskTemp, 0, sizeof(struct COMMTASK) );        
1399   1              TaskTemp.Id             = ID_LCD;
1400   1              TaskTemp.Cmd            = DISPKEY_DISP;
1401   1              TaskTemp.Sn             = Lcd.Sn;
1402   1              TaskTemp.Priority       = PRIORITY_NORMAL;
1403   1              TaskTemp.ParamLen       = len;
1404   1              memcpy( TaskTemp.Param , Str , len );
1405   1      
1406   1              return ZhkSchedulerAddTask( &TaskTemp );
1407   1              
1408   1      }
1409          bit DisplayPosString( const uchar PosX , const uchar PosY , uchar * Str , const uchar len )
1410          {
1411   1              struct COMMTASK xdata TaskTemp;
1412   1              
1413   1              memset( &TaskTemp, 0, sizeof(struct COMMTASK) );
1414   1              //Trace( "DisplayPosString( %bd , %bd , % bd )\n" , PosX , PosY , len );
1415   1              TaskTemp.Id             = ID_LCD;
1416   1              TaskTemp.Cmd            = DISPKEY_DISPS;
1417   1              TaskTemp.Sn             = Lcd.Sn;
1418   1              TaskTemp.Priority       = PRIORITY_NORMAL;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 24  

1419   1              TaskTemp.ParamLen       = len + 2;
1420   1              TaskTemp.Param[ 0 ]     = PosX;
1421   1              TaskTemp.Param[ 1 ]     = PosY;
1422   1              memcpy( TaskTemp.Param + 2 , Str , len );
1423   1      
1424   1              return ZhkSchedulerAddTask( &TaskTemp );
1425   1      }
1426          
1427          bit DisplaySetCursorStyle( uchar style )
1428          {
1429   1              struct COMMTASK xdata TaskTemp;
1430   1      
1431   1              memset( &TaskTemp, 0, sizeof(struct COMMTASK) );        
1432   1              TaskTemp.Id             = ID_LCD;
1433   1              TaskTemp.Cmd            = DISPKEY_CURSORSTYLE;
1434   1              TaskTemp.Sn             = Lcd.Sn;
1435   1              TaskTemp.Priority       = PRIORITY_NORMAL;
1436   1              TaskTemp.ParamLen       = 1;
1437   1              TaskTemp.Param[ 0 ]     = style;
1438   1      
1439   1              return ZhkSchedulerAddTask( &TaskTemp );
1440   1      }
1441          
1442          bit DisplaySetCursorPos( uchar PosX , uchar PosY )
1443          {
1444   1              struct COMMTASK xdata TaskTemp;
1445   1      
1446   1              memset( &TaskTemp, 0, sizeof(struct COMMTASK) );        
1447   1              TaskTemp.Id             = ID_LCD;
1448   1              TaskTemp.Cmd            = DISPKEY_SETCURSOR;
1449   1              TaskTemp.Sn             = Lcd.Sn;
1450   1              TaskTemp.Priority       = PRIORITY_NORMAL;
1451   1              TaskTemp.ParamLen       = 2;
1452   1              TaskTemp.Param[ 0 ]     = PosX;
1453   1              TaskTemp.Param[ 1 ]     = PosY;
1454   1      
1455   1              return ZhkSchedulerAddTask( &TaskTemp );
1456   1                      
1457   1      }
1458          
1459          bit DisplayBkLightOn( void )
1460          {
1461   1              struct COMMTASK xdata TaskTemp;
1462   1      
1463   1              TaskTemp.Id             = ID_LCD;
1464   1              TaskTemp.Cmd            = DISPKEY_DENOTE;
1465   1              TaskTemp.Sn             = Lcd.Sn;
1466   1              TaskTemp.Priority       = PRIORITY_NORMAL;
1467   1              TaskTemp.ParamLen       = 1;
1468   1              TaskTemp.Param[ 0 ]     = 1;
1469   1              return ZhkSchedulerAddTask( &TaskTemp );
1470   1              
1471   1      }
1472          
1473          bit DisplayBkLightOff( void )
1474          {
1475   1              struct COMMTASK xdata TaskTemp;
1476   1      
1477   1              TaskTemp.Id             = ID_LCD;
1478   1              TaskTemp.Cmd            = DISPKEY_DENOTE;
1479   1              TaskTemp.Sn             = Lcd.Sn;
1480   1              TaskTemp.Priority       = PRIORITY_NORMAL;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 25  

1481   1              TaskTemp.ParamLen       = 1;
1482   1              TaskTemp.Param[ 0 ]     = 0;
1483   1              return ZhkSchedulerAddTask( &TaskTemp );
1484   1      }
1485          
1486          uchar IsBackLightOn( void )
1487          {
1488   1              return Lcd.State & 0x10;
1489   1      }
1490          
1491          uchar GetDisplayState()
1492          {
1493   1              return Lcd.ExtState[1];
1494   1      }
1495          
1496          ////////////////////////////////////////////////////////////////////////////////////////////
1497          //纸币器处理
1498          ////////////////////////////////////////////////////////////////////////////////////////////
1499          /*
1500          bit ZhkCasherTask( struct COMMTASK xdata* TaskTemp )
1501          {
1502                  uchar xdata StateTemp = 0;
1503                  //Trace( "ZhkCasherTask\n" );
1504                  //Trace( "ZhkSchedulerState=%d\n",(int)ZhkSchedulerState );
1505                  switch( ZhkSchedulerState )
1506                  {
1507                  case TASK_NULL:
1508                          break;
1509                  case TASK_REDAY:                
1510                          ZhkChannelSwitch( EQUIP_CASHER );
1511                          if( Casher.ExtState[ 14 ] == 0 )
1512                                  StateTemp = ZhkCasherTxMsg( TaskTemp, 1 );//改换纸币器数据包的ACK
1513                          else
1514                                  StateTemp = ZhkCasherTxMsg( TaskTemp, 0 );//不改换纸币器数据包的ACK
1515                          if ( StateTemp )
1516                                  ZhkSchedulerState = TASK_WAIT;
1517                          else
1518                                  ZhkSchedulerState = TASK_FINISH;        
1519                          
1520                          ZhkDownMsgAckTimer  = 90;//DOWNMSGACKTIMEOUT;
1521                          Casher.CommState = COMM_BUZY;
1522                          break;
1523                  case TASK_WAIT: 
1524          //              Trace( "\n ZhkCasherTask TASK_WAIT" );  
1525                          StateTemp = ZhkCasherMsgProcess();
1526                          if ( StateTemp == 1 )
1527                          {
1528                                  ZhkSchedulerState = TASK_FINISH;
1529                                  break;
1530                          }
1531                          if ( ZhkDownMsgAckTimer == 0 )
1532                          {
1533                                  if ( ZhkCasherTxMsg( TaskTemp, 0 ) )
1534                                          ZhkSchedulerState = TASK_REWAIT;
1535                                  else
1536                                          ZhkSchedulerState = TASK_FINISH;
1537                          //      ZhkSchedulerState  = TASK_REWAIT;
1538                                  ZhkDownMsgAckTimer = 90; //DOWNMSGACKTIMEOUT;
1539                          }               
1540                          break;
1541                  case TASK_REWAIT:
1542          //              Trace( "\n ZhkCasherTask TASK_REWAIT" );                
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 26  

1543                          StateTemp = ZhkCasherMsgProcess();
1544                          if ( StateTemp == 1 )
1545                          {
1546                                  ZhkSchedulerState = TASK_FINISH;
1547                                  break;
1548                          }
1549                          if ( ZhkDownMsgAckTimer == 0 )
1550                          {
1551                                  ZhkSchedulerState = TASK_ERROR;
1552                          }
1553                          break;
1554                  case TASK_FINISH:       
1555                          Casher.CommState  = COMM_COMMOK;
1556                          memset( &CurrentTask, 0, sizeof( struct COMMTASK ) );
1557                          ZhkSchedulerState = TASK_NULL; 
1558                          ZhkCasherStatus = CASHER_STATUS_NULL;
1559                          Casher.ExtState[ 14 ] = 0; 
1560                          Casher.ExtState[13] = 0;
1561                          QueryCashTimer = 0;
1562                          break;
1563                  case TASK_ERROR:        
1564          //              Trace( "\n ZhkCasherTask TASK_ERROR" );
1565                          Casher.CommState = COMM_TIMEOUT;// | COMM_COMMOK;
1566                          ZhkSchedulerState   = TASK_NULL; 
1567                          ZhkCasherStatus = CASHER_STATUS_NULL;
1568          
1569                          if( Casher.ExtState[ 14 ] < 240 )
1570                                  Casher.ExtState[ 14 ] ++;
1571                          if( Casher.ExtState[ 14 ] >= 2 )
1572                          {
1573                                  QueryCashTimer = 120;//定时二分钟
1574                                  Casher.ExtState[ 14 ] = 0;
1575                                  CasherDisableCasher();
1576                                  Casher.State    =  0 ;
1577                                  Casher.ExtState[ 0 ] = 0;
1578                                  Casher.ExtState[ 1 ] = 0 ;                      
1579                                  Trace( "\n Casher outtime, Close query" );
1580                          }
1581                          memset( &CurrentTask, 0, sizeof( struct COMMTASK ) );
1582                          break;
1583                  default:
1584                          ZhkSchedulerState = TASK_NULL;
1585                  }       
1586                  return 1;
1587          }
1588          
1589          bit ZhkCasherTxMsg( struct COMMTASK xdata* TaskTemp, uchar xdata Flag )
1590          {
1591                  switch( TaskTemp->Cmd )
1592                  {
1593                  case CASHER_PERMISSION:
1594                          break;
1595                  case CASHER_ACCEPT:
1596                          // 接收纸币
1597                          ZhkCasherAcceptCash();
1598                          break;
1599                  case CASHER_REJECT:
1600                          // 拒收纸币
1601                          ZhkCasherRejectCash();
1602                          break;
1603                  case CASHER_QUERY:
1604                          // 查询纸币器状态
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 27  

1605                          ZhkCasherGetState( Flag );
1606                          break;
1607                  case CASHER_DISABLE:
1608                          //禁能纸币器指令
1609                          CasherDisableCasher();
1610                          break;
1611                  default:
1612                          return  0;
1613                  }
1614                  return 1;       
1615          }
1616          
1617          uchar ZhkCasherMsgProcess( void )
1618          {
1619                  struct COMMTASK xdata AckTask;
1620                  
1621                  if ( ZhkCasherFrameUnPack( &AckTask ) == 0 )
1622                          return 0;
1623                  Casher.State        = AckTask.State;
1624                  Casher.ExtState[ 0 ] = AckTask.Param[ 0 ];
1625                  Casher.ExtState[ 1 ] = AckTask.Param[ 1 ];
1626          //      if ( CasherIsCashIn() )
1627           //             ZhkCasherStatus = CASHER_STATUS_NULL;
1628                  return 1;
1629                  
1630          }
1631          */
1632          bit ZhkCasherQuery( void )
1633          {
1634   1              struct COMMTASK xdata TaskTemp;
1635   1      
1636   1              ZhkCasherStatus         = CASHER_STATUS_QUERY;  
1637   1              TaskTemp.Id             = ID_CASHER;
1638   1              TaskTemp.Cmd            = CASHER_QUERY;
1639   1              TaskTemp.Sn                     = Casher.Sn;
1640   1              TaskTemp.Priority   = PRIORITY4;
1641   1              TaskTemp.ParamLen       = 0;
1642   1      //      Trace("\n check CashState");
1643   1              return ZhkSchedulerAddTask( &TaskTemp );
1644   1      }
1645          
1646          bit CasherQuery( void )
1647          {       
1648   1      //      if ( Casher.CommState == COMM_BUZY ) 
1649   1      //              return 0;       
1650   1      //      if( ZhkCasherStatus == CASHER_STATUS_NULL )
1651   1      //      {                       
1652   1                      ZhkCasherQuery();
1653   1                      return 1;
1654   1      //      }       
1655   1      //      return 0;
1656   1      }
1657          
1658          bit CasherAccept( void )
1659          {
1660   1              struct COMMTASK xdata TaskTemp;
1661   1      
1662   1              ZhkCasherStatus = CASHER_STATUS_ACCEPT;
1663   1              TaskTemp.Id             = ID_CASHER;
1664   1              TaskTemp.Cmd            = CASHER_ACCEPT;
1665   1              TaskTemp.Sn             = Casher.Sn;
1666   1              TaskTemp.Priority       = PRIORITY_NORMAL;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 28  

1667   1              TaskTemp.ParamLen       = 0;
1668   1              return ZhkSchedulerAddTask( &TaskTemp );
1669   1      }
1670          
1671          bit CasherReject( void )
1672          {
1673   1              struct COMMTASK xdata TaskTemp;
1674   1              
1675   1              Trace("\n CasherReject");
1676   1              ZhkCasherStatus = CASHER_STATUS_REJECT;
1677   1              TaskTemp.Id             = ID_CASHER;
1678   1              TaskTemp.Cmd            = CASHER_REJECT;
1679   1              TaskTemp.Sn             = Casher.Sn;
1680   1              TaskTemp.Priority       = PRIORITY_NORMAL; 
1681   1              TaskTemp.ParamLen       = 0;
1682   1              return ZhkSchedulerAddTask( &TaskTemp );
1683   1      }
1684          
1685          uchar CasherIsCashIn( void )
1686          {
1687   1              return Casher.State & 0x10;
1688   1      }
1689          
1690          uchar CasherIsAcceptOK( void )
1691          {
1692   1              return Casher.State & 0x20;
1693   1      }
1694          
1695          //退币是否成功
1696          uchar CasherIsRejectOK( void )
1697          {
1698   1              return Casher.State & 0x80;
1699   1      }
1700          
1701          uint GetCash( void )
1702          {
1703   1              uchar data ch;
1704   1      
1705   1              ch = Casher.ExtState[ 1 ] % 8;
1706   1              Casher.ExtState[ 1 ] = 0;
1707   1              if ( ch == 0 ) 
1708   1                      return 0;
1709   1              return CashAccept[ ch - 1 ];
1710   1      }
1711          
1712          uint GetComingCash( void )
1713          {
1714   1              uchar data ch = 0;
1715   1      
1716   1              ch = Casher.ExtState[ 1 ] % 8;
1717   1              Casher.ExtState[ 1 ] = 0;
1718   1          /*
1719   1              if ( ( ch == 0 ) || ( CashAcceptEnableTable[ch - 1] != 1 ) )
1720   1                      return 0;
1721   1              return CashAccept[ ch - 1 ];
1722   1          */
1723   1          if ( ch == 0 ) 
1724   1                      return 0;
1725   1              return SystemParameter.billValue[ch-1];   //Changed by Andy on 2010.8.17!
1726   1      }
1727          
1728          bit CasherQueryEnable( void )
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 29  

1729          {
1730   1              ZhkAutoTaskPermission[ 0 ] = 1;
1731   1              memset( &Casher, 0, sizeof( Casher ) );
1732   1              return 1;
1733   1      }
1734          
1735          void CasherGetMachineState( uchar state )
1736          {
1737   1              Casher.ExtState[ 15 ] = state;
1738   1      }
1739          
1740          uchar CasherRealTimeState( )
1741          {
1742   1              return Casher.ExtState[ 13 ];
1743   1      }
1744          
1745          
1746          bit CasherQueryDisable( void )
1747          {
1748   1              ZhkAutoTaskPermission[ 0 ] = 0;
1749   1              return 1;
1750   1      }
1751          
1752          void CasherResetOuttime( void )
1753          {       
1754   1              Casher.CommState  = COMM_COMMOK;        
1755   1              QueryCashTimer = 0;
1756   1      }
1757          
1758          //////////////////////////////////////////////////////////
1759          ///货道处理
1760          //////////////////////////////////////////////////////////
1761          bit ZhkChannelTask( struct COMMTASK xdata* TaskTemp )
1762          {
1763   1              u_char data StateTemp;
1764   1      
1765   1              #ifdef   _SJJ_//升降机
1766   1                      return 0;               
1767   1              #endif
1768   1              
1769   1              switch( ZhkSchedulerState )
1770   1              {
1771   2              case TASK_NULL:
1772   2                      break;
1773   2              case TASK_REDAY:                
1774   2                      ZhkChannelSwitch( EQUIP_CHANNEL );              
1775   2                      if ( ZhkChannelTxMsg( TaskTemp ) )
1776   2                              ZhkSchedulerState = TASK_WAIT;
1777   2                      else
1778   2                              ZhkSchedulerState = TASK_FINISH;
1779   2                      
1780   2                      ZhkDownMsgAckTimer  = 800;
1781   2                      Channel.CommState = COMM_BUZY;
1782   2                      Channel.ExtState[2] = 0;
1783   2                      break;  
1784   2              case TASK_WAIT:
1785   2                      StateTemp = ZhkChannelMsgProcess();
1786   2                      if ( StateTemp == 1 )
1787   2                      {
1788   3                              if( ( TaskTemp->Cmd == CHANNEL_EXEC ) || ( TaskTemp->Cmd == CHANNEL_TEST ) )
1789   3                              {
1790   4                              //等来了命令ACK，还要等命令执行结果啦
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 30  

1791   4      //                              Trace("\n return command ACK");
1792   4                                      Channel.ExtState[2] = 1;
1793   4                                      ZhkSchedulerState = TASK_REWAIT;
1794   4                                      ZhkDownMsgAckTimer = 1500;                              
1795   4                              }       
1796   3                              else
1797   3                              {
1798   4                                      ZhkDownMsgAckTimer = 0;
1799   4                                      ZhkSchedulerState = TASK_FINISH;
1800   4                              }
1801   3                              break;
1802   3                      }
1803   2                      if ( ZhkDownMsgAckTimer == 0 )
1804   2                      {
1805   3                              if( ( TaskTemp->Cmd == CHANNEL_EXEC ) || ( TaskTemp->Cmd == CHANNEL_TEST ) )
1806   3                              {
1807   4                                      //超时确没有命令ACK回应，只能重来了
1808   4      //                              Trace("\n no return command ACK");
1809   4                                      if( Channel.ExtState[2] == 0)
1810   4                                      {
1811   5                                              ZhkSchedulerState = TASK_ERROR;
1812   5                                              break;
1813   5                                      }
1814   4                              }
1815   3                              //如果是查询或清零命令，则可直接重试一次
1816   3                              Channel.Sn --;
1817   3                              if ( ZhkChannelTxMsg( TaskTemp ) )
1818   3                              {
1819   4                                      ZhkSchedulerState = TASK_REWAIT;
1820   4                                      ZhkDownMsgAckTimer = 800;
1821   4                              }
1822   3                              else
1823   3                                      ZhkSchedulerState = TASK_FINISH;                                        
1824   3                      }               
1825   2                      break;          
1826   2              case TASK_REWAIT:
1827   2                      StateTemp = ZhkChannelMsgProcess();
1828   2                      if ( StateTemp == 1 )
1829   2                      {
1830   3      //                      Trace("\n return mission ACK");
1831   3                              if( ( TaskTemp->Cmd == CHANNEL_EXEC ) || ( TaskTemp->Cmd == CHANNEL_TEST ) )                    
1832   3                                      Channel.ExtState[2] = 2;                                
1833   3                              ZhkSchedulerState = TASK_FINISH;
1834   3                              break;
1835   3                      }
1836   2                      if ( ZhkDownMsgAckTimer == 0 )
1837   2                      {
1838   3                              ZhkSchedulerState = TASK_ERROR;
1839   3                      }
1840   2                      break;          
1841   2              case TASK_FINISH:
1842   2                      ZhkSchedulerState = TASK_NULL;          
1843   2                      Channel.CommState   = COMM_COMMOK;
1844   2                      memset( &CurrentTask, 0, sizeof( struct COMMTASK ) );
1845   2                      ZhkDownMsgAckTimer = 0;
1846   2                      break;
1847   2              case TASK_ERROR:
1848   2                      Channel.CommState = COMM_TIMEOUT;// | COMM_COMMOK;
1849   2                      ZhkSchedulerState   = TASK_NULL; 
1850   2                      memset( &CurrentTask, 0, sizeof( struct COMMTASK ) );
1851   2                      break;
1852   2              default:
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 31  

1853   2                      ZhkSchedulerState = TASK_NULL;
1854   2              }
1855   1              return 1;
1856   1      }
1857          
1858          bit ZhkChannelTxMsg( struct COMMTASK xdata* NewTask )
1859          {
1860   1              u_char ChannelTemp;
1861   1              u_char sum;
1862   1              
1863   1      //      Trace("\n ZhkChannelTxMsg" );
1864   1              ChannelTemp  = NewTask->Param[ 0 ] ;    
1865   1              
1866   1              if( ( NewTask->Cmd == CHANNEL_EXEC ) && ( NewTask->Param[1] == 1 ) )
1867   1                      Channel.Sn--;
1868   1              if( Channel.Sn == 255 )
1869   1                      Channel.Sn = 1;
1870   1              else
1871   1                      Channel.Sn ++;
1872   1      
1873   1              ZhkSerial1PutCh( 0xED );
1874   1      //      Trace(" ed" );
1875   1              sum  = 0xED;
1876   1              ZhkSerial1PutCh( 0x08 );
1877   1      //      Trace(" 08" );
1878   1              sum ^= 0x08;
1879   1              if( NewTask->Cmd == CHANNEL_CLEAR )
1880   1              {
1881   2                      ZhkSerial1PutCh( 0x00 );
1882   2      //              Trace(" %02bx", 0x00 );
1883   2                      sum ^= 0x00;
1884   2              }
1885   1              else
1886   1              {
1887   2                      ZhkSerial1PutCh( Channel.Sn );
1888   2      //              Trace(" %02bx", Channel.Sn );
1889   2                      sum ^= Channel.Sn;              
1890   2                      NewTask->Sn = Channel.Sn;
1891   2              }
1892   1              switch( NewTask->Cmd )
1893   1              {
1894   2                      case CHANNEL_EXEC:      //命令ID        
1895   2                              ZhkSerial1PutCh( 0x70 );
1896   2      //                      Trace(" 70" );
1897   2                              sum ^= 0x70;
1898   2                              ZhkSerial1PutCh( ChannelTemp );//货道编号               
1899   2                              sum ^= ChannelTemp;
1900   2      //                      Trace(" %02bx", ChannelTemp );          
1901   2                      break;  
1902   2                      case CHANNEL_QUERY:     //命令ID        
1903   2                              ZhkSerial1PutCh( 0x71 );
1904   2      //                      Trace(" 71" );
1905   2                              sum ^= 0x71;
1906   2                              ZhkSerial1PutCh( 0x00 );//货道编号
1907   2                              sum ^= 0x00;            
1908   2                              NewTask->Param[ 0 ] = 0;
1909   2      //                      Trace(" 00");                   
1910   2                      break;  
1911   2                      case CHANNEL_CLEAR:     //命令ID        
1912   2                              ZhkSerial1PutCh( 0x72 );
1913   2      //                      Trace(" 72" );
1914   2                              sum ^= 0x72;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 32  

1915   2                              ZhkSerial1PutCh( 0x00 );//货道编号
1916   2                              sum ^= 0x00;
1917   2                              NewTask->Param[ 0 ] = 0;
1918   2      //                      Trace(" 00");                   
1919   2                              Channel.Sn = 0;
1920   2                              NewTask->Sn = 0;
1921   2                      break;  
1922   2                      case CHANNEL_TEST:      //命令ID        
1923   2                              ZhkSerial1PutCh( 0x73 );
1924   2      //                      Trace(" 73" );
1925   2                              sum ^= 0x73;
1926   2                              ZhkSerial1PutCh( ChannelTemp );//货道编号
1927   2      //                      Trace(" %02bx", ChannelTemp );
1928   2                              sum ^= ChannelTemp;             
1929   2                      break;                  
1930   2              default:
1931   2                      return  0;
1932   2              }
1933   1              ZhkSerial1PutCh( 0x00 );                
1934   1          //Trace(" 00" );
1935   1              sum ^= 0x00;
1936   1              
1937   1          //----------------------------------------------
1938   1          //Changed for GOC dev, by Andy on 2010.10.21 
1939   1          //if( SystemParameter.GOCOn == 1 )
1940   1          if( (SystemParameter.GOCOn == 1)/*&&(DeviceStatus.GOCStatus==0x00)&&(SystemStatus==1)*/ )  //Changed b
             -y Andy 2011.7.11
1941   1          {
1942   2              
1943   2              if( (SystemStatus==1) )
1944   2              {
1945   3                   if(DeviceStatus.GOCStatus==0x00)
1946   3                   {
1947   4                               ZhkSerial1PutCh( 0x01 );
1948   4                                   sum ^= 0x01;
1949   4                   }
1950   3                   //出货模块卡货时，每隔一段时间，予以检测;by cq 20110815
1951   3                   else if((DeviceStatus.GOCStatus & 0x01) && (sysVPMission.GOCTestFlag == 1))
1952   3                               {
1953   4                                       ZhkSerial1PutCh( 0x01 );//打开
1954   4                                       sum ^= 0x01;
1955   4                               }  
1956   3                   else
1957   3                   {
1958   4                       ZhkSerial1PutCh( 0x00 );
1959   4                               //Trace(" 00" );
1960   4                                       sum ^= 0x00;
1961   4                   }
1962   3              }
1963   2              else
1964   2              {
1965   3                       ZhkSerial1PutCh( 0x01 );
1966   3                           sum ^= 0x01;               
1967   3              }
1968   2          }
1969   1          else
1970   1          {
1971   2              ZhkSerial1PutCh( 0x00 );
1972   2              //Trace(" 00" );
1973   2                      sum ^= 0x00;
1974   2          }
1975   1          //==============================================
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 33  

1976   1      
1977   1              ZhkSerial1PutCh( sum );
1978   1          //Trace(" %02bx", sum );
1979   1              return 1;       
1980   1      }
1981          
1982          u_char ZhkChannelMsgProcess( void )
1983          {
1984   1              struct COMMTASK xdata AckTask;
1985   1              
1986   1              memcpy( &AckTask, &CurrentTask, sizeof( struct COMMTASK ) );
1987   1              if( ZhkChannelFrameUnPack( &AckTask ) == 0 ) 
1988   1                      return 0;               
1989   1              if( AckTask.Cmd == CHANNEL_QUERY )//查询指令不能比较货道编号
1990   1              {
1991   2                      Channel.State         = AckTask.State;
1992   2                      Channel.ExtState[ 0 ] = AckTask.Param[ 0 ];//货道序列号
1993   2                      Channel.ExtState[ 1 ] = AckTask.Param[ 1 ];//包序列号
1994   2                      return 1;
1995   2              }
1996   1              
1997   1          //if( CurrentTask.Param[ 0 ] == AckTask.Param[ 0 ] )
1998   1              {
1999   2                      Channel.State         = AckTask.State;
2000   2                      Channel.ExtState[ 0 ] = AckTask.Param[ 0 ];//货道序列号
2001   2                      Channel.ExtState[ 1 ] = AckTask.Param[ 1 ];//包序列号
2002   2                //Channel.CommState     = COMM_COMMOK;
2003   2              }
2004   1          /*
2005   1              else
2006   1          {
2007   1                      return 0;
2008   1          }
2009   1          */
2010   1              return 1;
2011   1              
2012   1      }
2013          
2014          ////货道命令
2015          //查询
2016          bit ZhkChannelQuery( )
2017          {
2018   1              struct COMMTASK xdata TaskTemp;
2019   1              
2020   1              Channel.CommState       = COMM_BUZY;
2021   1              TaskTemp.Id             = ID_CHANNEL;
2022   1              TaskTemp.Cmd            = CHANNEL_QUERY;
2023   1              TaskTemp.Sn             = Channel.Sn;
2024   1              TaskTemp.Priority       = PRIORITY_NORMAL; 
2025   1              TaskTemp.ParamLen       = 1;
2026   1              TaskTemp.Param[ 0 ]     = 0x00;
2027   1              return ZhkSchedulerAddTask( &TaskTemp );
2028   1      }
2029          
2030          //出货命令
2031          bit ZhkChannelExec( u_char ChannelNum, u_char ReSendFlag )
2032          {
2033   1              struct COMMTASK xdata TaskTemp;
2034   1              
2035   1              memset( &TaskTemp, 0, sizeof( struct COMMTASK ) );
2036   1              Channel.CommState       = COMM_BUZY;
2037   1              TaskTemp.Id             = ID_CHANNEL;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 34  

2038   1              TaskTemp.Cmd            = CHANNEL_EXEC;
2039   1              TaskTemp.Sn             = Channel.Sn;
2040   1              TaskTemp.Priority       = PRIORITY_NORMAL; 
2041   1              TaskTemp.ParamLen       = 2;
2042   1              TaskTemp.Param[ 0 ]     = ChannelNum;
2043   1              TaskTemp.Param[ 1 ]     = ReSendFlag;
2044   1              return ZhkSchedulerAddTask( &TaskTemp );
2045   1      }
2046          
2047          //清空SN命令
2048          bit ZhkChannelClear( )
2049          {
2050   1              struct COMMTASK xdata TaskTemp;
2051   1              
2052   1              Trace("\nZhkChannelClear" );
2053   1              Channel.CommState       = COMM_BUZY;
2054   1              TaskTemp.Id             = ID_CHANNEL;
2055   1              TaskTemp.Cmd            = CHANNEL_CLEAR;
2056   1              TaskTemp.Sn             = Channel.Sn;
2057   1              TaskTemp.Priority       = PRIORITY_NORMAL; 
2058   1              TaskTemp.ParamLen       = 1;
2059   1              TaskTemp.Param[ 0 ]     = 0x00;
2060   1              return ZhkSchedulerAddTask( &TaskTemp );
2061   1      }
2062          
2063          //检测货道命令
2064          bit ZhkChannelTest( u_char ChannelNum )
2065          {
2066   1              struct COMMTASK xdata TaskTemp;
2067   1              
2068   1              Channel.CommState       = COMM_BUZY;
2069   1              TaskTemp.Id             = ID_CHANNEL;
2070   1              TaskTemp.Cmd            = CHANNEL_TEST;
2071   1              TaskTemp.Sn             = Channel.Sn;
2072   1              TaskTemp.Priority       = PRIORITY_NORMAL; 
2073   1              TaskTemp.ParamLen       = 1;
2074   1              TaskTemp.Param[ 0 ]     = ChannelNum;
2075   1              return ZhkSchedulerAddTask( &TaskTemp );
2076   1      }
2077          
2078          //////////////////////////////////////////////////////////
2079          ///硬币器处理函数
2080          //////////////////////////////////////////////////////////
2081          //关闭硬币器电源
2082          /*
2083          bit CoinPowerOff( void )
2084          {
2085                  struct COMMTASK xdata TaskTemp;
2086                  
2087                  TaskTemp.Id             = ID_HUB;
2088                  TaskTemp.Cmd            = HUB_COINPOWER;
2089                  TaskTemp.Sn                 = Hub.Sn;
2090                  TaskTemp.Priority   = PRIORITY_NORMAL;
2091                  TaskTemp.ParamLen       = 1;
2092                  TaskTemp.Param[ 0 ] = 0;
2093                  Trace("\n CoinPowerOff()_AddTask");
2094                  return ZhkSchedulerAddTask( &TaskTemp );
2095          }
2096          //打开硬币器电源
2097          bit CoinPowerOn( void )
2098          {
2099                  struct COMMTASK xdata TaskTemp;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 35  

2100                  
2101                  TaskTemp.Id             = ID_HUB;
2102                  TaskTemp.Cmd            = HUB_COINPOWER;
2103                  TaskTemp.Sn                 = Hub.Sn;
2104                  TaskTemp.Priority   = PRIORITY_NORMAL;
2105                  TaskTemp.ParamLen       = 1;
2106                  TaskTemp.Param[ 0 ] = 1;
2107                  Trace("\n CoinPowerOn()_AddTask");
2108                  return ZhkSchedulerAddTask( &TaskTemp );
2109                  
2110          }
2111          */
2112          //////手机模块处理
2113          uchar TestATcommand()
2114          {
2115   1              uchar temp = 0;
2116   1              uchar TestTimer = 0;
2117   1      #ifndef _DEBUG_NO_MOBILE
                      IsPressMobile = 0;
                      while( 1 )
                      {
                              temp = SendATcommandToMobile();
                              if( temp == 3 )
                              {
                                      IsPressMobile = 1;
                                      return 3;
                              }
                              if( temp == 2 )
                              {
                                      SchedulerProcess();
                                      continue;
                              }
                              else
                              {
                                      if( temp == 0 )
                                      {
                                              IsPressMobile = 1;
                                              return 0;                       
                                      }
                                      if( TestTimer < 1 )
                                      {
                                              TestTimer++;
                                              continue;
                                      }
                                      else
                                      {
                                              IsPressMobile = 1;
                                              return 1;               
                                      }
                              }
                      }
                      IsPressMobile = 1;
               #endif
2153   1       return 0;
2154   1      
2155   1      }
2156          
2157          /////////////////////////////////////////////
2158          //HUB板通讯包处理
2159          /*
2160          bit ZhkHubTxMsg( struct COMMTASK xdata* NewTask )
2161          {
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 36  

2162                  ///     
2163                  if( Hub.Sn < 255 )
2164                          Hub.Sn ++;
2165                  else
2166                          Hub.Sn = 1;
2167                  if ( Hub.Sn == 0 ) 
2168                          Hub.Sn ++;
2169                  NewTask->Sn = Hub.Sn;
2170                  ZhkBusTxMsg( NewTask ); 
2171                  return 1;
2172          }
2173          
2174          uchar ZhkHubMsgProcess( void )
2175          {
2176                  struct COMMTASK xdata AckTask;
2177          
2178                  if ( CtrlCoinPowerFrameUnPack( &AckTask ) == 0 )     //Changed by Andy Zhang on Jan 17,2007.
2179                          return 0;
2180                  if ( CurrentTask.Id  != AckTask.Id  ) 
2181                          return 0;
2182                  if ( CurrentTask.Sn  != AckTask.Sn  ) 
2183                          return 0;
2184                  Hub.State = AckTask.State;
2185                  return 1;
2186          }
2187          
2188          
2189          bit ZhkHubTask( struct COMMTASK xdata* TaskTemp )
2190          {
2191                  uchar data StateTemp;
2192                  //Trace( "ZhkHubTask\n" );
2193                  //Trace( "ZhkSchedulerState=%d\n",(int)ZhkSchedulerState );
2194                  switch( ZhkSchedulerState )
2195                  {
2196                  case TASK_NULL:
2197                          break;
2198                  case TASK_REDAY:
2199                          Trace( "ZhkHubTaskBegin\n" );
2200                          ZhkChannelSwitch( EQUIP_HUB );
2201                          if ( ZhkHubTxMsg( TaskTemp ) )
2202                                  ZhkSchedulerState = TASK_WAIT;
2203                          else
2204                                  ZhkSchedulerState = TASK_FINISH;
2205                          Trace( "GUANYU ZhkSchedulerState = %bu\n, ZhkSchedulerState" );
2206                          Trace( "ZhkHubTaskTxMsgOK\n" );
2207                          ZhkDownMsgAckTimer = 60;//DOWNMSGACKTIMEOUT;
2208                          Hub.CommState   = COMM_BUZY;
2209                          break;
2210                  case TASK_WAIT:
2211                          StateTemp = ZhkHubMsgProcess();
2212                          if ( StateTemp == 1 )
2213                          {
2214                                  ZhkSchedulerState = TASK_FINISH;
2215                                  break;
2216                          }
2217                          if ( ZhkDownMsgAckTimer == 0 )
2218                          {
2219                                  Hub.Sn --;      
2220                                  if ( ZhkHubTxMsg( TaskTemp ) )
2221                                          ZhkSchedulerState = TASK_WAIT;
2222                                  else
2223                                          ZhkSchedulerState = TASK_FINISH;
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 37  

2224                                  ZhkDownMsgAckTimer = 60;//DOWNMSGACKTIMEOUT;
2225                          }
2226                          break;
2227                  case TASK_REWAIT:
2228                          StateTemp = ZhkHubMsgProcess();
2229                          if ( StateTemp == 1 )
2230                          {
2231                                  ZhkSchedulerState = TASK_FINISH;
2232                                  break;
2233                          }
2234                          if ( ZhkDownMsgAckTimer == 0 )
2235                          {
2236                                  ZhkSchedulerState = TASK_ERROR;
2237                          }
2238                          break;
2239                  case TASK_FINISH:
2240                          ZhkSchedulerState = TASK_NULL; 
2241                          Hub.CommState     = COMM_COMMOK;
2242                          break;
2243                  case TASK_ERROR:
2244                          Hub.CommState  = COMM_TIMEOUT;
2245                          ZhkSchedulerState = TASK_NULL; 
2246                          break;
2247                  default:
2248                          ZhkSchedulerState = TASK_NULL;
2249                  }
2250                  return 1;
2251          }
2252          */
2253          
2254          void ZhkChannelSwitch( uchar type )
2255          {
2256   1              //Trace( "ZhkChannelSwitch(%bd)\n" , type );
2257   1              ES1R = 0;
2258   1              switch( type )
2259   1              {
2260   2              case EQUIP_LCD: 
2261   2              //      ZhkHardSerialSwitch( 3 );
2262   2                      ZhkBusSerialInit();
2263   2                      DelayMs( 2 );
2264   2                      ZhkHardSerialSwitch( 2 );
2265   2                      DelayMs( 2 );
2266   2                      break;
2267   2              case EQUIP_HOPPER:
2268   2        //case EQUIP_HUB:     
2269   2        //    ZhkHardSerialSwitch( 3 );
2270   2                      ZhkBusSerialInit();
2271   2                      DelayMs( 2 );
2272   2              /*
2273   2              if( sysVPMission.VPMode_Key == 1 )
2274   2                  ZhkHardSerialSwitch( 2 );
2275   2              else
2276   2                              ZhkHardSerialSwitch( 4 );
2277   2              */
2278   2              ZhkHardSerialSwitch( 4 );
2279   2                      DelayMs( 2 );
2280   2                      break;
2281   2              case EQUIP_CASHER:      
2282   2                      //ZhkCasherSerialInit();
2283   2                      DelayMs( 2 );
2284   2                      ZhkHardSerialSwitch( 0 );
2285   2                      DelayMs( 2 );
CX51 COMPILER V7.50   SCHEDULER                                                            10/23/2014 09:48:27 PAGE 38  

2286   2                      break;
2287   2              case EQUIP_COINER:
2288   2                      ZhkBusSerialInit();
2289   2                      DelayMs( 2 );
2290   2              //ZhkHardSerialSwitch( 6 );//HUB板上J8口
2291   2                      ZhkHardSerialSwitch( 1 );
2292   2                      DelayMs( 2 );           
2293   2                      break;  
2294   2              case EQUIP_POWER:
2295   2              case EQUIP_MODE:
2296   2                      break;
2297   2              case EQUIP_CHANNEL:     //主板扩展口
2298   2              //ZhkHardSerialSwitch( 0 );
2299   2                      ZhkBusSerialInit();
2300   2                      DelayMs( 2 );
2301   2                      ZhkHardSerialSwitch( 3 );
2302   2                      DelayMs( 2 );
2303   2                      break;          
2304   2              }
2305   1              ES1R = 1;
2306   1      }
2307          
2308          
2309          
2310          
2311          
2312          
2313          
2314          
2315          
2316          
2317          
2318          
2319          
2320          
2321          
2322          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5858    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   1474    1138
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


CX51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
