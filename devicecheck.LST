CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 1   


CX51 COMPILER V7.50, COMPILATION OF MODULE DEVICECHECK
OBJECT MODULE PLACED IN devicecheck.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\CX51.EXE devicecheck.c LARGE OBJECTADVANCED ROM(HUGE) OPTIMIZE(SIZE) BROWSE DEBUG

line level    source

   1          #include "device.h"
   2          #include "CommonFunction.h"
   3          #include "devicecheck.h"
   4          #include "scheduler.h"
   5          #include "common.h"
   6          #include "key.h"
   7          #include <string.h>
   8          #include "procotol.h"
   9          #include "IOInput.h"
  10          #include "mainflow.h"  
  11          #include "timer.h" 
  12          #include "debug.h"
  13          #include "global.h"
  14          #include "ShortMsg.h"
  15          #include "communication.h"
  16          #include "ITL.h"
  17          #include "BusCard.h"
  18          #include "VMC_PC.h"
  19          
  20          #ifdef _CHINA_
  21                  const struct StrAndLen code WMenuStr[] = 
  22                  {       
  23                          /*
  24                          { "1.纸币器状态: ", 14 },
  25                          { "2.硬币器状态: ", 14 },
  26                      //{ "3.#1找零器状态: ", 16 },       
  27                          //{ "4.#2找零器状态: ", 16 },
  28                          { "3.五角找零: ", 12 }, 
  29                          { "4.一元找零: ", 12 },
  30                          //{ "5.#3找零器状态: ", 16 },   //111021        
  31                          //{ "6.手机模块状态测试", 18 },//111021
  32                          //{ "7.短信测试", 10 },//111021
  33                          //{ "8.货道状态", 10 },//111021
  34                  { "5.货道状态快速查询", 18 },
  35                          { "6.货道检测", 12 },
  36                  { "7.货道测试结果", 16 },
  37                  { "8.选货按钮检测", 16 },       
  38                          { "9.游戏按钮检测", 16 },
  39                          { "10. 退币按钮检测", 16 },
  40                  { "11. 读卡器测试: ", 16 },             
  41                          { "12. 压缩机测试", 14 },
  42                          { "13. 展示灯测试", 14 },
  43                          { "14. 出货确认测试", 16 },//111017     by cq 出货确认
  44                  { "15. 运行状态查询", 16 },
  45                  */
  46                  { "1.整机故障查看", 14 },
  47                  { "2.出货测试", 10 },
  48                  { "3.纸币器状态: ", 14 },
  49                          { "4.硬币器状态: ", 14 },
  50                      { "5.五角余额: ", 12 },     
  51                          { "6.一元余额: ", 12 },                         
  52                  //{ "7.货道测试结果", 14 },
  53                  { "7.选货按钮检测", 14 },       
  54                          { "8.游戏按钮检测", 14 },
  55                          { "9.退币按钮检测", 16 },
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 2   

  56                  { "10. 出货确认测试", 16 },//111017     by cq 出货确认  
  57                  { "11. 照明测试", 12 },
  58                          { "12. 压缩机测试", 14 },
  59                          
  60                  
  61                  };
  62          
  63                  const struct StrAndLen code DeviceStatusStr[] = 
  64                  {
  65                          { "\xd5\xfd常", 4 },  //0       
  66                  { "故障", 4 }, //1
  67                          { "无", 2 }, //2
  68                          { "不足", 4 },//3
  69                  };
  70                  
  71                  const struct StrAndLen code GoodsWaysStatusStr[] = 
  72                  {   
  73                      
  74                          { "未", 2 },       //未测试
  75                          { "\xd5\xfd", 2 }, //正常       
  76                  { "故", 2 },       //故障       
  77                          { "缺", 2 },       //无货
  78                          /*
  79                          { "未测试", 6 },       //未测试
  80                          { "\xd5\xfd常", 4 },   //正常   
  81                  { "故障", 4 },         //故障   
  82                          { "缺货", 4 },         //无货
  83                          */
  84                  };
  85          #else
                      const struct StrAndLen code WMenuStr[] = 
                      {       
                              { "1.Bill acceptor:", 16 },
                              { "2.Coin acceptor:", 16 },
                              { "3.Change unit#1:", 16 },     
                              { "4.Change unit#2:", 16 },
                              //{ "5.Change unit#3:", 16 },//111021
                              //{ "6.Mobile status test", 20 },//111021
                              //{ "7.SMS test", 10 },//111021
                              //{ "8.Column status", 15 },//111021
                      { "5.goods status", 14}
                              { "6.Column test", 13 },
                      { "7.Col test result", 18 },
                      { "8.Selection button", 19 },
                              { "9.Game button", 14 },
                              { "10.Return button", 16 },
                      { "11.IC card:", 11 },          
                              { "12.compressor test", 18 },
                              { "13.light test", 13 },
                              { "14.GOC test", 11 },//111017
                      { "15.Deal Status", 14 },
                      
                      };
              
                      const struct StrAndLen code DeviceStatusStr[] = 
                      {
                              { "OK", 2 },  //0       
                          { "Err", 3 }, //1
                              { "No", 2 }, //2
                              { "Litt", 4 },//3       
                      };
                      
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 3   

                      const struct StrAndLen code GoodsWaysStatusStr[] = 
                      {
                              { "NO", 2 },//未用
                              { "OK", 2 },//正常      
                          { "Er", 2 }, //故障 
                              { "Em", 2 },//无货      
                      };
              #endif
 126          
 127          
 128          
 129          
 130          u_char xdata m_iCheckDevice = 0;
 131          u_char xdata hardWareErrShow[2]={0,0};
 132          
 133          //用于显示确定或取消并返回用记选择值,返回值，确定返回0,取消返回1,超时返回2
 134          u_char ChooseReturn( u_char *str )
 135          {       
 136   1              u_char xdata MyKey = 0;
 137   1      
 138   1              ClearKey();     
 139   1              //显示字符      
 140   1              DisplayInfo( 0, 0 , str );
 141   1      #ifdef _CHINA_
 142   1              DisplayStr( 0, 1, 1, "确定ENTER 取消CANCEL", 20 );
 143   1      #else
                      DisplayStr( 0, 1, 1, "    ENTER  CANCEL", 17 );
              #endif
 146   1          
 147   1              //等待选择
 148   1              SgwSecTimer= 6;
 149   1              while( SgwSecTimer )
 150   1              {
 151   2                      WaitForWork( 50, NULL ); 
 152   2                      MyKey = GetKey();               
 153   2                      switch ( MyKey )
 154   2                      {
 155   3                              case KEY_SUBMIT:                                
 156   3                                      return 0 ;                      
 157   3                              case KEY_CANCEL:                                
 158   3                                      return 1 ;                                      
 159   3                              default:
 160   3                                      continue;
 161   3                      }       
 162   2              }
 163   1              return 2;
 164   1      }
 165          
 166          
 167          //显示当前测试的各货道故障数,by gzz 20110303
 168          void DispGoodsCheckValue()
 169          {               
 170   1              u_char xdata i = 0;
 171   1              u_char xdata j = 0;
 172   1              u_char xdata z = 0;
 173   1                                              
 174   1              u_char  xdata LineNum = 2;  //选中行在屏幕中的行号              
 175   1              u_char  xdata key;
 176   1              u_char xdata  DispFlag = 1;
 177   1              u_char xdata SumColunm = 0;
 178   1              u_char xdata m_Index = 0;
 179   1          u_char xdata str[20];
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 4   

 180   1              u_char xdata len = 0;
 181   1      
 182   1              //------------------------------------
 183   1              memset( str, 0, sizeof( str ) );
 184   1              len = sprintf( str, "累计测试次\xca\xfd: %u", WayCheck.testNum );
 185   1              DisplayStr( 0, 0, 1, str, len );
 186   1              ClearDisplayLine( 2 );
 187   1              //====================================
 188   1              for( m_Index = 0; m_Index < GOODSWAYNUM; m_Index ++ )
 189   1          {
 190   2             WayCheck.WayNo[m_Index] = InputGoodsWayList[m_Index].GoodsWayNo;
 191   2             //WayCheck[m_Index].BreakCount = 0;
 192   2          } 
 193   1              key = KEY_NULL;         
 194   1              ClearKey();
 195   1              DisplayCursorState( 0, 1, 1, 2, 1 );//设置当在第二行上且为整行光标状态
 196   1              LineNum = 2;
 197   1              for( i = 0; i < GOODSWAYNUM; i ++ )
 198   1              {
 199   2                      if( WayCheck.WayNo[i] != 0 )
 200   2                              SumColunm++;
 201   2                      else
 202   2                              break;
 203   2              }
 204   1              WaitForWork( 3000,NULL );
 205   1          i = 0;
 206   1          ClearKey();
 207   1      
 208   1              if( DispFlag  )
 209   1              {
 210   2                      #ifdef _CHINA_              
 211   2                          memset( str, 0, sizeof( str ) );
 212   2                          len = sprintf( str, "货道%02bu故障次\xca\xfd:%u", WayCheck.WayNo[i], WayCheck.BreakCount[i] );
 213   2                      DisplayStr( 0, 0, 1, str, len );
 214   2                          
 215   2                              len = sprintf( str, "货道%02bu故障次\xca\xfd:%u", WayCheck.WayNo[i+1], WayCheck.BreakCount[i+1] );
 216   2                      DisplayStr( 0, 1, 1, str, len );                                        
 217   2                      #else   
                              memset( str, 0, sizeof( str ) );
                                  len = sprintf( str, "Column%02buErrNum:%u", WayCheck.WayNo[i], WayCheck.BreakCount[i] );
                              DisplayStr( 0, 0, 1, str, len );
                                  
                                      len = sprintf( str, "Column%02buErrNum:%u", WayCheck.WayNo[i+1], WayCheck.BreakCount[i+1] );
                              DisplayStr( 0, 1, 1, str, len );                                
                              #endif                  
 225   2                              DisplayCursorState( 0, LineNum-1, 1, 2, 1 );
 226   2                              DispFlag = 0;
 227   2          }
 228   1          ClearKey();
 229   1              
 230   1      
 231   1              while( 1 )    //超时或客户退出
 232   1              {        
 233   2                      key = GetKey();
 234   2                      //if( key == KEY_NULL ) continue;
 235   2                      switch( key )           
 236   2                      {
 237   3                  case KEY_UP://上移                          
 238   3                                   if( LineNum == 2 )//选中标记上移
 239   3                                   {                       
 240   4                                      DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
 241   4                                      LineNum = 1;
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 5   

 242   4                                              if (i>1) i--;
 243   4                                   }
 244   3                                   else   //菜单上翻
 245   3                                   {          
 246   4                                              if( i == 0 )
 247   4                                              {
 248   5                                                      break;
 249   5                                              }
 250   4                                              else
 251   4                                              {                       
 252   5                                                  i--;
 253   5                                              #ifdef _CHINA_     
 254   5                                                  len = sprintf( str, "货道%02bu故障次\xca\xfd:%u", WayCheck.WayNo[i], WayCheck.BreakCount[i] );
 255   5                                              DisplayStr( 0, 0, 1, str, len );
 256   5                                                  
 257   5                                                      //如果下一行超出货道直，就不能显示了
 258   5                              if( (i+1) >= SumColunm )
 259   5                              {
 260   6                                 ClearDisplayLine( 2 );
 261   6                              }
 262   5                              else
 263   5                              {
 264   6                                                              len = sprintf( str, "货道%02bu故障次\xca\xfd:%u", WayCheck.WayNo[i+1], WayCheck.BreakCount[i+1] );
 265   6                                                      DisplayStr( 0, 1, 1, str, len );        
 266   6                                                      }
 267   5                                              #else
                                                              len = sprintf( str, "Column%02buErrNum:%u", WayCheck.WayNo[i], WayCheck.BreakCount[i] );
                                                      DisplayStr( 0, 0, 1, str, len );
                                                          
                                                              //如果下一行超出货道直，就不能显示了
                                      if( (i+1) >= SumColunm )
                                      {
                                         ClearDisplayLine( 2 );
                                      }
                                      else
                                      {
                                                                      len = sprintf( str, "Column%02buErrNum:%u", WayCheck.WayNo[i+1], WayCheck.BreakCount[i+1] );
                                                              DisplayStr( 0, 1, 1, str, len );                                                
                                                              }
                                                      #endif                                  
 282   5                                                      //DispFlag = 1;
 283   5                                                      DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
 284   5                                                      LineNum = 1;                                            
 285   5                                              }
 286   4                                   }
 287   3                                       break;
 288   3                              case KEY_DOWN://下移
 289   3                      if( i >= SumColunm ) break;//如果i的直超出货道直，则不能再递增了
 290   3                                  i++;                                
 291   3                                      if( LineNum == 1 )//选中标记下移
 292   3                                      {                                
 293   4                                           DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标                                 
 294   4                                           LineNum = 2;                                    
 295   4                                       }
 296   3                                       else//菜单下翻
 297   3                                       {      
 298   4                                      if( i >= SumColunm )//如果i的直超出货道直，则不能再下翻了
 299   4                                                      break;
 300   4                                              else
 301   4                                              {                                       
 302   5                                              #ifdef _CHINA_     
 303   5                                                  len = sprintf( str, "货道%02bu故障次\xca\xfd:%u", WayCheck.WayNo[i], WayCheck.BreakCount[i] );
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 6   

 304   5                                              DisplayStr( 0, 0, 1, str, len );
 305   5                                                  
 306   5                                                      //如果下一行超出货道直，就不能显示了
 307   5                              if( (i+1) >= SumColunm )
 308   5                              {
 309   6                                 ClearDisplayLine( 2 );
 310   6                              }
 311   5                              else
 312   5                              {
 313   6                                                         len = sprintf( str, "货道%02bu故障次\xca\xfd:%u", WayCheck.WayNo[i+1], WayCheck.BreakCount[i+1] )
             -;
 314   6                                                 DisplayStr( 0, 1, 1, str, len );
 315   6                              }
 316   5                                                              
 317   5                                              #else
                                                              len = sprintf( str, "Column%02buErrNum:%u", WayCheck.WayNo[i], WayCheck.BreakCount[i] );
                                                      DisplayStr( 0, 0, 1, str, len );
                                                          
                                                              if( (i+1) >= SumColunm )
                                      {
                                         ClearDisplayLine( 2 );
                                      }
                                      else
                                      {
                                                                 len = sprintf( str, "Column%02buErrNum:%u", WayCheck.WayNo[i+1], WayCheck.BreakCount[i+1] );
                                                         DisplayStr( 0, 1, 1, str, len );
                                                              }
                              
                                                      #endif                                          
 332   5                                                      //DispFlag = 1; 
 333   5                                                      DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标      
 334   5                                                      LineNum = 2;                                    
 335   5                                              }
 336   4                                      }
 337   3                                      break;
 338   3                           case KEY_CANCEL:
 339   3                                      return;
 340   3                                      break;                                  
 341   3                      }
 342   2              ClearKey();     
 343   2                      CoreProcessCycle(); //让出时间片
 344   2                      DelayMs( 10 );
 345   2                      //WaitForWork( 50, NULL );
 346   2              }       
 347   1      }
 348          
 349          //测试货道
 350          void  GoodsWayTest()
 351          {
 352   1              u_char xdata m_ChannelNum = 0;
 353   1              u_char xdata m_Index = 0;
 354   1              u_char xdata m_str[20];
 355   1              u_char xdata i = 0;
 356   1              u_char xdata len = 0;
 357   1              u_char xdata j = 0;
 358   1              
 359   1              m_ChannelNum = InputGoodsWayNo( 0 );
 360   1              if( m_ChannelNum == 100 )
 361   1                      return;
 362   1          GoodsSetSave = 1;         //Added by Andy 2011.6.8
 363   1              if( m_ChannelNum == 99 )  //货道全检
 364   1              {       
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 7   

 365   2              //初始化货道检测数组的初始故障值,by gzz 20110302
 366   2              for( m_Index = 0; m_Index < GOODSWAYNUM; m_Index ++ )
 367   2              {
 368   3                 WayCheck.WayNo[m_Index] = InputGoodsWayList[m_Index].GoodsWayNo;
 369   3                 WayCheck.BreakCount[m_Index] = 0;
 370   3              } 
 371   2              while( 1 )
 372   2              {
 373   3                          WayCheck.testNum++;
 374   3                      GoodsSetSave = 1;
 375   3                          //Trace("\n GoodsSetSave = %bu", GoodsSetSave );
 376   3                              for( m_Index = 0; m_Index < GOODSWAYNUM; m_Index ++ )                                   
 377   3                              {                       
 378   4                                      i = 0;  
 379   4                                      i = GetKey();
 380   4                                      if ( i == KEY_CANCEL )
 381   4                                  {
 382   5                                              ClearKey();
 383   5                                              return;
 384   5                                      }
 385   4                                      WaitForWork( 100, NULL );       
 386   4                                      if( InputGoodsWayList[m_Index].UseState == 0 )
 387   4                                              continue;
 388   4                                      m_ChannelNum = InputGoodsWayList[m_Index].SetArrayNo;
 389   4                                      //清除其它状态位
 390   4                                      GoodsWaySetVal[ m_Index ].WayState = 0x01;              
 391   4                              #ifdef _CHINA_
 392   4                                      len = sprintf( m_str, "\xd5\xfd在检测 %02bu 货道", InputGoodsWayList[m_Index].GoodsWayNo );     
 393   4                              #else
                                              len = sprintf( m_str, "Checking column %02bu", InputGoodsWayList[m_Index].GoodsWayNo );
                                      #endif
 396   4                                      DisplayStr( 0, 0, 1, m_str, len );
 397   4                              #ifdef _CHINA_
 398   4                                      len = sprintf( m_str,  "    请稍等..." );
 399   4                              #else
                                              len = sprintf( m_str,  "Please wait..." );
                                      #endif
 402   4                                      DisplayStr( 0, 1, 1, m_str, len );
 403   4                                      WaitForWork( 500, NULL );       
 404   4                                      i = 0;
 405   4                                      j = 0;
 406   4                                      #ifdef   _SJJ_//升降机
 407   4                                              i = ChannelLifterTask( InputGoodsWayList[m_Index].GoodsWayNo, CHANNEL_TEST );           
 408   4                                      #else         //普通货道
                                      i = ChannelTask( m_ChannelNum, CHANNEL_TEST );          
                                              #endif                                  
 411   4                              #ifdef _CHINA_                  
 412   4                                      if( i )
 413   4                                      {
 414   5                                              if( i == 2 )//主板与货道板通讯超时
 415   5                                              {                               
 416   6                                                      len = sprintf( m_str, "  货道板: 故障   " );
 417   6                                                      /*
 418   6                                                      for( i = 0; i < GOODSWAYNUM; i ++ )
 419   6                                                      GoodsWaySetVal[ i ].WayState |= 0x09;
 420   6                                      */              
 421   6                                                      j = 1;                  
 422   6                                              }                               
 423   5                                              else
 424   5                                              {
 425   6                                                  if( (i!=7)&&(i!=8) )
 426   6                                                      {
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 8   

 427   7                                                              GoodsWaySetVal[ m_Index ].WayState = 0x03;//修改货道状态查询;by gzz 20120323
 428   7                                                              len = sprintf( m_str, "  货道%02bu: 故障   ", InputGoodsWayList[m_Index].GoodsWayNo );
 429   7                                                              WayCheck.BreakCount[m_Index]+=1;
 430   7                                                      }
 431   6                                                      else if( i==8 )
 432   6                                                      {
 433   7                                                          #ifdef  SYS_GOOS_SOLDOUT_CTR
 434   7                                                                      GoodsWaySetVal[ m_Index ].WayState = 0x05;
 435   7                                                              #endif
 436   7                                                              len = sprintf( m_str, "  货道%02bu: 无货   ", InputGoodsWayList[m_Index].GoodsWayNo );
 437   7                                                      }
 438   6                      
 439   6                                              }
 440   5                                      }
 441   4                                      else
 442   4                                      {
 443   5                                              GoodsWaySetVal[ m_Index ].WayState = 0x01;
 444   5                                              len = sprintf( m_str, "  货道 %02bu:  \xd5\xfd常 ", InputGoodsWayList[m_Index].GoodsWayNo );
 445   5                                      }
 446   4                              #else
                                              if( i )
                                              {
                                                      if( i == 2 )
                                                      {                               
                                                              len = sprintf( m_str, "Broad:    Error " );
                                                              /*
                                                              for( i = 0; i < GOODSWAYNUM; i ++ )
                                                                      GoodsWaySetVal[ i ].WayState |= 0x09;
                                                  */          
                                                              j = 1;
                                                      }                               
                                                      else
                                                      {
                                                              if( (i!=7)&&(i!=8) )
                                                              {
                                                                      GoodsWaySetVal[ m_Index ].WayState = 0x03;//修改货道状态查询;by gzz 20120323
                                                                      len = sprintf( m_str, "Column %02bu: Error", InputGoodsWayList[m_Index].GoodsWayNo );
                                                              }
                                                              else if( i==8 )
                                                              {
                                                                  #ifdef  SYS_GOOS_SOLDOUT_CTR
                                                                              GoodsWaySetVal[ m_Index ].WayState = 0x05;
                                                                      #endif
                                                                      len = sprintf( m_str, "Column %02bu: Soldout", InputGoodsWayList[m_Index].GoodsWayNo );
                                                              }
                                                      }
                                              }
                                              else
                                              {
                                                      GoodsWaySetVal[ m_Index ].WayState = 0x01;
                                                      len = sprintf( m_str, "Column %02bu:    OK", InputGoodsWayList[m_Index].GoodsWayNo );
                                              }               
                                      #endif
 480   4                              //Trace( " \n SystemParameter.BanknoteMax = %d", SystemParameter.BanknoteMax );
 481   4                                      ClearDisplayLine( 1 );
 482   4                                      DisplayStr( 0, 1, 1, m_str, len );
 483   4                                      WaitForWork( 2000, NULL );//by gzz 20120215
 484   4                                      if( j == 1 )
 485   4                                      {
 486   5                                              j = 0;
 487   5                                              break;
 488   5                                      }
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 9   

 489   4                                      i = 0;  
 490   4                                      i = GetKey();
 491   4                                      if ( i == KEY_CANCEL )
 492   4                                  {
 493   5                                              ClearKey();
 494   5                                              DispGoodsCheckValue();
 495   5                                              return;
 496   5                                      }       
 497   4                                      if(sysVPMission.msActTimer == 0)
 498   4                                      {
 499   5                                              sysVPMission.msActTimer = 100;
 500   5                                              VPMission_Act_RPT(VP_ACT_ADMIN,VP_ACT_ENTERADMIN);
 501   5                                      }
 502   4                              }       
 503   3                              //if(sysVPMission.msActTimer == 0)
 504   3                              //{
 505   3                              //      sysVPMission.msActTimer = 50;
 506   3                              //      VPMission_Act_RPT(VP_ACT_ADMIN,VP_ACT_ENTERADMIN);
 507   3                              //}
 508   3                              //return;       
 509   3              }               
 510   2              }
 511   1      
 512   1      
 513   1              //单检指定货道
 514   1      //  if( InputGoodsWayList[m_Index].UseState != 1 )
 515   1      //                      continue;
 516   1              memset( m_str,0, sizeof( m_str ) );
 517   1              m_Index = InputGoodsWayList[m_ChannelNum].SetArrayNo;                           
 518   1      //      m_ChannelNum = InputGoodsWayList[m_Index].SetArrayNo;
 519   1      #ifdef _CHINA_
 520   1              sprintf( m_str, "\xd5\xfd在检测 %02bu 货道", InputGoodsWayList[m_ChannelNum].GoodsWayNo );
 521   1              DisplayStr( 0, 0, 1, m_str, 16 );
 522   1              sprintf( m_str,  "    请稍等..." );                     
 523   1              DisplayStr( 0, 1, 1, m_str, 13 );
 524   1      #else                           
                      sprintf( m_str, "Checking Column %02bu", InputGoodsWayList[m_ChannelNum].GoodsWayNo );  
              //              Trace( "\n Test goodsCode = %bu", m_ChannelNum );
                      DisplayStr( 0, 0, 1, m_str, 18 );
                      sprintf( m_str,  "Please wait..." );
                      DisplayStr( 0, 1, 1, m_str, 14 );
              #endif  
 531   1              WaitForWork( 100, NULL );               
 532   1              i = 0;
 533   1      //      i = ChannelExec( m_Index );
 534   1              Trace("\n GoodsWayTest m_Index = %bu", m_Index);
 535   1      
 536   1              #ifdef   _SJJ_//升降机
 537   1                      i = ChannelLifterTask( InputGoodsWayList[m_ChannelNum].GoodsWayNo, CHANNEL_TEST );              
 538   1              #else         //普通货道
                      i = ChannelTask( m_Index, CHANNEL_TEST );               
                      #endif
 541   1              
 542   1              //清除其它状态位
 543   1              GoodsWaySetVal[ m_ChannelNum ].WayState = 0x01;
 544   1      #ifdef _CHINA_
 545   1              if( i )
 546   1              {
 547   2                      if( i == 2 )
 548   2                      {
 549   3                              sprintf( m_str, "  货道板: 故障   " );
 550   3                  /*
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 10  

 551   3                              for( i = 0; i < GOODSWAYNUM; i ++ )
 552   3                                      GoodsWaySetVal[ i ].WayState |= 0x09;
 553   3                  */                  
 554   3                      }                               
 555   2                      else
 556   2                      {
 557   3                              if( (i!=7)&&(i!=8) )
 558   3                              {
 559   4                                      GoodsWaySetVal[ m_ChannelNum ].WayState = 0x03;//修改货道状态查询;by gzz 20120323
 560   4                                      len = sprintf( m_str, "  货道%02bu: 故障   ", InputGoodsWayList[m_ChannelNum].GoodsWayNo );
 561   4                              }
 562   3                              else if( i==8 )
 563   3                              {
 564   4                                  #ifdef  SYS_GOOS_SOLDOUT_CTR
 565   4                                              GoodsWaySetVal[ m_ChannelNum ].WayState = 0x05;
 566   4                                      #endif
 567   4                                      len = sprintf( m_str, "  货道%02bu: 无货   ", InputGoodsWayList[m_ChannelNum].GoodsWayNo );
 568   4                              }
 569   3                      }
 570   2              }
 571   1              else
 572   1              {
 573   2                      GoodsWaySetVal[ m_ChannelNum ].WayState = 0x01;
 574   2                      sprintf( m_str, "  货道 %02bu:  \xd5\xfd常 ", InputGoodsWayList[m_ChannelNum].GoodsWayNo );
 575   2              }
 576   1      #else
                      if( i )
                      {
                              if( i == 2 )
                              {
                                      sprintf( m_str, "Broad:   Error   " );
                                      /*
                                      for( i = 0; i < GOODSWAYNUM; i ++ )
                                              GoodsWaySetVal[ i ].WayState |= 0x09;
                          */                                  
                              }                       
                              else
                              {
                                      if( (i!=7)&&(i!=8) )
                                      {
                                              GoodsWaySetVal[ m_ChannelNum ].WayState = 0x03;//修改货道状态查询;by gzz 20120323
                                              len = sprintf( m_str, "Column %02bu: Error", InputGoodsWayList[m_ChannelNum].GoodsWayNo );
                                      }
                                      else if( i==8 )
                                      {
                                          #ifdef  SYS_GOOS_SOLDOUT_CTR
                                                      GoodsWaySetVal[ m_ChannelNum ].WayState = 0x05;
                                              #endif
                                              len = sprintf( m_str, "Column %02bu: Soldout", InputGoodsWayList[m_ChannelNum].GoodsWayNo );
                                      }
                              }
                      }
                      else
                      {
                              GoodsWaySetVal[ m_ChannelNum ].WayState = 0x01;
                              sprintf( m_str, "Column %02bu:    OK ", InputGoodsWayList[m_ChannelNum].GoodsWayNo );
                      }                               
              #endif
 609   1              GoodsSetSave = 1;
 610   1              Trace("\n GoodsWayTest GoodsWaySetVal[%bu].WayState = %02bx", m_ChannelNum,GoodsWaySetVal[ m_ChannelNum ]
             -.WayState );
 611   1              ClearDisplayLine( 1 );
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 11  

 612   1              DisplayStr( 0, 1, 1, m_str, 17 );
 613   1              WaitForWork( 2000, NULL );
 614   1              if( i == 3 )
 615   1              {
 616   2                      for( i = 0; i < GOODSWAYNUM; i ++ )
 617   2                      {
 618   3                              //清除其它状态位
 619   3                  //GoodsWaySetVal[ i ].WayState = 0x00;
 620   3                              //GoodsWaySetVal[ i ].WayState = 0x09;
 621   3                      }
 622   2              }
 623   1      }
 624          
 625          
 626          /*脉冲硬币测试*/
 627          void CoinerTest()
 628          {       
 629   1              u_int xdata CoinSum = 0;
 630   1              u_int xdata CoinMnu = 0;
 631   1              u_char xdata str[20];
 632   1              u_char xdata flag = 0;
 633   1              u_char xdata len = 0;
 634   1              u_char xdata MyKey = 0;
 635   1          u_char xdata coinFull = 0;
 636   1          u_char xdata disFullFlag = 0;
 637   1              u_char xdata disEmpFlag = 0;
 638   1      
 639   1              //照明灯测试
 640   1              Trace( "Coiner Test begin\n" );
 641   1              CoinerEnable();//使能硬币器
 642   1      #ifdef _CHINA_
 643   1              DisplayStr( 0, 0, 1,"    硬币器测试", 14 );
 644   1              DisplayStr( 0, 1, 1, "请投币:", 7 );
 645   1      #else
                      DisplayStr( 0, 0, 1,"Coin Acceptor test!", 19 );
                //DisplayStr( 0, 1, 1, "Insert coin:\x24", 13 );
                      DisplayStr( 0, 1, 1, "Insert coin:", 12 );
              #endif
 650   1              
 651   1          //SgwSecTimer= 30;          
 652   1              memset( str, 0, sizeof( str ) );
 653   1              while( 1 )
 654   1              {
 655   2                      WaitForWork( 100, NULL );
 656   2                      CoinMnu = GetCoin();    
 657   2                      if( CoinMnu != 0 )
 658   2                      {               
 659   3                              while ( CoinMnu ) 
 660   3                              {               
 661   4                      #ifdef _COIN_INPUT_PARALLEL                     
 662   4                                      CoinSum += CoinMnu;
 663   4                      #else
                                              CoinSum += CoinMnu*COINMULTIPLE;                        
                              #endif
 666   4                                      Trace("\n CoinSum = %u", CoinSum);
 667   4                      SchedulerProcess();
 668   4                      WaitForWork( SYS_WAIT_NEXT_PULSE, NULL );    //Wait for the next pulse, 100-300-120       
             -          
 669   4                                      CoinMnu = GetCoin();
 670   4                              }
 671   3                              flag = 1;
 672   3                  WaitForWork( 100, NULL );
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 12  

 673   3                      }
 674   2      
 675   2              //----------------------------------------------------
 676   2              if( IfCoinHopperFull() )
 677   2              {
 678   3                  if( coinFull == 0 )
 679   3                  {
 680   4                              coinFull = 1;
 681   4                      CoinerDisable();
 682   4                      disFullFlag = 1;
 683   4                  }
 684   3              }
 685   2              else
 686   2              {
 687   3                  if( coinFull == 1 )
 688   3                  {
 689   4                      CoinerEnable();
 690   4                      coinFull = 0;
 691   4                                      flag = 1;
 692   4                                      disEmpFlag = 1;
 693   4                  }
 694   3              }
 695   2              //====================================================
 696   2              if( coinFull == 1 )
 697   2              {
 698   3                  if (disFullFlag == 1)
 699   3                              {
 700   4                          #ifdef _CHINA_
 701   4                                                      len = sprintf( str, "  币斗已满, 请处理!"  );   
 702   4                                      #else
                                                              len = sprintf( str, "  Coin full, check!" );            
                                              #endif  
 705   4                          ClearDisplayLine( 2 );
 706   4                              DisplayStr( 0, 0, 1, str, len );  
 707   4                      disFullFlag = 0;
 708   4                          }
 709   3                   
 710   3              }
 711   2                      else if( flag == 1 )
 712   2                      {       
 713   3                          if(disEmpFlag == 1 )
 714   3                              {
 715   4                          #ifdef _CHINA_
 716   4                                              DisplayStr( 0, 0, 1,"    硬币器测试", 14 );
 717   4                                      #else
                                                      DisplayStr( 0, 0, 1,"Coin Acceptor test!", 19 );
                                              #endif
 720   4                                      disEmpFlag = 0;
 721   4                              }
 722   3      
 723   3                              switch( SystemParameter.curUnit )
 724   3                              {
 725   4                                      case 1:
 726   4                              #ifdef _CHINA_
 727   4                                              len = sprintf( str, "已投入金额: %u", CoinSum );        
 728   4                              #else
                                                      len = sprintf( str, "Insert coin: %u", CoinSum );               
                                      #endif  
 731   4                                      break;                          
 732   4                                      case 10:
 733   4                              #ifdef _CHINA_
 734   4                                              len = sprintf( str, "已投入金额: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.cur
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 13  

             -Unit );        
 735   4                              #else
                                                      len = sprintf( str, "Insert coin: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.cu
             -rUnit );                
                                      #endif  
 738   4                                      break;
 739   4                                      case 100:
 740   4                              #ifdef _CHINA_
 741   4                                              len = sprintf( str, "已投入金额: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.c
             -urUnit );        
 742   4                              #else
                                                      len = sprintf( str, "Insert coin: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.
             -curUnit );                
                                      #endif  
 745   4                                      break;
 746   4                                      default:
 747   4                                              len = 0;
 748   4                                              memset( str, 0, sizeof( str ) );
 749   4                                      break;
 750   4                              }
 751   3                              if( len != 0 )
 752   3                              {
 753   4                                      DisplayStr( 0, 1, 1, str, len );
 754   4                                      flag = 0;
 755   4                              }
 756   3                      }
 757   2                      MyKey = GetKey();               
 758   2                      if( ( MyKey  == KEY_SUBMIT ) || ( MyKey  == KEY_CANCEL ) )
 759   2                              break;
 760   2              }               
 761   1              CoinerDisable();//禁能硬币器
 762   1      #ifdef _CHINA_
 763   1              len = ChooseReturn( "  硬币器是否\xd5\xfd常?" );
 764   1      #else
                      len = ChooseReturn( "Coin Acceptor OK ?" );     
              #endif  
 767   1              if( len == 0 )//正常            
 768   1                      DeviceStatus.CoinAccepter = 0;          
 769   1              else            
 770   1                      DeviceStatus.CoinAccepter = 1;  
 771   1      }
 772          
 773          //展示灯和压缩机测试，1代表展示灯，2代表压缩机
 774          void ACDCModuleTest(uchar xdata testDev)
 775          {       
 776   1              u_char xdata len = 0;
 777   1              u_char xdata key = 0;
 778   1              u_char xdata DevStr[10];
 779   1              u_char xdata str[20];
 780   1          
 781   1              //111017 by cq 
 782   1              //提示ACDC模式未开启
 783   1              if( SystemParameter.ACDCModule == 0 )
 784   1              {
 785   2                      //...
 786   2      #ifdef _CHINA_
 787   2                              len = sprintf( str, "%s", "ACDC模式未开启" );
 788   2                              DisplayStr( 0, 0, 1, str, len ); 
 789   2      #else           
                                      len = sprintf( str, "%s", "ACDCmode closed" );  
                                      DisplayStr( 0, 0, 1, str, len ); 
              #endif
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 14  

 793   2              ClearDisplayLine( 2 );
 794   2                      WaitForWork(2000, NULL);
 795   2                      return;
 796   2              }
 797   1      
 798   1              if(testDev == 1)
 799   1              {
 800   2                      #ifdef _CHINA_
 801   2                              sprintf( DevStr, "%s", "展示灯" );
 802   2                      #else
                                      sprintf( DevStr, "%s", "Light" );
                              #endif          
 805   2              }
 806   1              else if(testDev == 2)
 807   1              {
 808   2                      #ifdef _CHINA_
 809   2                              sprintf( DevStr, "%s", "压缩机" );
 810   2                      #else
                                      sprintf( DevStr, "%s", "Compressor" );
                              #endif          
 813   2              }
 814   1      
 815   1              #ifdef _CHINA_
 816   1                      len = sprintf( str, "  %s测试", DevStr );
 817   1                      DisplayStr( 0, 0, 1, str, len ); 
 818   1                      DisplayStr( 0, 1, 1, "1-打开  2-关闭", 14 );
 819   1              #else           
                              len = sprintf( str, "  %s Test!", DevStr );             
                          DisplayStr( 0, 0, 1, str, len ); 
                              DisplayStr( 0, 1, 1, "1-Open 2-Close", 14 );
                      #endif
 824   1              
 825   1              ClearKey();     
 826   1          while( 1 )
 827   1              {
 828   2                      key = GetKey();
 829   2                      if(key == KEY_1 ) 
 830   2                      {
 831   3                          if( testDev == 1 )
 832   3                              {
 833   4                                  sysVPMission.ACDCLedCtr = 1; 
 834   4                              }
 835   3                              else
 836   3                              {
 837   4                                      sysVPMission.ACDCCompressorCtr = 1;
 838   4                              }
 839   3                              ACDCMission();
 840   3                              ClearDisplayLine( 1 );
 841   3                          ClearDisplayLine( 2 );
 842   3                              #ifdef _CHINA_
 843   3                                      len = sprintf( str, "%s已打开，请确认", DevStr );                               
 844   3                              #else
                                              len = sprintf( str, "Open %s", DevStr );                                
                                      #endif  
 847   3                              DisplayStr( 0, 0, 1, str, len ); 
 848   3                      }
 849   2                      else if(key == KEY_2 ) 
 850   2                      {
 851   3                          if( testDev == 1 )
 852   3                              {
 853   4                                  sysVPMission.ACDCLedCtr = 0; 
 854   4                              }
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 15  

 855   3                              else
 856   3                              {
 857   4                                      sysVPMission.ACDCCompressorCtr = 0;
 858   4                              }
 859   3                              ACDCMission();
 860   3      
 861   3                              ClearDisplayLine( 1 );
 862   3                          ClearDisplayLine( 2 );
 863   3                              #ifdef _CHINA_
 864   3                                      len = sprintf( str, "%s已关闭，请确认", DevStr );                               
 865   3                              #else
                                              len = sprintf( str, "Close %s", DevStr );                               
                                      #endif  
 868   3                              DisplayStr( 0, 0, 1, str, len ); 
 869   3                      }
 870   2                      else if((key==KEY_CANCEL)||(key==KEY_SUBMIT))
 871   2                  {
 872   3                          #ifdef _CHINA_
 873   3                                      len = sprintf( str, "请不要随意关闭设备！");                            
 874   3                              #else
                                              len = sprintf( str, "Keep the dev work..." );                           
                                      #endif  
 877   3                              ClearDisplayLine( 2 );
 878   3                              DisplayStr( 0, 0, 1, str, len ); 
 879   3                          WaitForWork( 2000, NULL );
 880   3                              break;
 881   3                      }
 882   2                      WaitForWork( 100, NULL );       
 883   2              }       
 884   1      }
 885          
 886          
 887          void ITLBillATest()
 888          {       
 889   1              u_int xdata  CoinSum = 0;
 890   1              u_int xdata  CoinMnu = 0;
 891   1              u_char xdata str[20];
 892   1              u_char xdata flag = 0;
 893   1              u_char xdata len = 0;
 894   1              u_char xdata MyKey = 0;
 895   1              u_char xdata mission = 0;
 896   1      
 897   1              ITLMission_Init();
 898   1      #ifdef _CHINA_
 899   1              DisplayStr( 0, 0, 1,"    纸币器测试", 14 );
 900   1              DisplayStr( 0, 1, 1, "请投币:", 7 );
 901   1      #else
                      DisplayStr( 0, 0, 1, "Bill Acceptor test!", 19 );
                      DisplayStr( 0, 1, 1, "Insert bill:", 12 );
              #endif          
 905   1              memset( str, 0, sizeof( str ) );
 906   1          //ITLMission_Enable();
 907   1              ITLMission_Init_1();
 908   1      
 909   1              while( 1 )
 910   1              {
 911   2              
 912   2              flag = 0;  
 913   2      
 914   2              if( (SystemParameter.BillNo==1)&&(sysITLMission.ITLSet==1))
 915   2              {
 916   3                              if( /*(sysITLMission.billSta&ITL_BILL_SJAM)||*/( sysITLMission.billSta& ITL_BILL_UJAM) )
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 16  

 917   3                          {
 918   4                                      ITLMission_Init_1();
 919   4                              }
 920   3                      //
 921   3                              if((sysITLMission.status&ITL_DEV_FAIL)||(sysITLMission.status&ITL_DEV_FATTN)/*||(sysITLMission.status&I
             -TL_DEV_NCFFAR)||( sysITLMission.status&ITL_DEV_NCICBAR)*/)
 922   3                              {
 923   4                                      ITLMission_Init_1();
 924   4                              }
 925   3                  }
 926   2              
 927   2                      if( (SystemParameter.BillNo==1)&&(sysITLMission.ITLSet==1)&&(sysITLMission.enableFlag==1)&&(sysITLMissio
             -n.status&ITL_DEV_DISABLED) )
 928   2                  {
 929   3                      //flag = ITLMission_Enable();
 930   3                              sysITLMission.reEnableFlag = 1;
 931   3                              if( sysITLMission.reEnableTime >= ITL_TIME_DISABLED_INIT )
 932   3                              {
 933   4                                      flag = ITLMission_Init_1();
 934   4                                      sysITLMission.reEnableTime = 0;
 935   4                              }
 936   3                  }
 937   2                      else
 938   2                      {
 939   3                          sysITLMission.reEnableFlag = 0;     
 940   3                      }
 941   2      
 942   2                  if( (sysITLMission.ITLSet==1)&&(sysITLMission.msPoll == 0)/*&&( DeviceStatus.BillAccepter == 0 )*/ )
 943   2              {
 944   3                      mission = ITLMission_Poll(); 
 945   3                  sysITLMission.msPoll = ITL_TIME_POLL;    //
 946   3              }
 947   2            
 948   2                      if( sysITLMission.billSta & ITL_BILL_READ )
 949   2                      {
 950   3                  sysITLMission.billSta    &= ~ ITL_BILL_READ;
 951   3                  sysITLMission.billStaCtr |= ITL_BILL_READ;
 952   3                              if( (CoinSum+sysITLMission.billValue) > 10000 )
 953   3                              {
 954   4                                      mission = ITLMission_Reject();
 955   4                              }
 956   3                      }
 957   2      
 958   2                      //if( sysITLMission.billSta & ITL_BILL_CREDIT )
 959   2              if( ( sysITLMission.billSta & ITL_BILL_CREDIT )&&( sysITLMission.billStaCtr & ITL_BILL_READ )/*&&(
             - CurrentPayed < SystemParameter.BanknoteMax )*/ )
 960   2                      {
 961   3                  sysITLMission.billSta    &= ~ITL_BILL_CREDIT;
 962   3                  sysITLMission.billStaCtr &= ~ITL_BILL_READ;
 963   3                  CoinSum += sysITLMission.billValue;
 964   3                              if( CoinSum >= 10000 )
 965   3                              {
 966   4                                      mission = ITLMission_Disable();
 967   4                              }
 968   3                              flag = 1;
 969   3                      }
 970   2      
 971   2              if( sysITLMission.billSta & ITL_BILL_STACKED )
 972   2                      {   /*
 973   3                              CoinSum += sysITLMission.billValue;
 974   3                              if( CoinSum >= 10000 )
 975   3                              {
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 17  

 976   3                                      mission = ITLMission_Disable();
 977   3                              }
 978   3                              flag = 1;
 979   3                  */
 980   3                      }
 981   2             
 982   2                      if( flag == 1 )
 983   2                      {       
 984   3                              switch( SystemParameter.curUnit )
 985   3                              {
 986   4                                      case 1:
 987   4                              #ifdef _CHINA_
 988   4                                              len = sprintf( str, "已投入金额: %u", CoinSum );        
 989   4                              #else
                                                      len = sprintf( str, "Insert bill: %u", CoinSum );               
                                      #endif  
 992   4                                      break;                          
 993   4                                      case 10:
 994   4                              #ifdef _CHINA_
 995   4                                              len = sprintf( str, "已投入金额: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.cur
             -Unit );        
 996   4                              #else
                                                      len = sprintf( str, "Insert bill: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.cu
             -rUnit );                
                                      #endif  
 999   4                                      break;
1000   4                                      case 100:
1001   4                              #ifdef _CHINA_
1002   4                                              len = sprintf( str, "已投入金额: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.c
             -urUnit );        
1003   4                              #else
                                                      len = sprintf( str, "Insert bill: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.
             -curUnit );                
                                      #endif  
1006   4                                      break;
1007   4                                      default:
1008   4                                              len = 0;
1009   4                                              memset( str, 0, sizeof( str ) );
1010   4                                      break;
1011   4                              }
1012   3                              if( len != 0 )
1013   3                              {
1014   4                                      DisplayStr( 0, 1, 1, str, len );
1015   4                                      flag = 0;
1016   4                              }
1017   3                      }
1018   2                      MyKey = GetKey();               
1019   2                      if( ( MyKey  == KEY_SUBMIT ) || ( MyKey  == KEY_CANCEL ) )
1020   2              {
1021   3                              break;
1022   3              }
1023   2              }               
1024   1      
1025   1              ITLMission_Disable();
1026   1      #ifdef _CHINA_
1027   1              len = ChooseReturn( "  纸币器是否\xd5\xfd常?" );
1028   1      #else
                      len = ChooseReturn( "Bill acceptor OK ?" );     
              #endif  
1031   1      
1032   1              if( len == 0 )//正常            
1033   1                      DeviceStatus.BillAccepter = 0;          
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 18  

1034   1              else            
1035   1                      DeviceStatus.BillAccepter = 1;  
1036   1          
1037   1      }
1038          
1039          /*****************************************************************************
1040          * 1*k豪秒延时
1041          * k的取值范围0~65535
1042          *****************************************************************************/
1043          void DELAY_MS(uint k)
1044          {
1045   1      uint j;
1046   1      
1047   1      while(k!=0)
1048   1        {
1049   2        k--;
1050   2        for(j=0;j<4800;j++);
1051   2        }
1052   1      }
1053          
1054          /*
1055          void MDBBillATest( void )
1056          {       
1057                  u_int xdata  CoinSum = 0;
1058                  u_int xdata  CoinMnu = 0;
1059                  u_char xdata str[20];
1060                  u_char xdata flag = 0;
1061                  u_char xdata len = 0;
1062                  u_char xdata MyKey = 0;
1063                  u_char xdata mission = 0;
1064                  
1065                  uchar const JUSTCOMMAND[1]={0};
1066                  uchar const COIN_TYPE[4]={0xff, 0xff, 0xff, 0xff};
1067                  uchar const DISPENSE1[1]={0x10};
1068                  uchar const DISPENSE2[1]={0x11};
1069                  uchar const EXPANSION[2]={0x02,0x03};  
1070                  uchar const BILL_TYPE[4]={0xff, 0xff, 0xff, 0xff};
1071                  uchar const ESCROW1[1]={0xff};  //压钞
1072                  uchar const ESCROW2[1]={0x00};  //退钞
1073              
1074          #ifdef _CHINA_
1075                  DisplayStr( 0, 0, 1," MDB纸币器测试", 14 );
1076                  DisplayStr( 0, 1, 1, "请投币:", 7 );
1077          #else
1078                  DisplayStr( 0, 0, 1, "Bill Acceptor test!", 19 );
1079                  DisplayStr( 0, 1, 1, "Insert bill:", 12 );
1080          #endif          
1081              //DELAY_MS(100);
1082                  DelayMs( 100 );
1083                  MDBMission_Init(); 
1084              DelayMs( 200 );
1085                  memset( str, 0, sizeof( str ) );
1086          
1087              Session(0x08,JUSTCOMMAND,0);        //复位硬币机
1088                  Session(0x30,JUSTCOMMAND,0);        //复位纸币机
1089                  //DELAY_MS(500);
1090              DelayMs( 500 );
1091                  Session(0x09,JUSTCOMMAND,0);        //SETUP硬币机;
1092                  Session(0x0c,COIN_TYPE,4);          //COIN TYPE
1093                  Session(0x34,BILL_TYPE,4);          //BILL TYPE
1094              
1095                  while( 1 )
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 19  

1096                  {       
1097                  //MDBMission_Init();
1098                          Session(0x0b,JUSTCOMMAND,0);  //轮询硬币机,poll
1099                  Session(0x33,JUSTCOMMAND,0);  //轮询纸币机,poll
1100                          MyKey = GetKey();               
1101                          if( ( MyKey  == KEY_SUBMIT ) || ( MyKey  == KEY_CANCEL ) )
1102                  {
1103                                  break;
1104                  }
1105                  }               
1106              ITLSerialInit();
1107          #ifdef _CHINA_
1108                  len = ChooseReturn( "  纸币器是否\xd5\xfd常?" );
1109          #else
1110                  len = ChooseReturn( "Bill acceptor OK ?" );     
1111          #endif  
1112                  if( len == 0 )//正常            
1113                          DeviceStatus.BillAccepter = 0;          
1114                  else            
1115                          DeviceStatus.BillAccepter = 1;      
1116          }
1117          */
1118          
1119          
1120          void MDBBillATest( void )
1121          {       
1122   1              u_int xdata  CoinSum = 0;
1123   1              u_int xdata  CoinMnu = 0;
1124   1              u_char xdata str[20];
1125   1              u_char xdata flag = 0;
1126   1              u_char xdata len = 0;
1127   1              u_char xdata MyKey = 0;
1128   1              u_char xdata mission = 0;
1129   1          u_char xdata i = 0;
1130   1      
1131   1          //111019 by gzz 
1132   1              //提示纸币器未开启
1133   1              if( SystemParameter.BillNo == 0 )
1134   1              {
1135   2                      //...
1136   2      #ifdef _CHINA_
1137   2                              len = sprintf( str, "%s", "纸币器未开启" );
1138   2                              DisplayStr( 0, 0, 1, str, len ); 
1139   2      #else           
                                      len = sprintf( str, "%s", "Coin closed" );      
                                      DisplayStr( 0, 0, 1, str, len ); 
              #endif
1143   2              ClearDisplayLine( 2 );
1144   2                      WaitForWork(2000, NULL);
1145   2                      return;
1146   2              }
1147   1      
1148   1          //启动不成功，重试三次;by gzz 20111025
1149   1          DelayMs( 50 );
1150   1          do
1151   1          {
1152   2                      MDBMission_Bill_Init();
1153   2              i++; 
1154   2              DelayMs( 100 );
1155   2          }
1156   1          while((sysMDBMission.billDeviceStatus!=0)&&(i<3));
1157   1          
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 20  

1158   1      
1159   1      #ifdef _CHINA_
1160   1              DisplayStr( 0, 0, 1,"    纸币器测试", 14 );
1161   1              DisplayStr( 0, 1, 1, "请投币:", 7 );
1162   1      #else
                      DisplayStr( 0, 0, 1, "Bill Acceptor test!", 19 );
                      DisplayStr( 0, 1, 1, "Insert bill:", 12 );
              #endif          
1166   1              memset( str, 0, sizeof( str ) );
1167   1          DelayMs( 100 );
1168   1          
1169   1              
1170   1          
1171   1              while( 1 )
1172   1              {
1173   2              flag = 0;            
1174   2                      mission =MDB_Bill_IfSecrow( sysMDBMission.billBuf, &sysMDBMission.billBufLen, &sysMDBMission.billType );
1175   2              if( mission == 1 )
1176   2                      {
1177   3                          if( CoinSum+SystemParameter.billValue[sysMDBMission.billType] >=65000 )
1178   3                  {
1179   4                                      mission = MDB_Bill_EscrowCtr( 0 );
1180   4                              }
1181   3                          else
1182   3                              {
1183   4                                      mission = MDB_Bill_EscrowCtr( 1 );
1184   4                      if(mission==0)
1185   4                      {   
1186   5                                          sysVPMission.billSTimer = TIME_BILL_STACK;  
1187   5                                          while( sysVPMission.billSTimer )
1188   5                                              {
1189   6                              mission = MDB_Bill_IfStacked( sysMDBMission.billBuf, &sysMDBMission.billBufLen );
1190   6                                                      if( mission == 1 )
1191   6                                                  {
1192   7                                              CoinSum += SystemParameter.billValue[sysMDBMission.billType];
1193   7                                              memset(sysMDBMission.billBuf,0,sizeof(sysMDBMission.billBuf));
1194   7                                                              sysMDBMission.billBufLen=0;
1195   7                                                              sysMDBMission.billType=0;
1196   7                                                              sysMDBMission.billStock=0;
1197   7                                                              flag = 1;
1198   7                                  break;//更新币值慢，而且容易投入纸币后，将其暂存而不显示金额;by gzz 20111021
1199   7                                                      }
1200   6                                              }
1201   5                      }
1202   4                              }                                       
1203   3                      }
1204   2             
1205   2                      if( flag == 1 )
1206   2                      {       
1207   3                          
1208   3                              switch( SystemParameter.curUnit )
1209   3                              {
1210   4                                      case 1:
1211   4                              #ifdef _CHINA_
1212   4                                              len = sprintf( str, "已投入金额: %u", CoinSum );        
1213   4                              #else
                                                      len = sprintf( str, "Inserted bill: %u", CoinSum );             
                                      #endif  
1216   4                                      break;                          
1217   4                                      case 10:
1218   4                              #ifdef _CHINA_
1219   4                                              len = sprintf( str, "已投入金额: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.cur
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 21  

             -Unit );        
1220   4                              #else
                                                      len = sprintf( str, "Inserted bill: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.
             -curUnit );                
                                      #endif  
1223   4                                      break;
1224   4                                      case 100:
1225   4                              #ifdef _CHINA_
1226   4                                              len = sprintf( str, "已投入金额: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.c
             -urUnit );        
1227   4                              #else
                                                      len = sprintf( str, "Inserted bill: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParamete
             -r.curUnit );                
                                      #endif  
1230   4                                      break;
1231   4                                      default:
1232   4                                              len = 0;
1233   4                                              memset( str, 0, sizeof( str ) );
1234   4                                      break;
1235   4                              }
1236   3                              if( len != 0 )
1237   3                              {
1238   4                                  // 
1239   4                      DelayMs( 50 );
1240   4                                      //DelayMs( 50 );
1241   4                                      DisplayStr( 0, 1, 1, str, len );
1242   4                                      flag = 0; 
1243   4                                      //
1244   4                                      DelayMs( 100 );
1245   4                          MDBSerialInit();
1246   4                      DelayMs( 100 );
1247   4                              }
1248   3                      }
1249   2                      MyKey = GetKey();               
1250   2                      if( ( MyKey  == KEY_SUBMIT ) || ( MyKey  == KEY_CANCEL ) )
1251   2              {
1252   3                              break;
1253   3              }
1254   2              }
1255   1              MDB_Bill_EscrowCtr(0);
1256   1              MDBMission_Bill_Disable();
1257   1      #ifdef _CHINA_
1258   1              len = ChooseReturn( "  纸币器是否\xd5\xfd常?" );
1259   1      #else
                      len = ChooseReturn( "Bill acceptor OK ?" );     
              #endif  
1262   1      
1263   1              if( len == 0 )
1264   1              {       
1265   2                      DeviceStatus.BillAccepter = 0;
1266   2                      sysMDBMission.billDeviceStatus = 0;
1267   2              }
1268   1              else 
1269   1              {       
1270   2                      DeviceStatus.BillAccepter = 1;
1271   2                      sysMDBMission.billDeviceStatus = 1;
1272   2              }
1273   1          
1274   1      }
1275          
1276          void MDBCoinATest( void )
1277          {       
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 22  

1278   1              u_int xdata  CoinSum = 0;
1279   1              u_int xdata  CoinMnu = 0;
1280   1              u_char xdata str[20];
1281   1              u_char xdata flag = 0;
1282   1              u_char xdata len = 0;
1283   1              u_char xdata MyKey = 0;
1284   1              u_char xdata mission = 0;
1285   1          u_char xdata i = 0;
1286   1      
1287   1             
1288   1              //111019 by gzz 
1289   1              //提示硬币器未开启      
1290   1              if( SystemParameter.coinOn == 0 )
1291   1              {   
1292   2                      //...
1293   2      #ifdef _CHINA_
1294   2                              len = sprintf( str, "%s", "硬币器未开启" );
1295   2                              DisplayStr( 0, 0, 1, str, len ); 
1296   2      #else           
                                      len = sprintf( str, "%s", "Coin closed" );      
                                      DisplayStr( 0, 0, 1, str, len ); 
              #endif
1300   2              ClearDisplayLine( 2 );
1301   2                      WaitForWork(2000, NULL);
1302   2                      return;
1303   2              }
1304   1      
1305   1          //调整启动的位置;by gzz 20120323
1306   1          //启动不成功，重试三次;by gzz 20111025
1307   1          DelayMs( 50 );
1308   1          do
1309   1          { 
1310   2                      MDBMission_Coin_Init(); 
1311   2              i++; 
1312   2              DelayMs( 100 );
1313   2          }
1314   1          while((sysMDBMission.coinDeviceStatus!=0)&&(i<3));
1315   1      
1316   1      #ifdef _CHINA_
1317   1              DisplayStr( 0, 0, 1,"    硬币器测试", 14 );
1318   1              DisplayStr( 0, 1, 1, "请投币:", 7 );
1319   1      #else
                      DisplayStr( 0, 0, 1,"Coin Acceptor test!", 19 );
                      DisplayStr( 0, 1, 1, "Insert coin:", 12 );
              #endif  
1323   1              memset( str, 0, sizeof( str ) );    
1324   1          DelayMs( 100 );
1325   1          
1326   1              while( 1 )
1327   1              {
1328   2              
1329   2              flag = 0;          
1330   2              mission = MDB_Coin_IfDeposited( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen, &sysMDBMission.c
             -oinType, &sysMDBMission.coinStock );
1331   2              if( mission == 1 )
1332   2                      {
1333   3                              CoinSum += SystemParameter.coinValue[sysMDBMission.coinType];
1334   3                              flag = 1;
1335   3                  memset(sysMDBMission.coinBuf,0,sizeof(sysMDBMission.coinBuf));
1336   3                              sysMDBMission.coinBufLen=0;
1337   3                              sysMDBMission.coinType=0;
1338   3                              sysMDBMission.coinStock=0;
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 23  

1339   3                      }
1340   2                      if( flag == 1 )
1341   2                      {       
1342   3                          
1343   3                              switch( SystemParameter.curUnit )
1344   3                              {
1345   4                                      case 1:
1346   4                              #ifdef _CHINA_
1347   4                                              len = sprintf( str, "已投入金额: %u", CoinSum );        
1348   4                              #else
                                                      len = sprintf( str, "Inserted coin: %u", CoinSum );             
                                      #endif  
1351   4                                      break;                          
1352   4                                      case 10:
1353   4                              #ifdef _CHINA_
1354   4                                              len = sprintf( str, "已投入金额: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.cur
             -Unit );        
1355   4                              #else
                                                      len = sprintf( str, "Inserted coin: %u.%u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.
             -curUnit );                
                                      #endif  
1358   4                                      break;
1359   4                                      case 100:
1360   4                              #ifdef _CHINA_
1361   4                                              len = sprintf( str, "已投入金额: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParameter.c
             -urUnit );        
1362   4                              #else
                                                      len = sprintf( str, "Inserted coin: %u.%02u", CoinSum/SystemParameter.curUnit, CoinSum%SystemParamete
             -r.curUnit );                
                                      #endif  
1365   4                                      break;
1366   4                                      default:
1367   4                                              len = 0;
1368   4                                              memset( str, 0, sizeof( str ) );
1369   4                                      break;
1370   4                              }
1371   3                              if( len != 0 )
1372   3                              {
1373   4                      DelayMs( 50 );
1374   4                                      DisplayStr( 0, 1, 1, str, len );
1375   4                                      flag = 0; 
1376   4                                      DelayMs( 100 );
1377   4                          MDBSerialInit(); 
1378   4                      DelayMs( 200 );
1379   4                              }
1380   3                      }
1381   2                      MyKey = GetKey();               
1382   2                      if( ( MyKey  == KEY_SUBMIT ) || ( MyKey  == KEY_CANCEL ) )
1383   2              {
1384   3                              break;
1385   3              }
1386   2              }
1387   1              
1388   1              //退出时，更新硬币剩余金额;by gzz 20120309
1389   1              MDB_Coin_TubeSta_API(); 
1390   1          WaitForWork(1000,NULL);
1391   1              MDBMission_Coin_Disable();
1392   1              WaitForWork(1000,NULL);
1393   1      #ifdef _CHINA_
1394   1              len = ChooseReturn( "  硬币器是否\xd5\xfd常?" );
1395   1      #else
                      len = ChooseReturn( "Bill acceptor OK ?" );     
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 24  

              #endif  
1398   1      
1399   1              if( len == 0 )
1400   1              {       
1401   2                      DeviceStatus.CoinAccepter = 0;
1402   2                      sysMDBMission.coinDeviceStatus = 0;
1403   2              }
1404   1              else    
1405   1              {
1406   2                      DeviceStatus.CoinAccepter = 1;  
1407   2                      sysMDBMission.coinDeviceStatus |= 0x01;
1408   2              }
1409   1      }
1410          
1411          
1412          void MDBHopperATest( uchar xdata testDev )
1413          {       
1414   1              u_char xdata mission = 0;
1415   1              u_char xdata len = 0;
1416   1              u_char xdata dispensedNum = 0;
1417   1          u_char xdata coin[MDB_MAX_BLOCK_SIZF];
1418   1          u_char xdata coinLen;
1419   1          
1420   1              //修改退币函数;by gzz 20110721
1421   1              if(testDev == 1)
1422   1              {
1423   2                      #ifdef _CHINA_
1424   2                              len = ChooseReturn( "  五角退币，一次两枚" );
1425   2                      #else
                                      len = ChooseReturn( "5jiao" );  
                              #endif  
1428   2                      if( len == 0 )//确认退币
1429   2                      {
1430   3                  sysMDBMission.coinDeviceStatus = 1;
1431   3                              mission=MDB_Coin_Dispense(0,2);
1432   3                  DelayMs(500);
1433   3                              if(mission==0)
1434   3                              {
1435   4                      sysVPMission.hopperOutTimer = 20;
1436   4                                  while( sysVPMission.hopperOutTimer )
1437   4                                      {
1438   5                                      mission = MDB_Coin_EXP_PayoutValuePoll( &dispensedNum );
1439   5                                              if( mission == 0x00 )
1440   5                                              {
1441   6                                                      mission = MDB_Coin_EXP_PayoutStatus( &coin, &coinLen );
1442   6                                                      if( mission == 0x01 )
1443   6                                                      {
1444   7                                                          sysMDBMission.coinDeviceStatus = 0;  
1445   7                                  break;
1446   7                                                      }                                               
1447   6                                              }                                       
1448   5                                      }
1449   4                                      //sysMDBMission.coinDeviceStatus = 0;
1450   4                              }
1451   3                              else
1452   3                              {
1453   4                                      sysMDBMission.coinDeviceStatus = 1;
1454   4                              }
1455   3                      }
1456   2                      
1457   2              }
1458   1              else if(testDev == 2)
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 25  

1459   1              {
1460   2                      #ifdef _CHINA_
1461   2                              len = ChooseReturn( "  一元退币，一次两枚" );
1462   2                      #else
                                      len = ChooseReturn( "1yuan" );  
                              #endif  
1465   2                      if( len == 0 )//确认退币
1466   2                      {
1467   3                  sysMDBMission.coinDeviceStatus = 1;
1468   3                              mission=MDB_Coin_Dispense(1,2);
1469   3                              DelayMs(500);
1470   3                              if(mission==0)
1471   3                              {
1472   4                      sysVPMission.hopperOutTimer = 20;
1473   4                                  while( sysVPMission.hopperOutTimer )
1474   4                                      {
1475   5                                      mission = MDB_Coin_EXP_PayoutValuePoll( &dispensedNum );
1476   5                                              if( mission == 0x00 )
1477   5                                              {
1478   6                                                      mission = MDB_Coin_EXP_PayoutStatus( &coin, &coinLen );
1479   6                                                      if( mission == 0x01 )
1480   6                                                      {
1481   7                                                          sysMDBMission.coinDeviceStatus = 0;  
1482   7                                  break;
1483   7                                                      }                                               
1484   6                                              }                                       
1485   5                                      }
1486   4                                      //sysMDBMission.coinDeviceStatus = 0;
1487   4                              }
1488   3                              else
1489   3                              {
1490   4                                      sysMDBMission.coinDeviceStatus = 1;
1491   4                              }
1492   3                      }
1493   2              }    
1494   1      }
1495          
1496          
1497          /*选货按钮测试*/
1498          void ButtonTest()
1499          {               
1500   1              unsigned char xdata key = 0;
1501   1              unsigned char xdata Oldkey = 0 ;
1502   1              u_char xdata str[20];   
1503   1              u_char xdata len = 0;
1504   1              u_char xdata MyKey = 0;
1505   1      
1506   1              Trace( "\n Button test begin" );        
1507   1      #ifdef _CHINA_
1508   1              DisplayStr( 0 , 0 , 1 , "    按钮测试!" , 13 );                 
1509   1              DisplayStr( 0, 1, 1, "输入按钮:", 9 );  
1510   1      #else
                      DisplayStr( 0 , 0 , 1 , "Button test!" , 12 );          
                      DisplayStr( 0, 1, 1, "Input:", 6 );     
              #endif
1514   1          WaitForWork( 200, NULL );   
1515   1              //SgwSecTimer= 30;
1516   1              //Open the led
1517   1          sysVPMission.sel1ReadyLed = 0xff;
1518   1          sysVPMission.sel1ErrLed   = 0xff;
1519   1          sysVPMission.sel2ReadyLed = 0xff;
1520   1          sysVPMission.sel2ErrLed   = 0xff;
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 26  

1521   1          sysVPMission.sel3ReadyLed = 0xff;
1522   1          sysVPMission.sel3ErrLed   = 0xff;           
1523   1              while( 1 )
1524   1              {
1525   2                      WaitForWork( 100, NULL );
1526   2                      /*
1527   2                      key = PowerCotrlTask( POWER_QUERY );
1528   2                      Trace( "\n key1 = %bu", key );
1529   2                      */
1530   2                      key = GetKey_M2();
1531   2              WaitForWork( 100, NULL );
1532   2                      if( ( key >= 0 ) && ( key < GOODSTYPEMAX ) )
1533   2                      {
1534   3                  key += 1;            
1535   3                              Trace( "\n key2 = %bu", key );  
1536   3                              Trace( "\n Oldkey = %bu", Oldkey );     
1537   3                              if( Oldkey != key )
1538   3                              {
1539   4                              #ifdef _CHINA_
1540   4                                      len = sprintf( str, "输入按钮: %bu", key );     
1541   4                              #else
                                              len = sprintf( str, "Input: %bu",key );
                                      #endif                          
1544   4                                      DisplayStr( 0, 1, 1, str, len );        
1545   4                                      Oldkey = key;
1546   4                      WaitForWork( 200, NULL );
1547   4                              }
1548   3                      }
1549   2                      key = GetKey();         
1550   2                      if( ( key  == KEY_SUBMIT ) || ( key  == KEY_CANCEL ) )
1551   2                              break;
1552   2              }
1553   1              //Close the led
1554   1              sysVPMission.sel1ReadyLed = 0x00;
1555   1          sysVPMission.sel1ErrLed   = 0x00;
1556   1          sysVPMission.sel2ReadyLed = 0x00;
1557   1          sysVPMission.sel2ErrLed   = 0x00;
1558   1          sysVPMission.sel3ReadyLed = 0x00;
1559   1          sysVPMission.sel3ErrLed   = 0x00;
1560   1          key = GetKey_M2();
1561   1      }
1562          
1563          void GameButtonTest()
1564          {               
1565   1              unsigned char xdata key = 0;
1566   1              unsigned char xdata Oldkey = 0 ;
1567   1              //u_char xdata str[20]; 
1568   1              u_char xdata len = 0;
1569   1              u_char xdata MyKey = 0;
1570   1      
1571   1              Trace( "\n Game button test begin" );   
1572   1      #ifdef _CHINA_
1573   1              DisplayStr( 0 , 0 , 1 , "    游戏按钮测试!" , 17 );             
1574   1              DisplayStr( 0, 1, 1, "有键按下, 则鸣叫一声", 20  );     
1575   1      #else
                      DisplayStr( 0 , 0 , 1 , "Game button test!" , 17 );             
                      DisplayStr( 0, 1, 1, "Beep for one press!", 19 );       
              #endif
1579   1          WaitForWork( 200, NULL );   
1580   1              //SgwSecTimer= 30;
1581   1              //Open the led
1582   1              GameLedOn();
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 27  

1583   1              while( 1 )
1584   1              {
1585   2                      //WaitForWork( 100, NULL );
1586   2                      if( IfGameKeyOn() )
1587   2                      {
1588   3                              Beep();
1589   3                              /*
1590   3                  #ifdef _CHINA_
1591   3                                      len = sprintf( str, "按钮: 1" );        
1592   3                              #else
1593   3                                      len = sprintf( str, "Button: 1");
1594   3                              #endif  
1595   3                              DisplayStr( 0, 1, 1, str, len );        
1596   3                  WaitForWork( 100, NULL );
1597   3                              */
1598   3                      }
1599   2                      key = GetKey();         
1600   2                      if( ( key  == KEY_SUBMIT ) || ( key  == KEY_CANCEL ) )
1601   2                              break;
1602   2              }
1603   1              //Close the led
1604   1          GameLedOff();
1605   1      }
1606          
1607          
1608          //111017 by cq 出货确认  
1609          void GOCTest()
1610          {       
1611   1              u_char xdata len = 0;
1612   1              u_char xdata key = 0;
1613   1              u_char xdata DevStr[10];
1614   1              u_char xdata str[20];
1615   1      
1616   1              ClearDisplayLine( 1 );
1617   1              ClearDisplayLine( 2 );
1618   1          
1619   1              if( SystemParameter.GOCOn == 0 )
1620   1              {
1621   2                  //...       
1622   2      #ifdef _CHINA_
1623   2                      len = sprintf( str, "%s", "出货确认未开启" );
1624   2                      DisplayStr( 0, 0, 1, str, len ); 
1625   2      #else           
                              len = sprintf( str, "%s", "GOC closed" );       
                              DisplayStr( 0, 0, 1, str, len ); 
              #endif
1629   2                      WaitForWork(2000,NULL);
1630   2                      return;
1631   2              }
1632   1              
1633   1      #ifdef _CHINA_
1634   1                              sprintf( DevStr, "%s", "出货确认" );
1635   1      #else
                                      sprintf( DevStr, "%s", "GOC" );
              #endif          
1638   1      
1639   1              #ifdef _CHINA_
1640   1                      len = sprintf( str, "  %s测试", DevStr );
1641   1                      DisplayStr( 0, 0, 1, str, len ); 
1642   1                      //DisplayStr( 0, 1, 1, "1-打开  2-关闭", 14 );
1643   1              #else           
                              len = sprintf( str, "  %s Test!", DevStr );             
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 28  

                          DisplayStr( 0, 0, 1, str, len ); 
                              //DisplayStr( 0, 1, 1, "1-Open 2-Close", 14 );
                      #endif
1648   1              WaitForWork( 500, NULL );       
1649   1              ClearKey();     
1650   1              
1651   1          while( 1 )
1652   1              {
1653   2                      key = GetKey();         
1654   2                      ChannelTask( 0, CHANNEL_QUERY );
1655   2                      
1656   2                      if( SystemParameter.GOCOn == 1 )
1657   2                      {
1658   3                                 if( Channel.State & 0x80 )
1659   3                                 {
1660   4                                         //DeviceStatus.GOCStatus |= 0x01; 
1661   4      
1662   4                                      #ifdef _CHINA_
1663   4                                              len = sprintf( str, "%s", "    检测到有遮挡" );         
1664   4                                              DisplayStr( 0, 1, 1, str, len );
1665   4                                      #else           
                                                      len = sprintf( str, "%s", "is covering GOC" );          
                                                      DisplayStr( 0, 1, 1, str, len );
                                              #endif
1669   4                                 }
1670   3                                 else
1671   3                                 {
1672   4                                         //DeviceStatus.GOCStatus &= 0xFE;
1673   4      
1674   4                                      #ifdef _CHINA_
1675   4                                         len = sprintf( str, "%s", "    请遮挡两秒" );           
1676   4                                         DisplayStr( 0, 1, 1, str, len );
1677   4                                      #else           
                                                 len = sprintf( str, "%s", "cover GOC 2sec" );           
                                                 DisplayStr( 0, 1, 1, str, len );
                                              #endif
1681   4                                 }
1682   3                      }
1683   2                      
1684   2                                      
1685   2                      if((key==KEY_CANCEL)||(key==KEY_SUBMIT))
1686   2                  {
1687   3                              SystemSave = 1;
1688   3                              break;
1689   3                      }
1690   2                      WaitForWork( 500, NULL );//可以适当延长
1691   2              }       
1692   1      }
1693          
1694          
1695          void ReturnButtonTest()
1696          {               
1697   1              unsigned char xdata key = 0;
1698   1              unsigned char xdata Oldkey = 0 ;
1699   1              //u_char xdata str[20]; 
1700   1              u_char xdata len = 0;
1701   1              u_char xdata MyKey = 0;
1702   1      
1703   1              Trace( "\n Game button test begin" );   
1704   1      #ifdef _CHINA_
1705   1              DisplayStr( 0 , 0 , 1 , "    退币按钮测试!" , 17 );             
1706   1              DisplayStr( 0, 1, 1,    "      没有按下", 14  );        
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 29  

1707   1      #else
                      DisplayStr( 0 , 0 , 1 , "Return button test!" , 19 );           
                      DisplayStr( 0, 1, 1, "Beep for one press!", 19 );       
              #endif
1711   1          WaitForWork( 200, NULL );   
1712   1              //SgwSecTimer= 30;
1713   1              //Open the led
1714   1              //GameLedOn();
1715   1              while( 1 )
1716   1              {
1717   2              //Added  for changer return key
1718   2              MDB_Coin_IfDeposited( sysMDBMission.coinBuf, &sysMDBMission.coinBufLen, &sysMDBMission.coinType, &
             -sysMDBMission.coinStock );
1719   2                      WaitForWork( 100, NULL );
1720   2                      if( IfReturnKeyOn() )
1721   2                      {
1722   3                              Beep();
1723   3                              DisplayStr( 0, 1, 1,    "    按下退币按钮", 16  );
1724   3                              WaitForWork( 2000, NULL );
1725   3                              DisplayStr( 0, 1, 1,    "      没有按下", 14  );
1726   3                              IfReturnKeyOn();
1727   3                      }
1728   2                      key = GetKey();         
1729   2                      if( ( key  == KEY_SUBMIT ) || ( key  == KEY_CANCEL ) )
1730   2                              break;
1731   2              }
1732   1              //Close the led
1733   1          //GameLedOff();
1734   1      }
1735          
1736          void ICCardTest()
1737          {               
1738   1              
1739   1      }
1740          
1741          
1742          
1743          
1744          /*取得设备的状态,可取状态的设备有纸硬币器，退币器，*/
1745          void GetDeviceStatus(unsigned char iDeviceID )
1746          {
1747   1              u_char   xdata flag ;
1748   1      //      unsigned char xdata i;  
1749   1      
1750   1              flag = 0;
1751   1              switch(iDeviceID)
1752   1              {       
1753   2                      case 0:       //1纸币器状态     
1754   2                  #ifdef MACHINE_SET_MDB
1755   2                      break;
1756   2                  #else
                              if( SystemParameter.BillNo == 1 )                               
                                              {
                                      if( sysITLMission.ITLSet == 1 )
                                      {
                                          //flag = ITLMission_Syn();
                                          flag = ITLMission_Poll();
                                          if( flag == ITL_ERR_NULL )
                                          {
                                              DeviceStatus.BillAccepter = 0;
                                          }
                                          else
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 30  

                                          {
                                              DeviceStatus.BillAccepter |= 0x01;
                                          }
                                      }
                                      else
                                      {
                                                              flag = GetHardWareDeviceState( 4, &Casher );
                                                              if( flag == 0 )
                                                              {
                                                                      flag = 0;
                                                                      flag = TestDeviceException( &Casher );                  
                                                                      if ( flag )
                                                                      {                                       
                                                                              DeviceStatus.BillAccepter = 1;
                                                                              return ;
                                                                      }
                                                                      else                            
                                                                              DeviceStatus.BillAccepter = 0;                          
                                                              }       
                                                              else
                                                  DeviceStatus.BillAccepter = 1;
                                      }               
                                              }
                                              else
                                                      DeviceStatus.BillAccepter = 128;
                                              Trace( "\n DeviceStatus.BillAccepter = %bu", DeviceStatus.BillAccepter );
                                              break;              
                          #endif              
1796   2                      case 1:       //2硬币器状态
1797   2                  #ifdef MACHINE_SET_MDB
1798   2                      break;
1799   2                  #else
                                              CoinerTest();
                                              WaitForWork( 100, NULL );               
                                              break;
                          #endif                      
1804   2                      case 2:       //3 #1退币器测试  
1805   2                  #ifdef MACHINE_SET_MDB
1806   2                                  DeviceStatus.ChangeUnit1 = 0;
1807   2                      break;            
1808   2                  #endif
1809   2                              if( SystemParameter.HopperCoinPrice1 == 0 )
1810   2                              { 
1811   3                                      DeviceStatus.ChangeUnit1 = 1;
1812   3                                      break;
1813   3                              }               
1814   2                              if( m_iCheckDevice )
1815   2                              {                       
1816   3                                      flag = HopperOutCoin( 0, 1, &Hopper1 );  //出币5枚,5-0(Chnaged by Andy on 2011.3.3 )
1817   3                                      WaitForWork( 1500 , NULL );
1818   3                                      if( flag == 0 )                          //出币命令发送成功
1819   3                                      {                               
1820   4                                              flag = GetHardWareDeviceState( 1, &Hopper1 );
1821   4                                              if( flag != 1 )
1822   4                                              {
1823   5                                                      
1824   5                            //if( Hopper1.State & 0x50 )         //系统故障
1825   5                              if( Hopper1.State & 0x50 )         //系统故障                                                                                                                                                                                                   
1826   5                                                              DeviceStatus.ChangeUnit1 = 1;
1827   5                              else if( Hopper1.State & 0x08 ) 
1828   5                                  DeviceStatus.ChangeUnit1 = 4;
1829   5                                                      else if( Hopper1.State & 0x20 )    //光测无币或实际无币                                                 
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 31  

1830   5                                                              DeviceStatus.ChangeUnit1 = 2;                                           
1831   5                                                      else                                            
1832   5                                                              DeviceStatus.ChangeUnit1 = 0;                                           
1833   5                                              }       
1834   4                                              else
1835   4                                                      DeviceStatus.ChangeUnit1 = 1;
1836   4                                      }
1837   3                                      else//出币命令发送不成功                                
1838   3                                              DeviceStatus.ChangeUnit1 = 1;                           
1839   3                              }
1840   2                              else
1841   2                              {
1842   3                                      flag = GetHardWareDeviceState( 1, &Hopper1 );                   
1843   3                                      if( flag != 1 )
1844   3                                      {                                       
1845   4                                              if( Hopper1.State & 0x50 )         //系统故障                                                                                                                                                                                                   
1846   4                                                      DeviceStatus.ChangeUnit1 = 1;
1847   4                          else if( Hopper1.State & 0x08 ) 
1848   4                              DeviceStatus.ChangeUnit1 = 4;
1849   4                                              else if( Hopper1.State & 0x20 )    //光测无币或实际无币                                                 
1850   4                                                      DeviceStatus.ChangeUnit1 = 2;                                           
1851   4                                              else                                            
1852   4                                                      DeviceStatus.ChangeUnit1 = 0;                                   
1853   4                                      }       
1854   3                                      else
1855   3                                              DeviceStatus.ChangeUnit1 = 1;
1856   3                              }
1857   2                              WaitForWork( 100, NULL );
1858   2                              break;                                                          
1859   2                      case 3:       //3 #2退币器测试  
1860   2      
1861   2                          #ifdef MACHINE_SET_MDB  
1862   2                      DeviceStatus.ChangeUnit2 = 0;     
1863   2                      break;            
1864   2                  #endif
1865   2      
1866   2                              if( SystemParameter.HopperCoinPrice2 == 0 )
1867   2                              {
1868   3                                      DeviceStatus.ChangeUnit2 = 1;
1869   3                                      break;
1870   3                              }               
1871   2                              if( m_iCheckDevice )
1872   2                              {                               
1873   3                                      flag = HopperOutCoin( 0, 2, &Hopper2 );   //出币5枚, 5-0(Chnaged by Andy on 2011.3.3 )
1874   3                                      WaitForWork( 1500 , NULL );
1875   3                                      if( flag == 0 )//出币命令发送成功
1876   3                                      {                                       
1877   4                                              flag = GetHardWareDeviceState( 2, &Hopper2 );                   
1878   4                                              if( flag != 1 )
1879   4                                              {
1880   5                                                      if( Hopper2.State & 0x50 )        //系统故障                                                                                                                                                                                                    
1881   5                                                              DeviceStatus.ChangeUnit2 = 1;
1882   5                              else if( Hopper2.State & 0x08 )
1883   5                                  DeviceStatus.ChangeUnit2 = 4;
1884   5                                                      else if( Hopper2.State & 0x20 )   //光测无币或实际无币                                                  
1885   5                                                              DeviceStatus.ChangeUnit2 = 2;                                           
1886   5                                                      else                                            
1887   5                                                              DeviceStatus.ChangeUnit2 = 0;                                                   
1888   5                                              }       
1889   4                                              else
1890   4                                                      DeviceStatus.ChangeUnit2 = 1;
1891   4                                      }
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 32  

1892   3                                      else//出币命令发送不成功                                
1893   3                                              DeviceStatus.ChangeUnit2 = 1;                           
1894   3                              }
1895   2                              else
1896   2                              {
1897   3                                      flag = GetHardWareDeviceState( 2, &Hopper2 );
1898   3                                      Trace("\n Hopper2 flag = %bu", flag );                  
1899   3                                      if( flag != 1 )
1900   3                                      {
1901   4                                              if( Hopper2.State & 0x50 )          //系统故障                                                                                                                                                                                                  
1902   4                                                      DeviceStatus.ChangeUnit2 = 1;
1903   4                          else if( Hopper2.State & 0x08 )
1904   4                              DeviceStatus.ChangeUnit2 = 4;
1905   4                                              else if( Hopper2.State & 0x20 )     //光测无币或实际无币                                                        
1906   4                                                      DeviceStatus.ChangeUnit2 = 2;                                           
1907   4                                              else                                            
1908   4                                                      DeviceStatus.ChangeUnit2 = 0;                                           
1909   4                                      }       
1910   3                                      else
1911   3                                              DeviceStatus.ChangeUnit2 = 1;
1912   3                              }
1913   2                              WaitForWork( 100, NULL );
1914   2                              break;
1915   2                 case 4:       //3 #1退币器测试
1916   2      
1917   2                      #ifdef MACHINE_SET_MDB
1918   2                      DeviceStatus.ChangeUnit3 = 0;
1919   2                      break;            
1920   2                  #endif
1921   2      
1922   2                              if( SystemParameter.HopperCoinPrice3 == 0 )
1923   2                              {
1924   3                                      DeviceStatus.ChangeUnit3 = 1;
1925   3                                      break;
1926   3                              }               
1927   2                              if( m_iCheckDevice )
1928   2                              {                               
1929   3                                      flag = HopperOutCoin( 0, 3, &Hopper3 );   //出币5枚, 5-0(Chnaged by Andy on 2011.3.3 )
1930   3                                      WaitForWork( 1500 , NULL );
1931   3                                      if( flag == 0 )                           //出币命令发送成功
1932   3                                      {                                       
1933   4                                              flag = GetHardWareDeviceState( 3, &Hopper3 );                   
1934   4                                              if( flag != 1 )
1935   4                                              {
1936   5                                                      if( Hopper3.State & 0x50 )          //系统故障                                                                                                                                                                                                  
1937   5                                                              DeviceStatus.ChangeUnit3 = 1;
1938   5                              else if( Hopper3.State & 0x08 )     //Empty                                                     
1939   5                                                              DeviceStatus.ChangeUnit3 = 4; 
1940   5                                                      else if( Hopper3.State & 0x20 )     //光测无币或实际无币                                                        
1941   5                                                              DeviceStatus.ChangeUnit3 = 2;                                           
1942   5                                                      else                                            
1943   5                                                              DeviceStatus.ChangeUnit3 = 0;                                                   
1944   5                                              }       
1945   4                                              else
1946   4                                                      DeviceStatus.ChangeUnit3 = 1;
1947   4                                      }
1948   3                                      else//出币命令发送不成功                                
1949   3                                              DeviceStatus.ChangeUnit3 = 1;                           
1950   3                              }
1951   2                              else
1952   2                              {
1953   3                                      flag = GetHardWareDeviceState( 3, &Hopper3 );                   
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 33  

1954   3                                      if( flag != 1 )
1955   3                                      {
1956   4                                              if( Hopper3.State & 0x50 )           //系统故障                                                                                                                                                                                                 
1957   4                                                      DeviceStatus.ChangeUnit3 = 1;
1958   4                          else if( Hopper3.State & 0x08 )     //Empty                                                 
1959   4                                                      DeviceStatus.ChangeUnit3 = 4; 
1960   4                                              else if( Hopper3.State & 0x20 )      //光测无币或实际无币                                                       
1961   4                                                      DeviceStatus.ChangeUnit3 = 2;                                           
1962   4                                              else                                            
1963   4                                                      DeviceStatus.ChangeUnit3 = 0;                                   
1964   4                                      }       
1965   3                                      else
1966   3                                              DeviceStatus.ChangeUnit3 = 1;
1967   3                              }
1968   2                              WaitForWork( 100, NULL );                       
1969   2                              break;
1970   2             case 10:
1971   2                          /*
1972   2                      {
1973   2                                      if( SystemParameter.busCardOn==0x01 )
1974   2                                      {
1975   2                                          flag = BCMission_Inq();
1976   2                                      }
1977   2                                      else
1978   2                                      {
1979   2                                              DeviceStatus.BusCard |= 0x80;
1980   2                                      }
1981   2                              }*/
1982   2                      break;
1983   2                 default:
1984   2                      break;
1985   2              }
1986   1      }
1987          
1988          /*Index,设备编号，y，显示行号，PrintFlag打印标志，此标志为1是返回值，为0时显示值*/
1989          u_char DispDeviceStatus( u_char Index, u_char y, bit PrintFlag )
1990          {
1991   1              u_char xdata yStateus = 0;
1992   1              u_char xdata uline[20];
1993   1              u_char xdata line[10];
1994   1              u_int  xdata yValue;
1995   1              u_char xdata len = 0;
1996   1              
1997   1              switch( Index )
1998   1              {
1999   2                      case 2://纸币器状态，Bit 7 -- 无此模块；Bit 6~1 保留；Bit 0 -- 故障     
2000   2                          /*
2001   2                  if( DeviceStatus.BillAccepter & 128 )//Bit 7
2002   2                                      yStateus = 2;//无此模块
2003   2                              else 
2004   2                              */
2005   2                              if( sysMDBMission.billDeviceStatus & 1 )//Bit 7
2006   2                              yStateus = 1;//故障
2007   2                              else
2008   2                                      yStateus = 0;//正常
2009   2                      break;
2010   2                      case 3://收硬币器状态，Bit 7 -- 无此模块；Bit 6~1 保留；Bit 0 -- 故障；
2011   2                          /*
2012   2                  if( DeviceStatus.CoinAccepter & 128 )//Bit 7
2013   2                                      yStateus = 2;//无此模块
2014   2                              else
2015   2                              */
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 34  

2016   2                              if( sysMDBMission.coinDeviceStatus & 1 )//Bit 7
2017   2                              yStateus = 1;//故障
2018   2                              else
2019   2                                      yStateus = 0;//正常
2020   2                      break;
2021   2                      case 4: // //#1退币器，Bit 7 -- 无此模块；Bit 6~2 保留；Bit 1 -- 缺币；Bit 0 -- 故障；
2022   2                              /*
2023   2                  if( DeviceStatus.CoinAccepter & 128 )//Bit 7
2024   2                                      yStateus = 2;//无此模块
2025   2                              else
2026   2                              */
2027   2                              if( sysMDBMission.coinDeviceStatus & 1 )//Bit 7
2028   2                              yStateus = 1;//故障
2029   2                              else
2030   2                              { 
2031   3                                      yStateus = 0;//正常
2032   3                                      yValue = sysMDBMission.coin5jValue;//正常
2033   3                              }
2034   2                      break;          
2035   2                      case 5: // //#2退币器，Bit 7 -- 无此模块；Bit 6~2 保留；Bit 1 -- 缺币；Bit 0 -- 故障；
2036   2                              /*
2037   2                  if( DeviceStatus.CoinAccepter & 128 )//Bit 7
2038   2                                      yStateus = 2;//无此模块
2039   2                              else
2040   2                              */
2041   2                              if( sysMDBMission.coinDeviceStatus & 1 )//Bit 7
2042   2                              yStateus = 1;//故障
2043   2                              else
2044   2                              { 
2045   3                                      yStateus = 0;//正常
2046   3                                      yValue = sysMDBMission.coin1yValue;//正常
2047   3                              }                               
2048   2                      break;
2049   2                      case 6://#3退币器，Bit 7 -- 无此模块；Bit 6~2 保留；Bit 1 -- 缺币；Bit 0 -- 故障；
2050   2                              /*
2051   2                              if( DeviceStatus.ChangeUnit3 & 128 )//Bit 7
2052   2                                      yStateus = 2;//无此模块
2053   2                              else
2054   2                              */
2055   2                              if( DeviceStatus.ChangeUnit3 & 6 )//Bit 7
2056   2                              yStateus = 3;//缺币
2057   2                              else if( DeviceStatus.ChangeUnit3 & 1 )//Bit 7
2058   2                              yStateus = 1;//故障
2059   2                              else
2060   2                                      yStateus = 0;//正常
2061   2                      break;
2062   2                      //case 5://手机模块，Bit 7 -- 无此模块；Bit 6~2 保留；Bit 0 -- 故障；
2063   2                      /*      
2064   2                          if( DeviceStatus.MobileStates & 128 )//Bit 7
2065   2                                      yStateus = 2;//无此模块                 
2066   2                              else if( DeviceStatus.MobileStates & 1 )//Bit 7
2067   2                              yStateus = 1;//故障
2068   2                              else
2069   2                                      yStateus = 0;//正常
2070   2                      */
2071   2                      //break;
2072   2              case 10:
2073   2                           if( DeviceStatus.BusCard & 0x80 )
2074   2                               {
2075   3                                      yStateus = 2;
2076   3                               }
2077   2                               else if( DeviceStatus.BusCard & 0x03 )
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 35  

2078   2                               {
2079   3                                  yStateus = 1;  
2080   3                               }
2081   2                               else
2082   2                               {
2083   3                                  yStateus = 0;
2084   3                               }
2085   2                      break;
2086   2      
2087   2                      default:
2088   2                      break;
2089   2              }
2090   1              if( PrintFlag == 0 )
2091   1              {
2092   2                      memcpy( uline, WMenuStr[Index].str, WMenuStr[Index].len );      
2093   2              if(((Index==4)||(Index==5))&&(yStateus == 0))
2094   2              {
2095   3                          switch( SystemParameter.curUnit )           
2096   3                              {
2097   4                                      case 1:
2098   4                                              len += sprintf( line, "%u", yValue );
2099   4                                      break;
2100   4                                      case 10:
2101   4                                              len += sprintf( line, "%u.%u", yValue/SystemParameter.curUnit, yValue%SystemParameter.curUnit );
2102   4                                      break;
2103   4                                      case 100:
2104   4                                              len += sprintf( line, "%u.%02u", yValue/SystemParameter.curUnit, yValue%SystemParameter.curUnit );
2105   4                                      break;
2106   4                              }
2107   3                              memcpy( uline + WMenuStr[Index].len, line, len );
2108   3                              DisplayStr( 0, y, 1, uline, WMenuStr[Index].len + len );
2109   3                      }
2110   2              else
2111   2              {
2112   3                              memcpy( uline + WMenuStr[Index].len, DeviceStatusStr[yStateus].str, DeviceStatusStr[yStateus].len );
2113   3                          DisplayStr( 0, y, 1, uline, WMenuStr[Index].len + DeviceStatusStr[yStateus].len );  
2114   3                      }
2115   2                              
2116   2              }
2117   1              else
2118   1                      return yStateus;
2119   1      }
2120          
2121          
2122          
2123          void DispDeviceMenu( u_char Index, u_char y)
2124          {       
2125   1      //#ifdef _HAVE_CASHER
2126   1          /*  
2127   1              if( ( Index != 5 ) && ( Index != 7 ) && ( Index != 8 ) && ( Index != 6 ) && ( Index != 9 ) && ( Index != 
             -10 ) && ( Index != 11 ) && ( Index != 13 ) )                                                                                  
2128   1                      DispDeviceStatus( Index, y, 0 );                                                
2129   1              else
2130   1                      DisplayStr( 0, y, 1, WMenuStr[Index].str, WMenuStr[Index].len );
2131   1          */    
2132   1          //111024 by cq 删除
2133   1          //if( (Index==0)||(Index==1)||(Index==2)||(Index==3)||(Index==4)||(Index==0)||(Index==14))
2134   1              if( (Index==2)||(Index==3)||(Index==4)||(Index==5))
2135   1          {   
2136   2                      DispDeviceStatus( Index, y, 0 );
2137   2          }
2138   1          else
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 36  

2139   1          {
2140   2              DisplayStr( 0, y, 1, WMenuStr[Index].str, WMenuStr[Index].len );
2141   2          }
2142   1                                                      
2143   1      /*#else
2144   1              if( ( Index != 4 ) && ( Index != 5 ) )                                                                                  
2145   1                      DispDeviceStatus( Index, y, 0 );                                                
2146   1              else
2147   1                      DisplayStr( 0, y, 1, WMenuStr[Index].str, WMenuStr[Index].len );
2148   1      #endif*/
2149   1      }
2150          
2151          //显示当前货道状态
2152          void DispGoodsWaysStates()
2153          {               
2154   1              u_char xdata i = 0;
2155   1              u_char xdata j = 0;
2156   1              u_char xdata z = 0;
2157   1                                              
2158   1              u_char  xdata LineNum = 2;  //选中行在屏幕中的行号              
2159   1              u_char  xdata key;
2160   1              u_char xdata  DispFlag = 1;
2161   1              u_char xdata SumColunm = 0;
2162   1              u_char xdata m_Index = 0;
2163   1          u_char xdata str[20];
2164   1              u_char xdata len = 0;
2165   1              u_char xdata WayState[GOODSWAYNUM];
2166   1      
2167   1              memset( WayState, 0, sizeof(WayState) );
2168   1      
2169   1              for( m_Index = 0; m_Index < GOODSWAYNUM; m_Index ++ )
2170   1          {
2171   2             //WayCheck.WayNo[m_Index] = InputGoodsWayList[m_Index].GoodsWayNo;
2172   2             //WayCheck[m_Index].BreakCount = 0;
2173   2                  if( GoodsWaySetVal[m_Index].WayState == 0 )
2174   2                      {
2175   3                          //未
2176   3                          WayState[m_Index] = 0;
2177   3                      }
2178   2                      else if( GoodsWaySetVal[m_Index].WayState & 0x0A )
2179   2                      {
2180   3                          //故
2181   3                          WayState[m_Index] = 2;
2182   3                      }
2183   2                      else if( (GoodsWaySetVal[m_Index].WayState & 0x04) || (GoodsWaySetVal[m_Index].GoodsCurrentSum == 0) )
2184   2                      {
2185   3                          //缺
2186   3                          WayState[m_Index] = 3;
2187   3                      }
2188   2                      else
2189   2                      {
2190   3                          //正
2191   3                          WayState[m_Index] = 1;
2192   3                      }
2193   2          } 
2194   1              LineNum = 2;
2195   1              for( i = 0; i < GOODSWAYNUM; i ++ )
2196   1              {
2197   2                      if( InputGoodsWayList[i].GoodsWayNo != 0 )
2198   2                              SumColunm++;
2199   2                      else
2200   2                              break;
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 37  

2201   2              }
2202   1              i = 0;
2203   1          ClearKey();
2204   1      
2205   1              if( DispFlag  )
2206   1              {
2207   2                      #ifdef _CHINA_              
2208   2                          memset( str, 0, sizeof( str ) );
2209   2                          len = sprintf( str, "货道%02bu: %s", InputGoodsWayList[i].GoodsWayNo, GoodsWaysStatusStr[ WayState[i
             -] ].str );
2210   2                      DisplayStr( 0, 0, 1, str, len );
2211   2                          WaitForWork( 100, NULL );
2212   2      
2213   2                              len = sprintf( str, "货道%02bu: %s", InputGoodsWayList[i+1].GoodsWayNo, GoodsWaysStatusStr[ WayState[i+
             -1] ].str );
2214   2                      DisplayStr( 0, 1, 1, str, len );
2215   2                              WaitForWork( 100, NULL );               
2216   2                      #else   
                              memset( str, 0, sizeof( str ) );
                                  len = sprintf( str, "Column%02bu: %s", InputGoodsWayList[i].GoodsWayNo, GoodsWaysStatusStr[ WayState
             -[i] ].str );
                              DisplayStr( 0, 0, 1, str, len );
                                  WaitForWork( 100, NULL );
              
                                      len = sprintf( str, "Column%02bu: %s", InputGoodsWayList[i+1].GoodsWayNo, GoodsWaysStatusStr[ WayState[
             -i+1] ].str );
                              DisplayStr( 0, 1, 1, str, len );
                                      WaitForWork( 100, NULL );
                              #endif                  
2226   2                              DisplayCursorState( 0, LineNum-1, 1, 2, 1 );
2227   2                              DispFlag = 0;
2228   2          }
2229   1          ClearKey();
2230   1              
2231   1      
2232   1              while( 1 )    //超时或客户退出
2233   1              {        
2234   2                      key = GetKey();
2235   2                      switch( key )           
2236   2                      {
2237   3                  case KEY_UP://上移                          
2238   3                                   if( LineNum == 2 )//选中标记上移
2239   3                                   {                       
2240   4                                      DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
2241   4                                      LineNum = 1;
2242   4                                              if (i>1) i--;
2243   4                                   }
2244   3                                   else   //菜单上翻
2245   3                                   {          
2246   4                                              if( i == 0 )
2247   4                                              {
2248   5                                                      break;
2249   5                                              }
2250   4                                              else
2251   4                                              {                       
2252   5                                                  i--;
2253   5                                              #ifdef _CHINA_     
2254   5                                                  len = sprintf( str, "货道%02bu: %s", InputGoodsWayList[i].GoodsWayNo, GoodsWaysStatusStr[ WayStat
             -e[i] ].str );
2255   5                                              DisplayStr( 0, 0, 1, str, len );
2256   5                                                  
2257   5                                                      //如果下一行超出货道直，就不能显示了
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 38  

2258   5                              if( (i+1) >= SumColunm )
2259   5                              {
2260   6                                 ClearDisplayLine( 2 );
2261   6                              }
2262   5                              else
2263   5                              {
2264   6                                                              len = sprintf( str, "货道%02bu: %s", InputGoodsWayList[i+1].GoodsWayNo, GoodsWaysStatusStr[ WayStat
             -e[i+1] ].str );
2265   6                                                      DisplayStr( 0, 1, 1, str, len );        
2266   6                                                      }
2267   5                                              #else
                                                              len = sprintf( str, "Column%02bu: %s", InputGoodsWayList[i].GoodsWayNo, GoodsWaysStatusStr[ WayState
             -[i] ].str );
                                                      DisplayStr( 0, 0, 1, str, len );
                                                          
                                                              //如果下一行超出货道直，就不能显示了
                                      if( (i+1) >= SumColunm )
                                      {
                                         ClearDisplayLine( 2 );
                                      }
                                      else
                                      {
                                                                      len = sprintf( str, "Column%02bu: %s", InputGoodsWayList[i+1].GoodsWayNo, GoodsWaysStatusStr[ WaySt
             -ate[i+1] ].str );
                                                              DisplayStr( 0, 1, 1, str, len );                                                
                                                              }
                                                      #endif                                  
2282   5                                                      //DispFlag = 1;
2283   5                                                      DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
2284   5                                                      LineNum = 1;                                            
2285   5                                              }
2286   4                                   }
2287   3                                       break;
2288   3                              case KEY_DOWN://下移
2289   3                      if( i >= SumColunm ) break;//如果i的直超出货道直，则不能再递增了
2290   3                                  i++;                                
2291   3                                      if( LineNum == 1 )//选中标记下移
2292   3                                      {                                
2293   4                                           DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标                                 
2294   4                                           LineNum = 2;                                    
2295   4                                       }
2296   3                                       else//菜单下翻
2297   3                                       {      
2298   4                                      if( i >= SumColunm )//如果i的直超出货道直，则不能再下翻了
2299   4                                                      break;
2300   4                                              else
2301   4                                              {                                       
2302   5                                              #ifdef _CHINA_     
2303   5                                                  len = sprintf( str, "货道%02bu: %s", InputGoodsWayList[i].GoodsWayNo, GoodsWaysStatusStr[ WayStat
             -e[i] ].str );
2304   5                                              DisplayStr( 0, 0, 1, str, len );
2305   5                                                  
2306   5                                                      //如果下一行超出货道直，就不能显示了
2307   5                              if( (i+1) >= SumColunm )
2308   5                              {
2309   6                                 ClearDisplayLine( 2 );
2310   6                              }
2311   5                              else
2312   5                              {
2313   6                                                         len = sprintf( str, "货道%02bu: %s", InputGoodsWayList[i+1].GoodsWayNo, GoodsWaysStatusStr[ WaySt
             -ate[i+1] ].str );
2314   6                                                 DisplayStr( 0, 1, 1, str, len );
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 39  

2315   6                              }
2316   5                                                              
2317   5                                              #else
                                                              len = sprintf( str, "Column%02bu: %s", InputGoodsWayList[i].GoodsWayNo, GoodsWaysStatusStr[ WayState
             -[i] ].str );
                                                      DisplayStr( 0, 0, 1, str, len );
                                                          
                                                              if( (i+1) >= SumColunm )
                                      {
                                         ClearDisplayLine( 2 );
                                      }
                                      else
                                      {
                                                                 len = sprintf( str, "Column%02bu: %s", InputGoodsWayList[i+1].GoodsWayNo, GoodsWaysStatusStr[ Way
             -State[i+1] ].str );
                                                         DisplayStr( 0, 1, 1, str, len );
                                                              }
                              
                                                      #endif                                          
2332   5                                                      //DispFlag = 1; 
2333   5                                                      DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标      
2334   5                                                      LineNum = 2;                                    
2335   5                                              }
2336   4                                      }
2337   3                                      break;
2338   3                           case KEY_CANCEL:
2339   3                                      return;
2340   3                                      break;                                  
2341   3                      }
2342   2              ClearKey();     
2343   2                      CoreProcessCycle(); //让出时间片
2344   2                      DelayMs( 10 );
2345   2                      //WaitForWork( 50, NULL );
2346   2              }       
2347   1      }
2348          /*
2349          {
2350                  u_char xdata line1[21];
2351                  u_char xdata line2[21];
2352                  u_char xdata i = 0;
2353                  u_char xdata j = 0;
2354                  u_char xdata z = 0;
2355          #ifdef _CHINA_
2356                  u_char xdata Start = 0;
2357                  u_char xdata End = 10;
2358          #else
2359                  u_char xdata Start = 0;
2360                  u_char xdata End = 8;
2361          #endif                                  
2362                  u_char  xdata LineNum = 2;  //选中行在屏幕中的行号              
2363                  u_char  xdata key;
2364                  u_char xdata  DispFlag = 1;
2365                  u_char xdata SumColunm = 0;
2366          
2367                  key = KEY_NULL;         
2368                  ClearKey();
2369                  DisplayCursorState( 0, 1, 1, 2, 1 );//设置当在第二行上且为整行光标状态
2370                  LineNum = 2;
2371                  for( i = 0; i < GOODSWAYNUM; i ++ )
2372                  {
2373                          if( GoodsWaySetVal[i].WayNo != 0 )
2374                                  SumColunm++;
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 40  

2375                          else
2376                                  break;
2377                  }
2378          
2379                  while( 1 )    //超时或客户退出
2380                  {
2381                          if( DispFlag )
2382                          {
2383                                  memset( line1, 0, sizeof( line1 ) );    
2384                                  memset( line2, 0, sizeof( line2 ) );    
2385                                  j = 0;
2386                                  i = 0;                  
2387                                  for( i = Start; i < End; i++ )
2388                                  {       
2389                                  #ifdef _CHINA_
2390                                          if( i < ( Start + 5 ) )
2391                                  #else
2392                                          if( i < ( Start + 4 ) )
2393                                  #endif                          
2394                                          {
2395                                                  if( GoodsWaySetVal[i].WayNo == 0 )
2396                                                          continue;
2397                                          #ifdef _CHINA_
2398                                                  sprintf( line1 + 4*j, "%02bu ", GoodsWaySetVal[i].WayNo );
2399                                          #else
2400                                                  sprintf( line1 + 5*j, "%02bu ", GoodsWaySetVal[i].WayNo );
2401                                      #endif
2402                                                  z = 0;
2403                              /*
2404                                                  if( GoodsWaySetVal[i].GoodsCurrentSum == 0 )
2405                                                          z = 3;
2406                                                  z = ( GoodsWaySetVal[i].WayState & 0x0f );
2407                                                  if( ( z & 0x01 ) != 0x01 )                                              
2408                                                          z = 0;                                  
2409                                                  else if( ( z & 0x01 ) == 0x01 )
2410                                                          z = 1;
2411                                                  else if( ( z & 0x02 ) == 0x02 )
2412                                                          z = 2;
2413                                                  else if( ( z & 0x04 ) == 0x04 )
2414                                                          z = 3;  
2415                                                  else if( ( z & 0x08 ) == 0x08 )
2416                                                  {
2417                                                          if( ( z & 0x08) == 0x08 )
2418                                                                  GoodsWaySetVal[i].WayState &= 0xf0;
2419                                                          z = 4;
2420                                                  }
2421                              * /
2422                              if( GoodsWaySetVal[i].WayState == 0 )
2423                                                  {
2424                                                      //未
2425                                                      z = 0;
2426                                                  }
2427                                                  else if( GoodsWaySetVal[i].WayState & 0x0A )
2428                                                  {
2429                                                      //故
2430                                                      z = 2;
2431                                                  }
2432                                                  else if( (GoodsWaySetVal[i].WayState & 0x04) || (GoodsWaySetVal[i].GoodsCurrentSum == 0) )
2433                                                  {
2434                                                      //缺
2435                                                      z = 3;
2436                                                  }
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 41  

2437                                                  else
2438                                                  {
2439                                                      //正
2440                                                      z = 1;
2441                                                  }
2442                                          #ifdef _CHINA_
2443                                                  memcpy( line1 + 4*j + 2, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
2444                                          #else
2445                                                  memcpy( line1 + 5*j + 3, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
2446                                          #endif                                  
2447                                              //Trace("\n GoodsWaySetVal[i].WayNo = %02bu", GoodsWaySetVal[i].WayNo );            
2448                                              //Trace("\n GoodsWaySetVal[i].WayState = %bu", GoodsWaySetVal[i].WayState );                
2449                                              //Trace("\n line1 = %s", line1 );           
2450                                                  j++;
2451                                          }
2452                                          else
2453                                          {                                       
2454                                                  if( i < SumColunm )
2455                                                  {                                       
2456                                                          if( GoodsWaySetVal[i].WayNo == 0 )
2457                                                                  continue;
2458                                                  #ifdef _CHINA_
2459                                                          sprintf( line2 + 4*(j - 5 ), "%02bu ", GoodsWaySetVal[i].WayNo );
2460                                                  #else
2461                                                          sprintf( line2 + 5*(j - 4 ), "%02bu ", GoodsWaySetVal[i].WayNo );
2462                                          #endif                                          
2463                                                          z = 0;
2464                                  /*
2465                                                          if( GoodsWaySetVal[i].GoodsCurrentSum == 0 )
2466                                                                  z = 3;
2467                                                          z = ( GoodsWaySetVal[i].WayState & 0x0f );
2468                                                          if( ( z & 0x01 ) != 0x01 )
2469                                                                  z = 0;                                          
2470                                                          else if( ( z & 0x01 ) == 0x01 )
2471                                                                  z = 1;
2472                                                          else if( ( z & 0x02 ) == 0x02 )
2473                                                                  z = 2;
2474                                                          else if( ( z & 0x04 ) == 0x04 )
2475                                                                  z = 3;
2476                                                          else if( ( z & 0x08) == 0x08 )
2477                                                          {
2478                                                                  z = 4;
2479                                                                  if( ( z & 0x08) == 0x08 )
2480                                                                          GoodsWaySetVal[i].WayState &= 0xf0;
2481                                                          }
2482                                  * /
2483                                  if( GoodsWaySetVal[i].WayState == 0 )
2484                                                          {
2485                                                              //未
2486                                                              z = 0;
2487                                                          }
2488                                                          else if( GoodsWaySetVal[i].WayState & 0x0A )
2489                                                          {
2490                                                              //故
2491                                                              z = 2;
2492                                                          }
2493                                                          else if( (GoodsWaySetVal[i].WayState & 0x04) || (GoodsWaySetVal[i].GoodsCurrentSum == 0) )
2494                                                          {
2495                                                              //缺
2496                                                              z = 3;
2497                                                          }
2498                                                          else
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 42  

2499                                                          {
2500                                                              //正
2501                                                              z = 1;
2502                                                          }
2503                                                  #ifdef _CHINA_
2504                                                          memcpy( line2 + 4*(j - 5 ) + 2, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
2505                                                  #else
2506                                                          memcpy( line2 + 5*(j - 4 ) + 3, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
2507                                                  #endif
2508                                                          j += 1;
2509                                                  }
2510                                                  else
2511                                                          break;
2512                                          }                               
2513                                  }       
2514                                  if( ( strlen( line1 ) == 0 ) && ( strlen(line2) == 0 ) )
2515                                          return;         
2516                          #ifdef _CHINA_
2517                                  DisplayStr( 0, 0, 1, line1, 20 );
2518                                  DisplayStr( 0, 1, 1, line2,( j - 5 )*4 );               
2519                          #else
2520                                  DisplayStr( 0, 0, 1, line1, 20 );
2521                                  DisplayStr( 0, 1, 1, line2,( j - 4 )*5 );               
2522                          #endif                  
2523                                  DisplayCursorState( 0, LineNum-1, 1, 2, 1 );
2524                                  DispFlag = 0;
2525                          }
2526                          key = GetKey();
2527                          switch( key )           
2528                          {
2529                                  case KEY_UP://上移      
2530                                       if( LineNum == 2 )//选中标记上移
2531                                       {                       
2532                                          DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
2533                                          LineNum = 1;                                    
2534                                       }
2535                                       else//菜单上翻
2536                                       {          
2537                                                  if( Start <= 0 )
2538                                                          break;                                  
2539                                                  else
2540                                                  {
2541                                                  #ifdef _CHINA_
2542                                                          Start = Start -5;                                       
2543                                                          End = End - 5;  
2544                                                  #else
2545                                                          Start = Start -4;                                       
2546                                                          End = End - 4;  
2547                                                  #endif                                  
2548                                                          DispFlag = 1;                                           
2549                                                          LineNum = 1;                                            
2550                                                  }
2551                                       }
2552                                           break;
2553                                  case KEY_DOWN://下移                            
2554                                          if( LineNum == 1 )//选中标记下移
2555                                          {                                
2556                                               DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标                                 
2557                                               LineNum = 2;                                    
2558                                           }
2559                                           else//菜单下翻
2560                                           {      
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 43  

2561                                          if( End >= SumColunm )
2562                                                          break;
2563                                                  else
2564                                                  {
2565                                                  #ifdef _CHINA_
2566                                                          Start = Start + 5;                                      
2567                                                          End = End + 5;  
2568                                                  #else
2569                                                          Start = Start + 4;                                      
2570                                                          End = End + 4;  
2571                                                  #endif                                  
2572                                                          DispFlag = 1;                           
2573                                                          LineNum = 2;                                    
2574                                                  }
2575                                          }
2576                                          break;
2577                                  case KEY_CANCEL:
2578                                          return;
2579                                          break;                                  
2580                          }
2581                          CoreProcessCycle();//让出时间片
2582                          DelayMs( 10 );
2583                  }               
2584                  /////////////////////
2585          }
2586          */
2587          //显示故障货道
2588          void DispFaultGoodsWays()
2589                  
2590          {
2591   1              u_char xdata line1[21];
2592   1              u_char xdata line2[21];
2593   1              u_char xdata i = 0;
2594   1              u_char xdata j = 0;
2595   1              u_char xdata z = 0;
2596   1      #ifdef _CHINA_
2597   1              u_char xdata Start = 0;
2598   1              u_char xdata End = 10;
2599   1      #else
                      u_char xdata Start = 0;
                      u_char xdata End = 8;
              #endif                                  
2603   1              u_char xdata LineNum = 2;  //选中行在屏幕中的行号               
2604   1              u_char xdata key;
2605   1              u_char xdata  DispFlag = 1;
2606   1              u_char xdata SumColunm = 0;
2607   1              u_char xdata ucBadWayNum = 0;//故障货道数量
2608   1              u_char xdata str[20];
2609   1              u_char xdata len = 0;
2610   1      
2611   1              //memset(&WayCheck, 0x00, sizeof(struct COLUMNTEST));//避免清空货道99检测的信息by gzz 20111028
2612   1              for( i = 0; i < GOODSWAYNUM; i ++ )
2613   1              {
2614   2                 //货道状态查询中，显示故障货道次数出错;by gzz 20120323
2615   2                 if(( GoodsWaySetVal[i].WayNo != 0 )&&( GoodsWaySetVal[i].WayState & 0x0A ))
2616   2                 {
2617   3                              //只放故障货道
2618   3                         //WayCheck.WayNo[ucBadWayNum] = InputGoodsWayList[i].GoodsWayNo;//避免清空货道99检测的信息by gzz 2011
             -1028
2619   3                              ucBadWayNum++;                  
2620   3                 }
2621   2              }       
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 44  

2622   1              memset( str, 0, sizeof( str ) );        
2623   1              if(ucBadWayNum == 0)
2624   1              {
2625   2                      len = sprintf( str, "无故障货道");
2626   2              }
2627   1              else
2628   1              {
2629   2                      len = sprintf( str, "故障货道%02bu个", ucBadWayNum );
2630   2              }
2631   1              DisplayStr( 0, 0, 1, str, len );
2632   1              ClearDisplayLine( 2 );  
2633   1              WaitForWork( 3000,NULL );
2634   1      
2635   1              key = KEY_NULL;         
2636   1              ClearKey();
2637   1              DisplayCursorState( 0, 1, 1, 2, 1 );//设置当在第二行上且为整行光标状态
2638   1              LineNum = 2;
2639   1              for( i = 0; i < GOODSWAYNUM; i ++ )
2640   1              {
2641   2                      if( InputGoodsWayList[i].GoodsWayNo != 0 )
2642   2                              SumColunm++;
2643   2                      else
2644   2                              break;
2645   2              }
2646   1      
2647   1              while( 1 )        //超时或客户退出
2648   1              {
2649   2                      if( DispFlag )
2650   2                      {
2651   3                              memset( line1, 0, sizeof( line1 ) );    
2652   3                              memset( line2, 0, sizeof( line2 ) );    
2653   3                              j = 0;
2654   3                              i = 0;                  
2655   3                              for( i = Start; i < End; i++ )
2656   3                              {       
2657   4                      #ifdef _CHINA_
2658   4                                      if( i < ( Start + 5 ) )
2659   4                      #else
                                              if( i < ( Start + 4 ) )
                              #endif                          
2662   4                                      {
2663   5                                              if(InputGoodsWayList[i].GoodsWayNo == 0)//修改货道状态查询;by gzz 20120323
2664   5                                                      continue;
2665   5                              #ifdef _CHINA_
2666   5                                              sprintf( line1 + 4*j, "%02bu ", InputGoodsWayList[i].GoodsWayNo );
2667   5                              #else
                                                      sprintf( line1 + 5*j, "%02bu ", InputGoodsWayList[i].GoodsWayNo );
                                  #endif
2670   5                                              z = 0;
2671   5                                              //注释掉原来货道状态判断函数;by gzz 20110309
2672   5                                              /*
2673   5                                              if( GoodsWaySetVal[i].GoodsCurrentSum == 0 )
2674   5                                                      z = 3;
2675   5                                              z = ( GoodsWaySetVal[i].WayState & 0x0f );
2676   5                                              if( ( z & 0x01 ) != 0x01 )                                              
2677   5                                                      z = 0;                                  
2678   5                                              else if( ( z & 0x01 ) == 0x01 )
2679   5                                                      z = 1;
2680   5                                              else if( ( z & 0x02 ) == 0x02 )
2681   5                                                      z = 2;
2682   5                                              else if( ( z & 0x04 ) == 0x04 )
2683   5                                                      z = 3;  
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 45  

2684   5                                              else if( ( z & 0x08 ) == 0x08 )
2685   5                                              {
2686   5                                                      if( ( z & 0x08) == 0x08 )
2687   5                                                              GoodsWaySetVal[i].WayState &= 0xf0;
2688   5                                                      z = 4;
2689   5                                              }
2690   5                                              */
2691   5                                              //添加新货道状态判断函数;by gzz 20110309
2692   5                                              if(( GoodsWaySetVal[i].WayState & 0x01 )!= 0x01)
2693   5                                              {
2694   6                                                      //未
2695   6                                                      z = 0;
2696   6                                              }
2697   5                                              else if( GoodsWaySetVal[i].WayState & 0x0A )
2698   5                                              {
2699   6                                                      //故
2700   6                                                      z = 2;
2701   6                                              }
2702   5                                              else if( (GoodsWaySetVal[i].WayState & 0x04) || (GoodsWaySetVal[i].GoodsCurrentSum == 0) )
2703   5                                              {
2704   6                                                      //缺
2705   6                                                      z = 3;
2706   6                                              }
2707   5                                              else
2708   5                                              {
2709   6                                                      //正
2710   6                                                      z = 1;
2711   6                                              }
2712   5                              #ifdef _CHINA_
2713   5                                              memcpy( line1 + 4*j + 2, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
2714   5                              #else
                                                      memcpy( line1 + 5*j + 3, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
                                      #endif                                  
2717   5                                      //      Trace("\n GoodsWaySetVal[i].WayNo = %02bu", GoodsWaySetVal[i].WayNo );          
2718   5                                      //      Trace("\n GoodsWaySetVal[i].WayState = %bu", GoodsWaySetVal[i].WayState );              
2719   5                                      //      Trace("\n line1 = %s", line1 );         
2720   5                                              j++;
2721   5                                      }
2722   4                                      else
2723   4                                      {                                       
2724   5                                              if( i < SumColunm )
2725   5                                              {                                       
2726   6                                                      if( InputGoodsWayList[i].GoodsWayNo == 0)//修改货道状态查询;by gzz 20120323
2727   6                                                              continue;
2728   6                                      #ifdef _CHINA_
2729   6                                                      sprintf( line2 + 4*(j - 5 ), "%02bu ", InputGoodsWayList[i].GoodsWayNo );
2730   6                                      #else
                                                              sprintf( line2 + 5*(j - 4 ), "%02bu ", InputGoodsWayList[i].GoodsWayNo );
                                      #endif                                          
2733   6                                                      z = 0;
2734   6                                                      //注释掉原来货道状态判断函数;by gzz 20110309
2735   6                                                      /*
2736   6                                                      if( GoodsWaySetVal[i].GoodsCurrentSum == 0 )
2737   6                                                              z = 3;
2738   6                                                      z = ( GoodsWaySetVal[i].WayState & 0x0f );
2739   6                                                      if( ( z & 0x01 ) != 0x01 )
2740   6                                                              z = 0;                                          
2741   6                                                      else if( ( z & 0x01 ) == 0x01 )
2742   6                                                              z = 1;
2743   6                                                      else if( ( z & 0x02 ) == 0x02 )
2744   6                                                              z = 2;
2745   6                                                      else if( ( z & 0x04 ) == 0x04 )
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 46  

2746   6                                                              z = 3;
2747   6                                                      else if( ( z & 0x08) == 0x08 )
2748   6                                                      {
2749   6                                                              z = 4;
2750   6                                                              if( ( z & 0x08) == 0x08 )
2751   6                                                                      GoodsWaySetVal[i].WayState &= 0xf0;
2752   6                                                      }
2753   6                                                      */
2754   6                                                      //添加新货道状态判断函数;by gzz 20110309
2755   6                                                      if(( GoodsWaySetVal[i].WayState & 0x01 )!= 0x01)
2756   6                                                      {
2757   7                                                              //未
2758   7                                                              z = 0;
2759   7                                                      }
2760   6                                                      else if( GoodsWaySetVal[i].WayState & 0x0A )
2761   6                                                      {
2762   7                                                              //故
2763   7                                                              z = 2;
2764   7                                                      }
2765   6                                                      else if( (GoodsWaySetVal[i].WayState & 0x04) || (GoodsWaySetVal[i].GoodsCurrentSum == 0) )
2766   6                                                      {
2767   7                                                              //缺
2768   7                                                              z = 3;
2769   7                                                      }
2770   6                                                      else
2771   6                                                      {
2772   7                                                              //正
2773   7                                                              z = 1;
2774   7                                                      }
2775   6                                      #ifdef _CHINA_
2776   6                                                      memcpy( line2 + 4*(j - 5 ) + 2, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
2777   6                                      #else
                                                              memcpy( line2 + 5*(j - 4 ) + 3, GoodsWaysStatusStr[ z ].str, GoodsWaysStatusStr[ z ].len );
                                              #endif
2780   6                                                      j += 1;
2781   6                                              }
2782   5                                              else
2783   5                                                      break;
2784   5                                      }                               
2785   4                              }       
2786   3                              if( ( strlen( line1 ) == 0 ) && ( strlen(line2) == 0 ) )
2787   3                                      return;         
2788   3              #ifdef _CHINA_
2789   3                              DisplayStr( 0, 0, 1, line1, 20 );
2790   3                              DisplayStr( 0, 1, 1, line2,( j - 5 )*4 );               
2791   3              #else
                                      DisplayStr( 0, 0, 1, line1, 20 );
                                      DisplayStr( 0, 1, 1, line2,( j - 4 )*5 );               
                      #endif                  
2795   3                              DisplayCursorState( 0, LineNum-1, 1, 2, 1 );
2796   3                              DispFlag = 0;
2797   3                      }
2798   2                      key = GetKey();
2799   2                      switch( key )           
2800   2                      {
2801   3                              case KEY_UP://上移              
2802   3                                       if( LineNum == 2 )//选中标记上移
2803   3                                       {                               
2804   4                                              DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
2805   4                                              LineNum = 1;                                    
2806   4                                       }
2807   3                                       else//菜单上翻
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 47  

2808   3                                       {              
2809   4                                              if( Start <= 0 )
2810   4                                                      break;                                  
2811   4                                              else
2812   4                                              {
2813   5                                      #ifdef _CHINA_
2814   5                                                      Start = Start -5;                                       
2815   5                                                      End = End - 5;  
2816   5                                      #else
                                                              Start = Start -4;                                       
                                                              End = End - 4;  
                                              #endif                                  
2820   5                                                      DispFlag = 1;                                           
2821   5                                                      LineNum = 1;                                            
2822   5                                              }
2823   4                                       }
2824   3                                       break;
2825   3                              case KEY_DOWN://下移                            
2826   3                                      if( LineNum == 1 )//选中标记下移
2827   3                                      {                                
2828   4                                               DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标                             
2829   4                                               LineNum = 2;                                    
2830   4                                       }
2831   3                                       else//菜单下翻
2832   3                                       {      
2833   4                                              if( End >= SumColunm )
2834   4                                                      break;
2835   4                                              else
2836   4                                              {
2837   5                                      #ifdef _CHINA_
2838   5                                                      Start = Start + 5;                                      
2839   5                                                      End = End + 5;  
2840   5                                      #else
                                                              Start = Start + 4;                                      
                                                              End = End + 4;  
                                              #endif                                  
2844   5                                                      DispFlag = 1;                           
2845   5                                                      LineNum = 2;                                    
2846   5                                              }
2847   4                                      }
2848   3                                      break;
2849   3                              case KEY_CANCEL:
2850   3                                      return;
2851   3                                      break;                                  
2852   3                      }
2853   2                      CoreProcessCycle();//让出时间片
2854   2                      DelayMs( 10 );
2855   2                      if(sysVPMission.msActTimer == 0)
2856   2                      {
2857   3                              sysVPMission.msActTimer = 100;
2858   3                              VPMission_Act_RPT(VP_ACT_ADMIN,VP_ACT_ENTERADMIN);
2859   3                      }
2860   2              }               
2861   1              /////////////////////
2862   1      }
2863          
2864          
2865          /*
2866          {               
2867                  u_char xdata i = 0;
2868                  u_char xdata j = 0;
2869                  u_char xdata z = 0;
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 48  

2870                                                  
2871                  u_char  xdata LineNum = 2;  //选中行在屏幕中的行号              
2872                  u_char  xdata key;
2873                  u_char xdata  DispFlag = 1;
2874                  u_char xdata SumColunm = 0;
2875                  u_char xdata m_Index = 0;
2876              u_char xdata str[20];
2877                  u_char xdata len = 0;
2878          
2879                  u_char xdata ucIsBadWay = 0;//货道是否故障
2880                  u_char xdata ucBadWayNum = 0;//故障货道数量
2881          
2882                  memset(&WayCheck, 0x00, sizeof(struct COLUMNTEST));
2883                  for( m_Index = 0; m_Index < GOODSWAYNUM; m_Index ++ )
2884              {
2885                 if( GoodsWaySetVal[m_Index].WayState & 0x0A )
2886                     {
2887                                  //只放故障货道
2888                         WayCheck.WayNo[ucBadWayNum] = InputGoodsWayList[m_Index].GoodsWayNo;
2889                                  ucBadWayNum++;
2890                                  if(ucBadWayNum%7 == 0) SumColunm++;
2891                     }
2892              }   
2893                  SumColunm++;
2894                  memset( str, 0, sizeof( str ) );
2895                  if(ucBadWayNum == 0)
2896                  {
2897                          len = sprintf( str, "无故障货道");
2898                          DisplayStr( 0, 0, 1, str, len );
2899                          ClearDisplayLine( 2 );          
2900                          WaitForWork( 3000,NULL );               
2901                          ClearKey();
2902                          return;
2903          
2904                  }
2905                  
2906                  len = sprintf( str, "故障货道%02bu个", ucBadWayNum );
2907                  DisplayStr( 0, 0, 1, str, len );
2908                  ClearDisplayLine( 2 );  
2909          
2910                  key = KEY_NULL;         
2911                  ClearKey();
2912                  DisplayCursorState( 0, 1, 1, 2, 1 );//设置当在第二行上且为整行光标状态
2913                  LineNum = 2;
2914                  WaitForWork( 3000,NULL );
2915              i = 0;
2916              ClearKey();
2917          
2918                  if( DispFlag  )
2919                  {
2920                          #ifdef _CHINA_              
2921                              memset( str, 0, sizeof( str ) );
2922                                  //len = sprintf( str, "货道%02bu故障", WayCheck.WayNo[i]);
2923                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0], WayCheck.WayNo[
             -i*7+1], WayCheck.WayNo[i*7+2], WayCheck.WayNo[i*7+3], WayCheck.WayNo[i*7+4], WayCheck.WayNo[i*7+5], WayCheck.WayNo[i*7+6
             -]);
2924                          DisplayStr( 0, 0, 1, str, len );                    
2925                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0+7], WayCheck.WayN
             -o[i*7+1+7], WayCheck.WayNo[i*7+2+7], WayCheck.WayNo[i*7+3+7], WayCheck.WayNo[i*7+4+7], WayCheck.WayNo[i*7+5+7], WayCheck
             -.WayNo[i*7+6+7]);
2926                          DisplayStr( 0, 1, 1, str, len );                                        
2927                          #else   
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 49  

2928                          memset( str, 0, sizeof( str ) );
2929                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0], WayCheck.WayNo[
             -i*7+1], WayCheck.WayNo[i*7+2], WayCheck.WayNo[i*7+3], WayCheck.WayNo[i*7+4], WayCheck.WayNo[i*7+5], WayCheck.WayNo[i*7+6
             -]);
2930                                  DisplayStr( 0, 0, 1, str, len );                        
2931                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0+7], WayCheck.WayN
             -o[i*7+1+7], WayCheck.WayNo[i*7+2+7], WayCheck.WayNo[i*7+3+7], WayCheck.WayNo[i*7+4+7], WayCheck.WayNo[i*7+5+7], WayCheck
             -.WayNo[i*7+6+7]);
2932                                  DisplayStr( 0, 1, 1, str, len );                                        
2933                          #endif                  
2934                                  DisplayCursorState( 0, LineNum-1, 1, 2, 1 );
2935                                  DispFlag = 0;
2936              }
2937              ClearKey();
2938                  
2939          
2940                  while( 1 )    //超时或客户退出
2941                  {        
2942                          key = GetKey();
2943                          //if( key == KEY_NULL ) continue;
2944                          switch( key )           
2945                          {
2946                      case KEY_UP://上移                          
2947                                       if( LineNum == 2 )//选中标记上移
2948                                       {                       
2949                                          DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
2950                                          LineNum = 1;
2951                                                  if (i>1) i--;
2952                                       }
2953                                       else   //菜单上翻
2954                                       {          
2955                                                  if( i == 0 )
2956                                                  {
2957                                                          break;
2958                                                  }
2959                                                  else
2960                                                  {                       
2961                                                      i--;
2962                                                  #ifdef _CHINA_     
2963                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0], WayCheck.WayN
             -o[i*7+1], WayCheck.WayNo[i*7+2], WayCheck.WayNo[i*7+3], WayCheck.WayNo[i*7+4], WayCheck.WayNo[i*7+5], WayCheck.WayNo[i*7
             -+6]);
2964                                                  DisplayStr( 0, 0, 1, str, len );
2965                                                      
2966                                                          //如果下一行超出货道直，就不能显示了
2967                                                          if( (i+1) >= SumColunm )                                                        
2968                                  {
2969                                     ClearDisplayLine( 2 );
2970                                  }
2971                                  else
2972                                  {
2973                                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0+7], WayCheck.
             -WayNo[i*7+1+7], WayCheck.WayNo[i*7+2+7], WayCheck.WayNo[i*7+3+7], WayCheck.WayNo[i*7+4+7], WayCheck.WayNo[i*7+5+7], WayC
             -heck.WayNo[i*7+6+7]);
2974                                                                  DisplayStr( 0, 1, 1, str, len );        
2975                                                          }
2976                                                  #else
2977                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0], WayCheck.WayN
             -o[i*7+1], WayCheck.WayNo[i*7+2], WayCheck.WayNo[i*7+3], WayCheck.WayNo[i*7+4], WayCheck.WayNo[i*7+5], WayCheck.WayNo[i*7
             -+6]);
2978                                                          DisplayStr( 0, 0, 1, str, len );
2979                                                      
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 50  

2980                                                          //如果下一行超出货道直，就不能显示了
2981                                                          if( (i+1) >= SumColunm )
2982                                  {
2983                                     ClearDisplayLine( 2 );
2984                                  }
2985                                  else
2986                                  {
2987                                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0+7], WayCheck.
             -WayNo[i*7+1+7], WayCheck.WayNo[i*7+2+7], WayCheck.WayNo[i*7+3+7], WayCheck.WayNo[i*7+4+7], WayCheck.WayNo[i*7+5+7], WayC
             -heck.WayNo[i*7+6+7]);
2988                                                                  DisplayStr( 0, 1, 1, str, len );                                                
2989                                                          }
2990                                                  #endif                                  
2991                                                          //DispFlag = 1;
2992                                                          DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
2993                                                          LineNum = 1;                                            
2994                                                  }
2995                                       }
2996                                           break;
2997                                  case KEY_DOWN://下移
2998                          if( i >= SumColunm ) break;//如果i的直超出货道直，则不能再递增了
2999                                      i++;                                
3000                                          if( LineNum == 1 )//选中标记下移
3001                                          {                                
3002                                               DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标                                 
3003                                               LineNum = 2;                                    
3004                                           }
3005                                           else//菜单下翻
3006                                           {      
3007                                                  if( i >= SumColunm ) break;//如果i的直超出货道直，则不能再递增了
3008                                                  else
3009                                                  {                                       
3010                                                  #ifdef _CHINA_     
3011                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0], WayCheck.WayN
             -o[i*7+1], WayCheck.WayNo[i*7+2], WayCheck.WayNo[i*7+3], WayCheck.WayNo[i*7+4], WayCheck.WayNo[i*7+5], WayCheck.WayNo[i*7
             -+6]);
3012                                                          DisplayStr( 0, 0, 1, str, len );
3013                                                      
3014                                                          //如果下一行超出货道直，就不能显示了
3015                                                          if( (i+1) >= SumColunm )
3016                                  {
3017                                     ClearDisplayLine( 2 );
3018                                  }
3019                                  else
3020                                  {
3021                                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0+7], WayCheck.
             -WayNo[i*7+1+7], WayCheck.WayNo[i*7+2+7], WayCheck.WayNo[i*7+3+7], WayCheck.WayNo[i*7+4+7], WayCheck.WayNo[i*7+5+7], WayC
             -heck.WayNo[i*7+6+7]);
3022                                                             DisplayStr( 0, 1, 1, str, len );
3023                                  }
3024                                                                  
3025                                                  #else
3026                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0], WayCheck.WayN
             -o[i*7+1], WayCheck.WayNo[i*7+2], WayCheck.WayNo[i*7+3], WayCheck.WayNo[i*7+4], WayCheck.WayNo[i*7+5], WayCheck.WayNo[i*7
             -+6]);
3027                                                          DisplayStr( 0, 0, 1, str, len );
3028                                                      
3029                                                          if( (i+1) >= SumColunm )
3030                                  {
3031                                     ClearDisplayLine( 2 );
3032                                  }
3033                                  else
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 51  

3034                                  {
3035                                                                  len = sprintf( str, "%02bu %02bu %02bu %02bu %02bu %02bu %02bu", WayCheck.WayNo[i*7+0+7], WayCheck.
             -WayNo[i*7+1+7], WayCheck.WayNo[i*7+2+7], WayCheck.WayNo[i*7+3+7], WayCheck.WayNo[i*7+4+7], WayCheck.WayNo[i*7+5+7], WayC
             -heck.WayNo[i*7+6+7]);
3036                                                             DisplayStr( 0, 1, 1, str, len );
3037                                                          }
3038                          
3039                                                  #endif                                          
3040                                                          //DispFlag = 1; 
3041                                                          DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标      
3042                                                          LineNum = 2;                                    
3043                                                  }
3044                                          }
3045                                          break;
3046                               case KEY_CANCEL:
3047                                          return;
3048                                          break;                                  
3049                          }
3050                  ClearKey();     
3051                          CoreProcessCycle(); //让出时间片
3052                          DelayMs( 10 );
3053                          //WaitForWork( 50, NULL );
3054                  }       
3055          }
3056          */
3057          
3058          
3059          //测试和显示手机模块状态
3060          void TestAndDispMobileStates( u_char type, u_char DispLine )
3061          {       
3062   1              type = 0;
3063   1          DispLine = 0;
3064   1      }
3065          
3066          void ErrShow()
3067          {
3068   1              //u_int xdata  CurrentMoney = 0;
3069   1      
3070   1              hardWareErrShow[0]=0;
3071   1              hardWareErrShow[1]=0;
3072   1              
3073   1              hardWareErrShow[1]=sysVPMission.hardWareErrShow;
3074   1              if(sysVPMission.hardWareErrShow==0x02)
3075   1                      hardWareErrShow[0]=0x70;
3076   1              //本次出货确认板的工作状态;by gzz 20111028 
3077   1          if( SystemParameter.GOCOn == 1 )
3078   1          {
3079   2              if( DeviceStatus.GOCStatus == 0 )
3080   2              {
3081   3                      hardWareErrShow[0]=0x00;
3082   3                      hardWareErrShow[1]=0xfc;
3083   3              }       
3084   2          }
3085   1              //纸币器故障
3086   1              //具体故障情况
3087   1              //钞箱已满                                                      
3088   1              if(sysMDBMission.billIsFull == 1)
3089   1              {
3090   2                      hardWareErrShow[0] = 0x60;
3091   2                      hardWareErrShow[1] = 0x08;
3092   2              }
3093   1              //钞箱移除报故障
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 52  

3094   1              if(sysMDBMission.billCashBuf == 1)//钞箱移除报故障;by gzz 20121224
3095   1          {           
3096   2                      {
3097   3                              hardWareErrShow[0] = 0x60;
3098   3                              hardWareErrShow[1] = 0x07;
3099   3                      }
3100   2              }
3101   1              //电机异常
3102   1              if(sysMDBMission.billOthErr & 0x01)
3103   1              {
3104   2                      hardWareErrShow[0] = 0x60;
3105   2                      hardWareErrShow[1] = 0x03;
3106   2              }
3107   1              //传感器异常
3108   1              if(sysMDBMission.billOthErr & 0x02)
3109   1              {
3110   2                      hardWareErrShow[0] = 0x60;
3111   2                      hardWareErrShow[1] = 0x04;
3112   2              }
3113   1              //卡币
3114   1              if(sysMDBMission.billOthErr & 0x08)
3115   1              {
3116   2                      hardWareErrShow[0] = 0x60;
3117   2                      hardWareErrShow[1] = 0x06;
3118   2              }
3119   1              
3120   1              //sysVPMission.send.msg[i++] = sysMDBMission.billOthErr;
3121   1      
3122   1              
3123   1              //硬币器故障
3124   1              /*
3125   1              if( ( HardWareErr & 0x0002 )||( sysVPMission.STA_CoinA == 2 ) )
3126   1              {
3127   1                      //errcode = 0xF2;
3128   1                      //sprintf( errCodeStr, "%s", "硬币器故障" );                    
3129   1                      //sprintf( errCodeStr, "%s", "  请用其它方式购物" );
3130   1      
3131   1                      //sprintf( sysVPMission.hardWareErrStr, "%s", "硬币器故障");
3132   1                      sysVPMission.send.msg[i++] = 0x00;
3133   1                      sysVPMission.send.msg[i++] = 0xF2;
3134   1                      //sysVPMission.send.msg[i++] = 0x00;
3135   1                      //sysVPMission.send.msg[i++] = 0xF3;
3136   1              }
3137   1              */
3138   1              //硬币器故障
3139   1              //具体故障情况
3140   1              //添加币管没有锁紧故障;by gzz 20110827
3141   1              if( sysMDBMission.tubeRemoved == 1 )
3142   1              {
3143   2                  //errcode = 0xF0;//币管没有锁紧故障
3144   2                      //sprintf( errCodeStr, "%s", "币管未关闭" );                    
3145   2                      //sprintf( errCodeStr, "%s", "  请用其它方式购物" );
3146   2      
3147   2                      //sprintf( sysVPMission.hardWareErrStr, "%s", "币管未关闭" );
3148   2                      hardWareErrShow[0] = 0x50;
3149   2                      hardWareErrShow[1] = 0x04;
3150   2              }
3151   1              //传感器异常
3152   1              if(sysMDBMission.coinOthErr & 0x01)
3153   1              {
3154   2                      hardWareErrShow[0] = 0x50;
3155   2                      hardWareErrShow[1] = 0x03;
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 53  

3156   2              }
3157   1              //出币卡币
3158   1              if(sysMDBMission.coinOthErr & 0x02)
3159   1              {
3160   2                      hardWareErrShow[0] = 0x50;
3161   2                      hardWareErrShow[1] = 0x05;
3162   2              }
3163   1              //进币通道出错
3164   1              if(sysMDBMission.coinOthErr & 0x08)
3165   1              {
3166   2                      hardWareErrShow[0] = 0x50;
3167   2                      hardWareErrShow[1] = 0x07;
3168   2              }
3169   1              //投币卡币
3170   1              if(sysMDBMission.coinOthErr & 0x10)
3171   1              {
3172   2                      hardWareErrShow[0] = 0x50;
3173   2                      hardWareErrShow[1] = 0x08;
3174   2              }        
3175   1      }
3176          
3177          void DealStatusQuery()
3178          {
3179   1              u_char xdata len = 0;   
3180   1          //u_char xdata StatusBuf[10];
3181   1              u_char xdata Buffer[20];
3182   1              u_char xdata key = 0;
3183   1              u_char xdata MyKey = 0;
3184   1          /*
3185   1              //无故障时，直接提示运行正常;by gzz 20111028
3186   1              if(sysVPMission.hardWareErrShow==0)
3187   1              sprintf( StatusBuf, "%s", "运行\xd5\xfd常" );
3188   1                      //DisplayStr( 0, 0 , 1 , "      运行\xd5\xfd常", 14 );
3189   1              else
3190   1              sprintf( StatusBuf, "%s", "故障代码" );
3191   1                      //DisplayStr( 0, 0 , 1 , "      故障代码", 14 );
3192   1          */
3193   1          ErrShow();
3194   1              len = sprintf( Buffer, "[%02bx%02bx]" , hardWareErrShow[0],hardWareErrShow[1] );        
3195   1                      
3196   1              //Trace( "\n LEN = %bu", len );
3197   1              DisplayStr( 0, 0 , 1, Buffer, len );
3198   1          WaitForWork( 100, NULL );
3199   1              
3200   1              //本次出货确认板的工作状态;by gzz 20111028 
3201   1          if( SystemParameter.GOCOn == 1 )
3202   1          {
3203   2              if( DeviceStatus.GOCStatus == 0 )
3204   2              {
3205   3                      len = sprintf( Buffer, "出货确认板开启");
3206   3              }
3207   2              else
3208   2              {
3209   3                      len = sprintf( Buffer, "出货确认板故障关闭");
3210   3              }
3211   2          }
3212   1          else
3213   1              {
3214   2                      len = sprintf( Buffer, "出货确认板未开启");
3215   2              }
3216   1              DisplayStr( 0, 1 , 1, Buffer, len );
3217   1              WaitForWork( 100, NULL );
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 54  

3218   1              
3219   1          while( 1 )
3220   1              {
3221   2              MyKey = GetKey();               
3222   2                      if( ( MyKey  == KEY_SUBMIT ) || ( MyKey  == KEY_CANCEL ) )
3223   2              {
3224   3                              break;
3225   3              }
3226   2                      WaitForWork( 100, NULL );
3227   2          }   
3228   1      }
3229          
3230          void DeviceCheck()
3231          {
3232   1          //菜单显示数组   
3233   1              unsigned char  xdata firstNum; //一级菜单编号   
3234   1              unsigned char  xdata LineNum;  //选中行在屏幕中的行号           
3235   1              unsigned char  xdata key;
3236   1              u_char   xdata status;
3237   1              bit     data Notout;
3238   1              unsigned char xdata line[20];
3239   1      
3240   1              memset(line , 0 , sizeof( line ));
3241   1              key = KEY_NULL;
3242   1              status = 0;
3243   1              firstNum = 1;
3244   1              LineNum = 2;    
3245   1              Notout = 1;
3246   1      
3247   1              ClearKey();
3248   1              /*菜单初始化显示（第1，2行）*/          
3249   1      //      DisplayStr( 0, 0, 1, WMenuStr[0].str, WMenuStr[0].len );                
3250   1      //#ifndef _HAVE_CASHER
3251   1              m_iCheckDevice = 0;
3252   1              /*
3253   1              if( SystemParameter.BillNo != 1 )
3254   1      //              GetDeviceStatus( 0 );   
3255   1      //      else
3256   1                      DeviceStatus.BillAccepter = 128;
3257   1      //      GetDeviceStatus( 1 );   
3258   1      //#endif
3259   1          //测试一下各找零器的状态值;by gzz 20110430
3260   1          //GetDeviceStatus(2);
3261   1          //GetDeviceStatus(3);
3262   1          //GetDeviceStatus(4);
3263   1          */
3264   1         
3265   1              //DispDeviceStatus( 0, 0, 0 );  
3266   1              //DispDeviceStatus( 1, 1, 0 );
3267   1              DispDeviceMenu( 0, 0);
3268   1              DispDeviceMenu( 1, 1);
3269   1              DisplayCursorState( 0, 1, 1, 2, 1 );//设置当在第二行上且为整行光标状态
3270   1              //Trace( "in Menu select begin\n" );            
3271   1              m_iCheckDevice = 1;
3272   1              while( Notout )    //超时或客户退出
3273   1              {                               
3274   2                      key = GetKey();
3275   2                      switch( key )           
3276   2                      {
3277   3                              case KEY_UP://上移      
3278   3                                   if( LineNum == 2 )//选中标记上移
3279   3                                   {                       
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 55  

3280   4                                      DisplayCursorState( 0, 0, 1, 2, 1 );//第一行整光标
3281   4                                      LineNum = 1;                       
3282   4                                              if( firstNum == 0 )
3283   4                                                      firstNum = MENU_COUNT(WMenuStr)-1;                                      
3284   4                                              else
3285   4                                                      firstNum--;
3286   4                                   }
3287   3                                   else//菜单上翻
3288   3                                   {
3289   4                                      /*当firstNum<=1不能上翻了*/                             
3290   4                                              DispDeviceMenu( firstNum, 1);                                                                       
3291   4                                              if( firstNum == 0 )
3292   4                                                      firstNum = MENU_COUNT(WMenuStr)-1;                                      
3293   4                                              else
3294   4                                                      firstNum--;
3295   4                                              DispDeviceMenu( firstNum, 0);                                           
3296   4                                              LineNum = 1;                                    
3297   4                                   }
3298   3                                       break;
3299   3                              case KEY_DOWN://下移                            
3300   3                                      if( LineNum == 1 )//选中标记下移
3301   3                                      {                                
3302   4                                           DisplayCursorState( 0, 1, 1, 2, 1 );//第二行整光标                            
3303   4                                              if( firstNum == MENU_COUNT(WMenuStr)-1 )
3304   4                                                      firstNum = 0;                                   
3305   4                                              else
3306   4                                                      firstNum++;
3307   4                                           LineNum = 2;                                    
3308   4                                       }
3309   3                                       else//菜单下翻
3310   3                                       {
3311   4                                          /*当firstNum<=2不能上翻了*/                                                         
3312   4                                              DispDeviceMenu( firstNum, 0);                                           
3313   4                                      if( firstNum == MENU_COUNT(WMenuStr)-1 )
3314   4                                                      firstNum = 0;                                   
3315   4                                              else
3316   4                                                      firstNum++;
3317   4                                              DispDeviceMenu( firstNum, 1);             
3318   4                                              LineNum = 2;                                    
3319   4                                      }
3320   3                                      break;
3321   3                              case KEY_CANCEL:
3322   3                                      Notout = 0;
3323   3                                      break;
3324   3                              case KEY_SUBMIT://Enter,选中了某项菜单  
3325   3                                      DisplayCursorState( 0, 0, 0, 0, 1 );//第二行整光标
3326   3                                      ClearKey();                             
3327   3                                      switch(firstNum)
3328   3                                      {                       
3329   4                                              case 0:       
3330   4                                                              //在设备管理菜单上，添加一个交易状态查询，可以查询上次交易模式时的故障状态，
3331   4                                      //同时显示故障状态信息
3332   4                                      DealStatusQuery();
3333   4                                                              break;
3334   4                                              case 1:       
3335   4                                                     //货道测试
3336   4                                                         GoodsWayTest();
3337   4                                 VPMission_ColumnSta_RPT();//by gzz 20120223                             
3338   4                                                         break;
3339   4                                              case 2:                                                    
3340   4                                                         //1纸币器状态
3341   4                                                         if( sysITLMission.ITLSet==1 )
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 56  

3342   4                                                         {
3343   5                                              //ITLBillATest();       
3344   5                                                                      MDBBillATest();
3345   5                                              break;
3346   5                                                         }
3347   4                                                         break;
3348   4                                              case 3:                                                    
3349   4                                                         //2硬币器状态//
3350   4                                                     MDBCoinATest();
3351   4                                                         break;
3352   4                                              /*
3353   4                                              case 4:     //#3退币器测试
3354   4                                                      GetDeviceStatus( firstNum );                                            
3355   4                                                      break;  
3356   4                                              case 5: //用AT指令测试主板与手机模块的连接情况                                                                          
3357   4                                              case 6: //发送短信测试
3358   4                                                      //TestAndDispMobileStates( firstNum - 4, LineNum );
3359   4                                              break;
3360   4                                              case 7://货道状态
3361   4                                                      //DispGoodsWaysStates();        
3362   4                                                      break;  
3363   4                                              */      
3364   4                          case 4:  
3365   4                                  //Trace("\n GoodsSetSave1 = %bu", GoodsSetSave );
3366   4                                  //#1退币器测试
3367   4                                                  MDBHopperATest(1);
3368   4                                                      MDB_Coin_TubeSta_API();
3369   4                                                      break;                          
3370   4                                              case 5:       
3371   4                                                      //#2退币器测试
3372   4                                                  MDBHopperATest(2);
3373   4                              MDB_Coin_TubeSta_API();
3374   4                                  //Trace("\n GoodsSetSave1 = %bu", GoodsSetSave );
3375   4                                                      break;                                  
3376   4                                              //case 6:
3377   4                                                  //DispGoodsCheckValue();
3378   4                              //break; 
3379   4                                              case 6:
3380   4                                                  //sysVPMission.VPMode = 1;
3381   4                                                  ButtonTest();
3382   4                              //sysVPMission.VPMode = 0;
3383   4                                                  break;
3384   4                                              case 7:
3385   4                                                  GameButtonTest();
3386   4                                                  break;                                      
3387   4                                              case 8:
3388   4                                                  ReturnButtonTest();
3389   4                                                  break;                              
3390   4                          //case 13:
3391   4                          //    ICCardTest();
3392   4                          //    break;                
3393   4                                              case 9:
3394   4                                                      //GetDeviceStatus( firstNum );
3395   4                                                      //出货确认测试
3396   4                                                      GOCTest();
3397   4                                                      break;                                          
3398   4                                              case 10:       //led test
3399   4                                                  ACDCModuleTest(1);
3400   4                              break; 
3401   4                                              case 11:       //goods show compressor test
3402   4                                                  ACDCModuleTest(2);
3403   4                              break;                                  
CX51 COMPILER V7.50   DEVICECHECK                                                          10/23/2014 09:48:23 PAGE 57  

3404   4                          default:
3405   4                              break;
3406   4                                              
3407   4                                      }
3408   3                                      if(LineNum ==2)
3409   3                                      {       
3410   4                                              if( firstNum == 0 )                                             
3411   4                                                      DispDeviceMenu( MENU_COUNT(WMenuStr)-1, 0);
3412   4                                              else                                            
3413   4                                                      DispDeviceMenu( firstNum - 1, 0);
3414   4                                              DispDeviceMenu( firstNum, 1);                                   
3415   4                                      }
3416   3                                      else
3417   3                                      {                                                                                               
3418   4                                              if( firstNum == ( MENU_COUNT(WMenuStr)-1 ) )
3419   4                                                      DispDeviceMenu( 0, 1);                                  
3420   4                                              else                                            
3421   4                                                      DispDeviceMenu( firstNum + 1, 1);                                       
3422   4                                              DispDeviceMenu( firstNum, 0);
3423   4                                      }                               
3424   3                                      DisplayCursorState( 0, LineNum - 1, 1, 2, 1 );//第二行整光标
3425   3                                      ClearKey();     
3426   3                                      break;
3427   3                      }
3428   2                      CoreProcessCycle();//让出时间片
3429   2                      DelayMs( 10 );
3430   2                      if(sysVPMission.msActTimer == 0)
3431   2                      {
3432   3                              sysVPMission.msActTimer = 100;
3433   3                              VPMission_Act_RPT(VP_ACT_ADMIN,VP_ACT_ENTERADMIN);
3434   3                      }
3435   2              }               
3436   1              m_iCheckDevice = 0;
3437   1      }
3438          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  12340    ----
   CONSTANT SIZE    =   1094    ----
   XDATA SIZE       =      3     561
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


CX51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
