CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 1   


CX51 COMPILER V7.50, COMPILATION OF MODULE COMMONFUNCTION
OBJECT MODULE PLACED IN CommonFunction.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\CX51.EXE CommonFunction.c LARGE OBJECTADVANCED ROM(HUGE) OPTIMIZE(SIZE) BROWSE DEBU
                    -G

line level    source

   1          //#undef _DEBUG_TRACE
   2          #define COMMONFUNCTION_C
   3          #include "debug.h"
   4          #include "device.h"
   5          #include "global.h"
   6          #include "common.h"
   7          #include "CommonFunction.h"
   8          #include "key.h"
   9          #include "STRING.H"
  10          #include "DataExChange.h"
  11          #include "mainflow.h"
  12          #include "timer.h"
  13          #include "SstFlash.h"
  14          #include "procotol.h"
  15          #include "casher.h"
  16          #include "scheduler.h"
  17          #include "IOInput.h"
  18          #include "communication.h"
  19          #include "ITL.h"
  20          #include "VMC_PC.h"
  21          #include "lifterApi.h"
  22          
  23          
  24          /*把时间片让给硬件和通讯模块*/
  25          
  26          struct WayList xdata InputGoodsWayList[ GOODSWAYNUM ] ;
  27          
  28          void CoreProcessCycle()
  29          {
  30   1              SchedulerProcess();
  31   1      #ifndef _DEBUG_NO_MOBILE
                      if( SystemParameter.MobileON == 1 )
                              DoCommunication();
              #endif
  35   1      }
  36          
  37          //Flash初始化
  38          void FlashInit()
  39          {
  40   1              //Flash片选
  41   1              //选中第一片
  42   1              ZhkHardFlashSelect();
  43   1              //整片擦除
  44   1              SstFlashChipErase();
  45   1              ZhkHardSramSelect();
  46   1              //选中第二片
  47   1              ZhkHardFlash1Select();
  48   1              //整片擦除
  49   1              SstFlashChipErase();
  50   1              ZhkHardSramSelect();
  51   1      }
  52          
  53          /*让出时间片实现等待,msec参数为指定等待时间, DeviceID为设备ID编号指针*/
  54          u_char WaitForWork( unsigned long msec, struct DEVICE xdata* DeviceID )
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 2   

  55          {
  56   1              unsigned long loopSec = msec / 1000;
  57   1              unsigned short loopMSec = msec % 1000;
  58   1                      
  59   1              TestDeviceCommOK( DeviceID );
  60   1              // 毫秒级定时
  61   1              LzjMSecTimer = loopMSec & 0x7F;
  62   1              loopMSec /= 128;
  63   1              do
  64   1              {
  65   2                      while(LzjMSecTimer)
  66   2                      {                       
  67   3                              if( DeviceID != NULL )
  68   3                              {
  69   4                                      SchedulerProcess();
  70   4                                      if( TestDeviceCommOK(  DeviceID ) == 0 )
  71   4                                              return 0;
  72   4                              }
  73   3                              else
  74   3                              {               
  75   4                                      if( SystemParameter.MobileON == 1 )
  76   4                                      {
  77   5                                              Mission();
  78   5                                              CoreProcessCycle();                     
  79   5                                      }
  80   4                                      else
  81   4                                              SchedulerProcess();     
  82   4                              }
  83   3                      }
  84   2                      LzjMSecTimer = 128;
  85   2              }while(loopMSec--);
  86   1      
  87   1              // 秒级定时
  88   1              SgpSecTimer = loopSec & 0x7F;
  89   1              loopSec /= 128;
  90   1              do
  91   1              {
  92   2                      while(SgpSecTimer)
  93   2                      {
  94   3                              if( DeviceID != NULL )
  95   3                              {
  96   4                                      SchedulerProcess();
  97   4                                      if( TestDeviceCommOK(  DeviceID ) == 0 )
  98   4                                              return 0;
  99   4                              }
 100   3                              else
 101   3                              {
 102   4                                      if( SystemParameter.MobileON == 1 )
 103   4                                      {
 104   5                                              Mission();
 105   5                                              CoreProcessCycle();                     
 106   5                                      }
 107   4                                      else
 108   4                                              SchedulerProcess();     
 109   4                              }
 110   3                      }
 111   2                      SgpSecTimer = 128;
 112   2              }while(loopSec--);
 113   1      
 114   1              if( DeviceID != NULL )  
 115   1                      return 1;
 116   1              else
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 3   

 117   1                      return 0;
 118   1                              
 119   1      }
 120          
 121          /*********************************************************************************************************
 122          ** Function name:       CrcCheck
 123          ** Descriptions:            CRC校验和
 124          ** input parameters:    msg需要检验的数据;len数据长度
 125          ** output parameters:   无
 126          ** Returned value:      CRC检验结果
 127          *********************************************************************************************************/
 128          u_int CrcCheck(u_char *msg, u_int len) 
 129          {
 130   1          u_int xdata i, j;
 131   1          u_int xdata crc = 0;
 132   1          u_int xdata current = 0;
 133   1          for(i=0;i<len;i++) 
 134   1          {
 135   2              current = msg[i] << 8;
 136   2              for(j=0;j<8;j++) 
 137   2              {
 138   3                  if((int)(crc^current)<0)
 139   3                      crc = (crc<<1)^0x1021;
 140   3                  else 
 141   3                      crc <<= 1; 
 142   3                  current <<= 1; 
 143   3              }
 144   2          }
 145   1          return crc;
 146   1      }
 147          
 148          
 149          //清除键值      
 150          void ClearKey()
 151          {
 152   1          u_char xdata ch = 0;
 153   1      
 154   1          if( sysVPMission.VPMode == 1 )
 155   1          {
 156   2                  //1.
 157   2              if( DeviceStatus.Selection[0] == 0 )
 158   2                      {
 159   3                              ch = GetSelectionState( 1, &Selection1 );
 160   3                          if( ch == 0 )
 161   3                              {
 162   4                                  DeviceStatus.Selection[0] &= 0xfe;
 163   4                              }
 164   3                              else
 165   3                              {
 166   4                                      DeviceStatus.Selection[0] |= 0x01;
 167   4                              }
 168   3                      }
 169   2                      //2.
 170   2              if( DeviceStatus.Selection[1] == 0 )
 171   2                      {
 172   3                              ch = GetSelectionState( 2, &Selection2 );
 173   3                          if( ch == 0 )
 174   3                              {
 175   4                                  DeviceStatus.Selection[1] &= 0xfe;
 176   4                              }
 177   3                              else
 178   3                              {
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 4   

 179   4                                      DeviceStatus.Selection[1] |= 0x01;
 180   4                              }
 181   3                      }
 182   2                      //3.
 183   2                      if( DeviceStatus.Selection[2] == 0 )
 184   2                      {
 185   3                              ch = GetSelectionState( 3, &Selection3 );
 186   3                          if( ch == 0 )
 187   3                              {
 188   4                                  DeviceStatus.Selection[2] &= 0xfe;
 189   4                              }
 190   3                              else
 191   3                              {
 192   4                                      DeviceStatus.Selection[2] |= 0x01;
 193   4                              }
 194   3                      }
 195   2          
 196   2          }
 197   1          else
 198   1          {
 199   2                      KeyLock();
 200   2                      KeyUnLock();
 201   2          }
 202   1      }
 203          
 204          /*显示字符,flag标志指定是以光标当前位置还是以指定位置显示字符，
 205                  当flag为0则以当前位置*/ 
 206          void  DisplayStr( u_char x, u_char y, bit flag, u_char *str, const u_char len )
 207          {       
 208   1              u_char xdata timeflag = 1;
 209   1              u_char xdata clearstr[] = "                    ";
 210   1              u_char xdata tempstr[20];
 211   1              u_char xdata i = 0;
 212   1              u_char xdata j = 0;
 213   1      
 214   1              memset( tempstr, 0x20, sizeof( tempstr ) );
 215   1              if( flag == 0 )//在当前位置显示                         
 216   1                      i = DisplayString( str, len );          
 217   1              else
 218   1              {                               
 219   2                      if( ( x + len ) < 20 )                  
 220   2                              memcpy( tempstr + x, str, len );                
 221   2                      else
 222   2                              memcpy( tempstr + x, str, 20 );
 223   2              //len = 20;             
 224   2                      i = DisplayPosString( 0, y, tempstr, 20 );//设置屏幕字串
 225   2              }       
 226   1              if( i == 0 )
 227   1                      return ;
 228   1              i = 0;
 229   1              j = 0;
 230   1              while( ! ( i || j ) )
 231   1              {
 232   2                      WaitForWork( 50, NULL );
 233   2                      i = TestDeviceTimeOut( &Lcd );
 234   2                      j = TestDeviceCommOK( &Lcd );           
 235   2              }
 236   1          //WaitForWork( 3000, &Lcd );
 237   1      }
 238          
 239          //输入密码
 240          u_char GetOneIDKey()
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 5   

 241          {
 242   1              u_char xdata k = KEY_NULL ;
 243   1              u_char xdata m_str[2];
 244   1      //      u_char xdata line[2];   
 245   1              unsigned int xdata interval = 500;   //超时时间5秒
 246   1      
 247   1              memset( m_str, 0, 2 );
 248   1              m_str[0] = '*';
 249   1              while( ( k == KEY_NULL ) && ( interval != 0 ) )
 250   1              {
 251   2                      SchedulerProcess();
 252   2                      WaitForWork( 50, NULL );
 253   2                      k = GetKey();                   
 254   2                      interval --;
 255   2              }
 256   1              switch( k )
 257   1              {
 258   2                      case KEY_0:
 259   2                      case KEY_1:
 260   2                      case KEY_2:
 261   2                      case KEY_3:
 262   2                      case KEY_4:
 263   2                      case KEY_5:
 264   2                      case KEY_6:
 265   2                      case KEY_7:
 266   2                      case KEY_8:
 267   2                      case KEY_9:                     
 268   2              //      case KEY_DOT:           
 269   2                      //      NumberToString( k ,  m_str , 1  );                              
 270   2                      //      sprintf( m_str,"%bu", k );
 271   2                              DisplayStr( 0, 0, 0, m_str, 1 );
 272   2                          break;                      
 273   2              }       
 274   1              if(interval == 0)
 275   1                      return KEY_NULL;        
 276   1              return k;       
 277   1      }
 278          
 279          
 280          /*输入一行字符串，strTip为提示符，len为strTip的长度，y 为显示行号，line为返回的字符串,len1为最大输入长度及
             -实际输出长度
 281          1:成功，0：失败*/         
 282          u_char GetLine( u_char  *strTip, unsigned char len, u_char y, u_char * line, unsigned char *len1)
 283          {
 284   1          u_char      xdata key;
 285   1              u_char  xdata iCounter = 0;
 286   1              u_char  xdata len_loca;
 287   1              u_char xdata space_char = 0x20;
 288   1              u_char xdata Tempstr[20];
 289   1      
 290   1              memset( Tempstr, 0, sizeof( Tempstr ) );
 291   1              iCounter = 0;
 292   1              ClearKey();
 293   1              len_loca = *len1;               
 294   1              if( len + len_loca > 20 )
 295   1              {       
 296   2                      DisplayStr( 0, 0, 1, strTip, len );             
 297   2                      DisplayStr( 0, 1, 1, " ", 1 );  
 298   2                      DisplayCursorState( 0, 1, 1, 1, 1 );    
 299   2              }
 300   1              else
 301   1              {
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 6   

 302   2                      DisplayStr( 0, y, 1, strTip, len );
 303   2                      DisplayCursorState( len, y, 1, 1, 1 );          
 304   2              }
 305   1              SgwSecTimer= 30;
 306   1              while( SgwSecTimer )
 307   1              {
 308   2                      WaitForWork( 20, NULL );                        
 309   2                      if(iCounter >= len_loca)        
 310   2                      {
 311   3                              *len1 = len_loca;
 312   3                      //      WaitForWork( 800, NULL );               
 313   3                              memcpy( line, Tempstr, len_loca );
 314   3                              return 1;
 315   3                      }
 316   2                      key = GetOneKey();      
 317   2                      if ( (key == KEY_UP) || (key == KEY_DOWN) || (key == KEY_DOT) || (key == KEY_NULL) )
 318   2                          continue;
 319   2                      else if( key == KEY_SUBMIT) 
 320   2                      {                               
 321   3                              *len1 = iCounter;                       
 322   3                              memcpy( line, Tempstr, iCounter );
 323   3                              return 1;
 324   3                      }                       
 325   2                      else if(key == KEY_CANCEL)
 326   2                              return 0;
 327   2                      else if( key == KEY_BACK)//clear键,光标后退一格
 328   2                      {               
 329   3                              if( iCounter >= 1 )
 330   3                              {
 331   4                                      if( len + len_loca >= 20 )
 332   4                                      {                                                                               
 333   5                                              DisplayPosString( iCounter - 1, 1, &space_char, 1); /* 屏幕清掉一个数字字符 */  
 334   5                                              WaitForWork( 300, &Lcd );
 335   5                                              DisplaySetCursorPos( iCounter - 1 , 1 );//设置光标位置                          
 336   5                                              WaitForWork( 300, &Lcd );
 337   5                                      }
 338   4                                      else
 339   4                                      {                                                                               
 340   5                                              DisplayPosString( iCounter + len - 1, y, &space_char, 1); /* 屏幕清掉一个数字字符 */    
 341   5                                              WaitForWork( 300, &Lcd );
 342   5                                              DisplaySetCursorPos( iCounter + len - 1 , y );//设置光标位置                            
 343   5                                              WaitForWork( 300, &Lcd );
 344   5                                      }                                               
 345   4                                      *(line + iCounter) = 0;
 346   4                                      iCounter--;             
 347   4                                      SgwSecTimer = 30;
 348   4                              }
 349   3                              
 350   3                      }
 351   2                      else
 352   2                      {                                               
 353   3                              Tempstr[ iCounter ] = key;                      
 354   3                              iCounter++;
 355   3                              SgwSecTimer = 30;                       
 356   3                      }                       
 357   2              }
 358   1      }
 359          
 360          /*输入一行字符串，strTip为提示符，len为strTip的长度，line为返回的字符串,
 361          len为line的最大长度,Passwdlog为输入密码(1)或输入其它(0) 1:成功，0：失败*/         
 362          u_char GetLine_1( u_char  *strTip, unsigned char len, u_char y, u_char * line, unsigned char *len1, bit Pa
             -sswdlog)
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 7   

 363          {
 364   1          u_char      xdata key;
 365   1              u_char  xdata iCounter = 0;
 366   1              u_char  xdata len_loca;
 367   1              u_char xdata space_char = 0x20;
 368   1              u_char xdata Tempstr[20];
 369   1      
 370   1              memset( Tempstr, 0, sizeof( Tempstr ) );
 371   1              iCounter = 0;
 372   1              ClearKey();
 373   1              len_loca = *len1;               
 374   1              if( len + len_loca >= 20 )
 375   1              {       
 376   2                      DisplayStr( 0, 0, 1, strTip, len );             
 377   2                      DisplayStr( 0, 1, 1, " ", 1 );  
 378   2                      DisplayCursorState( 0, 1, 1, 1, 1 );    
 379   2              }
 380   1              else
 381   1              {
 382   2                      DisplayStr( 0, y, 1, strTip, len );
 383   2                      DisplayCursorState( len, y, 1, 1, 1 );          
 384   2              }
 385   1      
 386   1          //SgwSecTimer = 30;
 387   1              while( 1 )
 388   1              {
 389   2                      WaitForWork( 50, NULL );                        
 390   2                      key = KEY_NULL;
 391   2                      ClearKey();
 392   2                      if(iCounter >= len_loca)        
 393   2                      {
 394   3                              *len1 = len_loca;               
 395   3                              memcpy( line, Tempstr, len_loca );
 396   3                              return 1;
 397   3                      }
 398   2                      if( Passwdlog == 1 )
 399   2                              key = GetOneIDKey();    
 400   2                      else
 401   2                              key = GetOneKey();                      
 402   2                      if ( (key == KEY_UP) || (key == KEY_DOWN) /*|| (key == KEY_BACK)*/ || (key == KEY_NULL) )
 403   2                          continue;
 404   2                      else if( key == KEY_SUBMIT) 
 405   2                      {                               
 406   3                              *len1 = iCounter;                       
 407   3                              memcpy( line, Tempstr, iCounter );
 408   3                              return 1;
 409   3                      }                       
 410   2                      else if(key == KEY_CANCEL)
 411   2                              return 0;
 412   2                      else if( key == KEY_BACK)//clear键,光标后退一格
 413   2                      {               
 414   3                              if( iCounter >= 1 )
 415   3                              {
 416   4                                      if( len + len_loca >= 20 )
 417   4                                      {                                                                               
 418   5                                              DisplayPosString( iCounter - 1, 1, &space_char, 1); /* 屏幕清掉一个数字字符 */  
 419   5                                              WaitForWork( 300, &Lcd );
 420   5                                              DisplaySetCursorPos( iCounter - 1 , 1 );//设置光标位置                          
 421   5                                              WaitForWork( 300, &Lcd );
 422   5                                      }
 423   4                                      else
 424   4                                      {                                                                               
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 8   

 425   5                                              DisplayPosString( iCounter + len - 1, y, &space_char, 1); /* 屏幕清掉一个数字字符 */    
 426   5                                              WaitForWork( 300, &Lcd );
 427   5                                              DisplaySetCursorPos( iCounter + len - 1 , y );//设置光标位置                            
 428   5                                              WaitForWork( 300, &Lcd );
 429   5                                      }                                               
 430   4                                      *(line + iCounter) = 0;
 431   4                                      iCounter--;                             
 432   4                              }                       
 433   3                      }
 434   2                      else
 435   2                      {                                               
 436   3                              Tempstr[ iCounter ] = key;                      
 437   3                              iCounter++;                                     
 438   3                      }                       
 439   2              }
 440   1              return 0;
 441   1      }
 442          
 443          
 444          /*获取单键金额输入*/
 445          u_char GetOneMoneyKey()
 446          {
 447   1              u_char xdata k = KEY_NULL ;
 448   1              u_char xdata m_str[2];
 449   1      //      u_char xdata line[2];   
 450   1              unsigned int xdata interval = 500;   //超时时间5秒
 451   1              
 452   1              memset( m_str, 0 , sizeof (m_str ) );
 453   1              while( ( k == KEY_NULL ) && ( interval != 0 ) )
 454   1              {
 455   2                      SchedulerProcess();
 456   2                      WaitForWork( 50, NULL );
 457   2                      k = GetKey();                   
 458   2                      interval --;
 459   2              }
 460   1              switch( k )
 461   1              {
 462   2                      case KEY_0:
 463   2                      case KEY_1:
 464   2                      case KEY_2:
 465   2                      case KEY_3:
 466   2                      case KEY_4:
 467   2                      case KEY_5:
 468   2                      case KEY_6:
 469   2                      case KEY_7:
 470   2                      case KEY_8:
 471   2                      case KEY_9:                     
 472   2                              NumberToString( k ,  m_str , 1  );                              
 473   2                      //      sprintf( m_str,"%bu", k );
 474   2                              DisplayStr( 0, 0, 0, m_str, 1 );
 475   2                          break;      
 476   2              }       
 477   1              if(interval == 0)
 478   1                      return KEY_NULL;        
 479   1              return k;       
 480   1      }
 481          
 482          /*输入一行字符串，strTip为提示符，len为strTip的长度，line为返回的字符串,
 483          len为line的最大长度,Passwdlog为输入密码(1)或输入其它(0) 1:成功，0：失败*/         
 484          u_char GetLineMoney( u_char  *strTip, unsigned char len, u_char y, u_char * line, unsigned char *len1 )
 485          {
 486   1          u_char xdata key;
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 9   

 487   1              u_char xdata iCounter = 0;
 488   1              u_char xdata len_loca;
 489   1              u_char xdata space_char = 0x20;
 490   1              u_char xdata Tempstr[20];
 491   1      
 492   1              memset( Tempstr, 0, sizeof( Tempstr ) );
 493   1              iCounter = 0;
 494   1              ClearKey();
 495   1              len_loca = *len1;               
 496   1              if( len + len_loca >= 20 )
 497   1              {       
 498   2                      DisplayStr( 0, 0, 1, strTip, len );             
 499   2                      DisplayStr( 0, 1, 1, " ", 1 );  
 500   2                      DisplayCursorState( 0, 1, 1, 1, 1 );    
 501   2              }
 502   1              else
 503   1              {
 504   2                      DisplayStr( 0, y, 1, strTip, len );
 505   2                      DisplayCursorState( len, y, 1, 1, 1 );          
 506   2              }
 507   1              while( 1 )
 508   1              {
 509   2                      WaitForWork( 50, NULL );                        
 510   2                      key = KEY_NULL;
 511   2                      ClearKey();
 512   2                      if(iCounter >= len_loca)        
 513   2                      {
 514   3                              *len1 = len_loca;               
 515   3                              memcpy( line, Tempstr, len_loca );
 516   3                              return 1;
 517   3                      }
 518   2                      key = GetOneMoneyKey();                 
 519   2                      if ( (key == KEY_UP) || (key == KEY_DOWN) || (key == KEY_DOT) || (key == KEY_NULL) )
 520   2                          continue;
 521   2                      else if( key == KEY_SUBMIT) 
 522   2                      {                               
 523   3                              *len1 = iCounter;                       
 524   3                              memcpy( line, Tempstr, iCounter );
 525   3                              return 1;
 526   3                      }                       
 527   2                      else if(key == KEY_CANCEL)
 528   2                              return 0;
 529   2                      else if( key == KEY_BACK)//clear键,光标后退一格
 530   2                      {               
 531   3                              if( iCounter >= 1 )
 532   3                              {
 533   4                                      if( len + len_loca >= 20 )
 534   4                                      {                                                                               
 535   5                                              DisplayPosString( iCounter - 1, 1, &space_char, 1); /* 屏幕清掉一个数字字符 */  
 536   5                                              WaitForWork( 300, &Lcd );
 537   5                                              DisplaySetCursorPos( iCounter - 1 , 1 );//设置光标位置                          
 538   5                                              WaitForWork( 300, &Lcd );
 539   5                                      }
 540   4                                      else
 541   4                                      {                                                                               
 542   5                                              DisplayPosString( iCounter + len - 1, y, &space_char, 1); /* 屏幕清掉一个数字字符 */    
 543   5                                              WaitForWork( 300, &Lcd );
 544   5                                              DisplaySetCursorPos( iCounter + len - 1 , y );//设置光标位置                            
 545   5                                              WaitForWork( 300, &Lcd );
 546   5                                      }                                               
 547   4                                      *(line + iCounter) = 0;
 548   4                                      iCounter--;                                             
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 10  

 549   4                              }                       
 550   3                      }
 551   2                      else
 552   2                      {                                               
 553   3                              Tempstr[ iCounter ] = key;                      
 554   3                              iCounter++;                     
 555   3                      }                       
 556   2              }
 557   1              return 0;
 558   1      }
 559          
 560          void ClearDisplayLine( u_char Line )
 561          {
 562   1              if( ( Line > 0 ) && ( Line < 3 ) )
 563   1              {
 564   2                      DisplayStr( 0, Line - 1 , 1 , "                    " , 20 );
 565   2                      WaitForWork( 20, NULL );        
 566   2              }
 567   1      }
 568          
 569          
 570          /*显示光标位置和类型,posflag确定是否设置位置,当它是0时x、y无效；stateflag意义相同*/     
 571          void  DisplayCursorState( u_char x, u_char y, bit posflag, u_char state, bit stateflag   )
 572          {               
 573   1              u_char xdata i = 0;
 574   1              u_char xdata j = 0;
 575   1      
 576   1              if( posflag == 1 )      
 577   1                      i = DisplaySetCursorPos( x, y );        
 578   1              if( stateflag == 1 )                    
 579   1                      i = DisplaySetCursorStyle( state );
 580   1      
 581   1              if( i == 0 )
 582   1                      return ;
 583   1              i = 0;
 584   1              j = 0;
 585   1              while( ! ( i || j ) )
 586   1              {
 587   2                      WaitForWork( 50, NULL );
 588   2                      i = TestDeviceTimeOut( &Lcd );
 589   2                      j = TestDeviceCommOK( &Lcd );           
 590   2              }
 591   1      //      WaitForWork( 3000, &Lcd );
 592   1      }
 593          
 594          /*获取单键输入*/
 595          u_char GetOneKey()
 596          {
 597   1              u_char xdata k = KEY_NULL ;
 598   1              u_char xdata m_str[2];
 599   1      //      u_char xdata line[2];   
 600   1              unsigned int xdata interval = 500;   //超时时间5秒
 601   1              
 602   1              memset( m_str, 0 , sizeof (m_str ) );
 603   1              while( ( k == KEY_NULL ) && ( interval != 0 ) )
 604   1              {
 605   2                      CoreProcessCycle();
 606   2                      WaitForWork( 50, NULL );
 607   2                      k = GetKey();                   
 608   2                      interval --;
 609   2              }
 610   1              switch( k )
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 11  

 611   1              {
 612   2                      case KEY_0:
 613   2                      case KEY_1:
 614   2                      case KEY_2:
 615   2                      case KEY_3:
 616   2                      case KEY_4:
 617   2                      case KEY_5:
 618   2                      case KEY_6:
 619   2                      case KEY_7:
 620   2                      case KEY_8:
 621   2                      case KEY_9:                     
 622   2                              NumberToString( k ,  m_str , 1  );                              
 623   2                      //      sprintf( m_str,"%bu", k );
 624   2                              DisplayStr( 0, 0, 0, m_str, 1 );
 625   2                          break;
 626   2              //      case KEY_DOT:           
 627   2              //              m_str[0] = 0x2e;
 628   2          //      DisplayStr( 0, 0, 0, m_str, 1 );  
 629   2              //              break;
 630   2              }       
 631   1              if(interval == 0)
 632   1                      return KEY_NULL;        
 633   1              return k;       
 634   1      }
 635          
 636          /*求数字的长度*/
 637          /*求数字的长度*/
 638          u_char LenOfNum( unsigned long num )
 639          {
 640   1              if(num >= 1000000000 )
 641   1                      return 10;
 642   1              if(num >= 100000000 )
 643   1                      return 9;
 644   1              if(num >= 10000000 )
 645   1                      return 8;
 646   1              if(num >= 1000000 )
 647   1                      return 7;
 648   1              if(num >= 100000 )
 649   1                      return 6;
 650   1              if(num >= 10000 )
 651   1                      return 5;
 652   1              else if(num >= 1000 )
 653   1                      return 4;
 654   1              else if(num >= 100 )
 655   1                      return 3;
 656   1              else if(num >= 10 ) 
 657   1                      return 2;
 658   1              else
 659   1                      return 1;
 660   1      } 
 661          
 662          //出币模块收到后会返回ACK应答包
 663          u_char HopperOutCoin( u_int iCoinNum, u_char iHopperNo, struct DEVICE xdata* iDevice )
 664          {       
 665   1              u_char xdata i = 0;
 666   1              u_char xdata j = 0;
 667   1      
 668   1              HopperOutput( iHopperNo , iCoinNum );
 669   1              WaitForWork( 100, NULL );
 670   1              i = 0;
 671   1              j = 0;
 672   1              while( ! ( i || j ) )
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 12  

 673   1              {
 674   2                      WaitForWork( 100, NULL );
 675   2                      i = TestDeviceTimeOut( iDevice );
 676   2                      j = TestDeviceCommOK( iDevice );                
 677   2              }               
 678   1              if ( i )        
 679   1              {
 680   2                      return 1;//超时
 681   2              }
 682   1      //      if ( TestDeviceException( iDevice ) )
 683   1      //      {
 684   1      //              return 2;//故障
 685   1      //      }
 686   1              Trace("\n HopperOutCoin OK" );
 687   1              sysVPMission.hopperCoinNum = iCoinNum;
 688   1              return 0; // 正常返回
 689   1      }
 690             
 691          
 692          //输入货道,返回物理货道编号与逻辑货道数组的数组序列编号，输入失败返回100
 693          u_char InputGoodsWayNo( u_char x )
 694          {
 695   1              u_char xdata key = 0;
 696   1              u_char xdata m_InputCode;
 697   1              u_char xdata m_GoodsWayNo;
 698   1              u_char xdata Tempstr[8];
 699   1              u_char xdata len = 0;
 700   1              u_char xdata i = 0;
 701   1              
 702   1              ClearKey();
 703   1              while( 1 )
 704   1              {               
 705   2                      ClearDisplayLine( 1 );
 706   2                      ClearDisplayLine( 2 );          
 707   2                      len = 2;
 708   2                      memset( Tempstr,0, sizeof( Tempstr ) ); 
 709   2              #ifdef _CHINA_
 710   2                      key = GetLine( "请输入编号: ", 12 , 0, Tempstr, &len );
 711   2              #else   
                              key = GetLine( "Input column code:", 18 , 0, Tempstr, &len );
                      #endif
 714   2                      WaitForWork( 500, NULL );       
 715   2                      m_GoodsWayNo = 100;
 716   2                      m_InputCode = 0;
 717   2                      ClearKey();                             
 718   2                      if( key == 1 )//Enter   
 719   2                      {                       
 720   3                              DisplayCursorState( 0, 0, 0, 0, 1 );                    
 721   3                              for( i = 0; i < len; i ++ )
 722   3                              {
 723   4              //                      Trace( "\n GoodsNo1 = %bu", Tempstr[i] );               
 724   4                                      if( ( Tempstr[i] >= 0 ) && ( Tempstr[i] <= 9 ) )
 725   4                                              m_InputCode = m_InputCode * 10 + Tempstr[i];                            
 726   4                              }
 727   3                              if( ( m_InputCode == 99 ) && ( x == 0 ) )
 728   3                                      return 99;                                      
 729   3                              ClearKey();     
 730   3                              if( m_InputCode != 0 )
 731   3                              {
 732   4                                      for( i = 0; i < GOODSWAYNUM; i ++ )
 733   4                                      {
 734   5                                              if( InputGoodsWayList[i].GoodsWayNo == m_InputCode )
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 13  

 735   5                                              {
 736   6                                                      m_GoodsWayNo = i;                                       
 737   6                                                      return i;
 738   6                                              }
 739   5                                      }               
 740   4                              }
 741   3                              else
 742   3                                      i = GOODSWAYNUM;
 743   3                              if( i == GOODSWAYNUM )
 744   3                          {
 745   4                              #ifdef _CHINA_
 746   4                                      DisplayStr( 0, 0, 1, "编号输入错误", 12 );
 747   4                                      DisplayStr( 0, 1, 1, "请输入其它编号", 14 );
 748   4                              #else
                                              DisplayStr( 0, 0, 1, "Input code error", 16 );
                                              DisplayStr( 0, 1, 1, "Input other code", 16 );
                                      #endif
 752   4                                      m_GoodsWayNo = 100;                     
 753   4                                      WaitForWork( 2000, NULL );
 754   4                                      continue;
 755   4                              }                       
 756   3              //              Trace( "\n m_SetArrayNo = %bu", m_GoodsWayNo );
 757   3              //              Trace( "\n return 0" );
 758   3                              return m_GoodsWayNo;
 759   3                      }
 760   2                      else
 761   2                              return m_GoodsWayNo;
 762   2              }
 763   1      }
 764          
 765          
 766          
 767          
 768          
 769          
 770          /*返回值的意义
 771                  0:正确执行的命令
 772                  1:出货返回失败
 773                  2:执行命令超时
 774                  3:货道无货
 775                  4:货道故障
 776                  5:在限定的时间内电机不能到位
 777              6:
 778              7: CMD ERR
 779              8: GOC check error 
 780          */
 781          u_char ChannelTask( u_char ChannelNum, u_char TaskId )
 782          {       
 783   1              u_char xdata i = 0;
 784   1              u_char xdata j = 0;
 785   1              u_char xdata z = 0;
 786   1      
 787   1              #ifdef   _SJJ_//升降机
 788   1                      return 0;
 789   1              #endif
 790   1              
 791   1              while( z < 2 )
 792   1              {
 793   2                      switch( TaskId )
 794   2                      {
 795   3                              case CHANNEL_EXEC://出货                        
 796   3                                      ZhkChannelExec( ChannelNum, z );                        
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 14  

 797   3                                      break;
 798   3                              case CHANNEL_QUERY://查询命令执行情况
 799   3                                      ZhkChannelQuery();
 800   3                                      break;
 801   3                              case CHANNEL_TEST://货道测试
 802   3                                      ZhkChannelTest( ChannelNum );                   
 803   3                                      break;
 804   3                              case CHANNEL_CLEAR://同步SN
 805   3                                      ZhkChannelClear();
 806   3                                      break;          
 807   3                              default:
 808   3                                      return 0;
 809   3                      }
 810   2                      i = 0;
 811   2                      j = 0;
 812   2                      while( ! ( i || j ) )
 813   2                      {
 814   3                              WaitForWork( 50, NULL );
 815   3                              i = TestDeviceTimeOut( &Channel );
 816   3                              j = TestDeviceCommOK( &Channel );               
 817   3                      }
 818   2              //      Trace("\n i = %bu, j = %bu", i, j );
 819   2                      if( i ) //超时，货道故障        
 820   2                      {
 821   3                              if( ( TaskId == CHANNEL_EXEC ) || ( TaskId == CHANNEL_TEST ) )
 822   3                              {
 823   4                                      if( Channel.ExtState[2] == 0 )  //没有收到命令ACK，重试一次
 824   4                                      {
 825   5                                              z++;
 826   5                                              continue;
 827   5                                      }
 828   4                                      else if( Channel.ExtState[2] == 1 )//收到命令ACK，但没有收到消息ACK，则查询命令执行情况
 829   4                                      {
 830   5                                              TaskId = CHANNEL_QUERY;
 831   5                                              z++;
 832   5                              //              Trace("\n CHANNEL_QUERY" );
 833   5                                              continue;
 834   5                                      }
 835   4                              }
 836   3                              else
 837   3                              {
 838   4                      //              Trace("\n TimeOut" );
 839   4                                      return 2;
 840   4                              }
 841   3                      }
 842   2                      else
 843   2                              break;
 844   2              }
 845   1              if( i )
 846   1                      return 2;
 847   1              /*状态字节中各位的意义
 848   1                Bit 6: 接收到的命令包有错误
 849   1                Bit 5: 货物没有通过出货检测口
 850   1                Bit 4: 在限定的时间内电机不能到位
 851   1                Bit 3: 电机没有转动
 852   1                Bit 2: 在转动前电机没有到位
 853   1                Bit 1: 商品卖空，保留
 854   1                Bit 0: 命令失败 */
 855   1              switch( TaskId )
 856   1              {
 857   2                  
 858   2                      case CHANNEL_EXEC:
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 15  

 859   2                      case CHANNEL_QUERY:     
 860   2                      case CHANNEL_TEST:
 861   2                              //----------------------------------------------------------------------
 862   2                              //Added by Andy on 2010.10.21 for GOC device
 863   2                   if( SystemParameter.GOCOn == 1 )
 864   2                       {
 865   3                                              if( Channel.State & 0x80 )
 866   3                                              {
 867   4                                                      DeviceStatus.GOCStatus |= 0x01; 
 868   4                                              }
 869   3                          else
 870   3                          {
 871   4                              DeviceStatus.GOCStatus &= 0xFE;
 872   4                          }
 873   3                               }
 874   2                              //======================================================================
 875   2                              if( Channel.State & 0x01 ) 
 876   2                              {       
 877   3                      /*
 878   3                      2011.3.4 disabled!
 879   3                                      if( Channel.State & 0x04 )
 880   3                                              return 3;//在转动前电机没有到位，没有出货，此货道已不能工作了
 881   3                      */
 882   3                                      if( Channel.State & 0x08 )
 883   3                                      {                                   
 884   4                                              return 4;//电机没有转动，没有出货，可以重试一次
 885   4                                      }
 886   3                                      //有出现货道未转，或未转到位时，不扣钱;by cq 20110909
 887   3                                      //if( Channel.State & 0x10 )
 888   3                                      //      return 5;//在限定的时间内电机不能到位（但货已出成功，货道有硬件故障）
 889   3                      if( Channel.State & 0x10 )                                      
 890   3                                      {
 891   4      
 892   4                                          /*
 893   4                              if( SystemParameter.GOCOn == 1 )
 894   4                                      {
 895   4                                                      if(!( Channel.State & 0x20 ))
 896   4                                                      {                                                   
 897   4                                                              return 5;
 898   4                                                      }                                               
 899   4                                                      return 4;
 900   4                              }
 901   4                                              */                                      
 902   4                                              return 4;
 903   4                                      }
 904   3      
 905   3                                      if( Channel.State & 0x40 )
 906   3                                              return 7;//接收到的命令包有错误，但货没有出，可以重试一次
 907   3                                      //----------------------------------------------------------------------
 908   3                                      //Added by Andy on 2010.10.21 for GOC device
 909   3                      if( SystemParameter.GOCOn == 1 )
 910   3                              {
 911   4                                              if( Channel.State & 0x20 )
 912   4                                              {
 913   5                                                  //if( ( DeviceStatus.GOCStatus == 0x00 ) )
 914   5                              /*
 915   5                                                      if( SystemParameter.SVC_GOCErr == 0x00 )
 916   5                                                      {
 917   5                                                              return 8;
 918   5                                                      }
 919   5                                                      else
 920   5                                                      {
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 16  

 921   5                                                          return 0;   
 922   5                                                      }
 923   5                              */                                              
 924   5                              return 8;
 925   5                                              }
 926   4                                      }
 927   3                                      //======================================================================
 928   3                                      return 1;//命令失败
 929   3                              }
 930   2                              break;          
 931   2                      case CHANNEL_CLEAR:
 932   2                  {
 933   3                      //----------------------------------------------------------------------
 934   3                                      //Added by Andy on 2010.10.21 for GOC device
 935   3                           if( SystemParameter.GOCOn == 1 )
 936   3                               {
 937   4                                                      if( Channel.State & 0x80 )
 938   4                                                      {
 939   5                                                              DeviceStatus.GOCStatus |= 0x01; 
 940   5                                                      }
 941   4                                  else
 942   4                                  {
 943   5                                      DeviceStatus.GOCStatus &= 0xFE;
 944   5                                  }
 945   4                                       }
 946   3                                      //======================================================================
 947   3                  }
 948   2                              break;
 949   2              }               
 950   1              return 0;//出货成功
 951   1      }
 952          
 953          /*
 954          //货道查询
 955          u_char ChannelQuery( u_char ChannelNum )
 956          {
 957                  u_char xdata i = 0;
 958                  u_char xdata j = 0;
 959          
 960          //      if ( ChannelNum > GOODSWAYNUM || ChannelNum == 0 )      
 961          //              return 4;//货道不正确
 962          //      Trace( "\n ChannelQuery" );
 963                  ZhkChannelQuery( ChannelNum );
 964                  i = 0;
 965                  j = 0;
 966                  while( ! ( i || j ) )
 967                  {
 968                          WaitForWork( 100, NULL );
 969                          i = TestDeviceTimeOut( &Channel );
 970                          j = TestDeviceCommOK( &Channel );               
 971                  }
 972                  if( i ) 
 973                          return 3;//超时，货道故障
 974                  else if( Channel.State & 0x01 )
 975                          return 2;//出货失败
 976                  return 0;//货道正常
 977          }
 978          
 979          //货道出货
 980          u_char ChannelExec( u_char ChannelNum )
 981          {
 982                  u_char xdata i = 0;
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 17  

 983                  u_char xdata j = 0;
 984          
 985          //      if ( ChannelNum > 64 || ChannelNum == 0 )       
 986          //              return 1;//货道不正确
 987                  ZhkChannelExec( ChannelNum );
 988                  i = 0;
 989                  j = 0;
 990                  while( ! ( i || j ) )
 991                  {
 992                          WaitForWork( 100, NULL );
 993                          i = TestDeviceTimeOut( &Channel );
 994                          j = TestDeviceCommOK( &Channel );               
 995                  }       
 996                  if ( i )        
 997                          return 3;//超时,货道板和主机通讯有问题,可认为整个出货统有问题
 998                  if ( Channel.State & 0x01 )     
 999                          return 2;//出货失败
1000                  return 0;//出货成功
1001                  
1002          }
1003          */
1004          
1005          //id=4, ACDCModule
1006          u_char GetSelectionState( u_char id, struct DEVICE xdata* iDevice )
1007          {
1008   1              u_char xdata i = 0;
1009   1              u_char xdata j = 0;
1010   1              u_char xdata timeBuf = 0;
1011   1       
1012   1              if( ( id == 1 ) || ( id == 2 ) || ( id == 3 ) || ( id == 4 ) )
1013   1              {
1014   2                      timeBuf = 3;  //10-3
1015   2          }
1016   1              for( YgpSecTimer=timeBuf; YgpSecTimer; )
1017   1              {               
1018   2                  SelectionQuery( id );
1019   2                      while( 1 )
1020   2                      {
1021   3                              i = TestDeviceCommOK( iDevice );
1022   3                              j = TestDeviceTimeOut( iDevice );
1023   3                              if( !( j || i ) )                                       
1024   3                              {
1025   4                                      WaitForWork( 100, NULL );
1026   4                                      i = 0;
1027   4                              }
1028   3                              else
1029   3                  {
1030   4                                      break;
1031   4                  }   
1032   3                      }
1033   2                      if( i == 4 )
1034   2              {
1035   3                              break;
1036   3                      }
1037   2                      WaitForWork( 100, NULL );
1038   2              }
1039   1              if( ( YgpSecTimer == 0 ) || ( j ) )
1040   1              {               
1041   2                      Trace("\n Time Out" );
1042   2                      return 1;      //超时
1043   2              }
1044   1          /*  
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 18  

1045   1              if ( TestDeviceException( iDevice ) )
1046   1              {
1047   1                      return 2;   //故障
1048   1              }
1049   1          */
1050   1              return 0;   //正常返回
1051   1              
1052   1      }
1053          
1054          
1055          u_char ACDCMission( void )
1056          {
1057   1          u_char xdata flag = 0;
1058   1      
1059   1              if( SystemParameter.ACDCModule == 0 )
1060   1              {
1061   2                      return 1;
1062   2              }
1063   1      
1064   1              if( DeviceStatus.ACDCModule == 0 )
1065   1              {
1066   2                      flag = GetSelectionState( 4, &ACDCModule );
1067   2                  if( flag == 0 )
1068   2                      {
1069   3                          DeviceStatus.ACDCModule &= 0xfe;
1070   3                  //DeviceStatus.ACDCModule = 0;
1071   3                              return 0;
1072   3                      }
1073   2                      else
1074   2                      {
1075   3                              DeviceStatus.ACDCModule |= 0x01;
1076   3                              return 1;
1077   3                      }
1078   2              }
1079   1              //return 0;
1080   1      }
1081          
1082          u_char GetHardWareDeviceState( u_char iHopperNo, struct DEVICE xdata* iDevice )
1083          {
1084   1              u_char xdata i = 0;
1085   1              u_char xdata j = 0;
1086   1              u_int xdata timeBuf = 0;
1087   1          u_char xdata result = 0;
1088   1      
1089   1          //----------------------------------------------------------------------------------
1090   1          //Changed by Andy on 2010.11.2
1091   1          if( ( iHopperNo == 1 ) || ( iHopperNo == 2 ) || ( iHopperNo == 3 ) )
1092   1          {
1093   2              //timeBuf = 5000;  //255-120-255(2011.6.16),5000(20110616)
1094   2                      //时间由需要出币的数量来确定，20S是延时时间;by gzz 20110616
1095   2                      timeBuf = sysVPMission.hopperCoinNum/4 + 20;            
1096   2          }
1097   1          else
1098   1          {
1099   2              timeBuf = 10;
1100   2          }        
1101   1          //==================================================================================
1102   1          
1103   1              //for( YgpSecTimer = timeBuf; YgpSecTimer ; )
1104   1          //for( YgpSecTimer=timeBuf; YgpSecTimer>0; )//by gzz 20110616
1105   1              for( sysVPMission.hopperOutTimer=timeBuf; sysVPMission.hopperOutTimer>0; )
1106   1              {                       
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 19  

1107   2                      if( ( iHopperNo == 1 ) || ( iHopperNo == 2 ) || ( iHopperNo == 3 ) )  //出币器状态
1108   2              {
1109   3                              HopperQuery( iHopperNo );
1110   3              }
1111   2                      else if( iHopperNo == 4 )   //纸币器状态
1112   2                      {
1113   3                  if( sysITLMission.ITLSet == 1 )
1114   3                  {
1115   4                      i = ITLMission_Poll();
1116   4                  }
1117   3                  else
1118   3                  {
1119   4                                      i = CasherQuery( );     
1120   4                                  WaitForWork( 100, NULL );
1121   4                  }
1122   3                      }
1123   2              sysVPMission.hopperTimer = timeBuf;
1124   2                      while( sysVPMission.hopperTimer )
1125   2                      {
1126   3                  
1127   3                  //--------------------------------------------------------------------------
1128   3                  if( (iHopperNo>=1)&&(iHopperNo<=3) )
1129   3                  {
1130   4                      WaitForWork( 100, NULL );
1131   4                      //sysVPMission.msGameTimer1 = 200;
1132   4                                      //while( sysVPMission.msGameTimer1 )
1133   4                                      {
1134   5                                              //----------------------------------------------------
1135   5                                      //Send the game key and poll pc in speciall time
1136   5                                      if( IfGameKeyOn() )
1137   5                                              {
1138   6                                                      VPMission_Button_RPT( VP_BUT_GAME, VP_BUT_NUMBER );
1139   6                                              //Beep();
1140   6                                              }
1141   5                                      result = VPMission_Poll();
1142   5                                      //===============================
1143   5                                      } 
1144   4                  }
1145   3                  //============================================================================
1146   3      
1147   3                              i = TestDeviceCommOK( iDevice );
1148   3                              j = TestDeviceTimeOut( iDevice );
1149   3                              if( !( j || i ) )                                       
1150   3                              {
1151   4                                      WaitForWork( 100, NULL );
1152   4                                      i = 0;
1153   4                              }
1154   3                              else
1155   3                                      break;  
1156   3                      }
1157   2                      if( iHopperNo == 4 )
1158   2                              break;
1159   2                      if( i == 4 )
1160   2                              break;          
1161   2                      WaitForWork( 100, NULL );
1162   2              }
1163   1      
1164   1              //if( ( YgpSecTimer == 0 ) || ( j ) )//by gzz 20110616
1165   1              if( ( sysVPMission.hopperOutTimer == 0 ) || ( j ) )
1166   1              {               
1167   2                      Trace("\n Time Out" );
1168   2                      return 1;//超时
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 20  

1169   2              }       
1170   1              if ( TestDeviceException( iDevice ) )
1171   1              {
1172   2              //Trace("\n Exception" );
1173   2                      return 2;//故障
1174   2              }
1175   1              return 0; //正常返回    
1176   1      }
1177          
1178          
1179          /*
1180          void   PhoneTBCD( u_char *OutBuffer )
1181          {
1182                  u_char xdata i = 0;
1183                  for( i = 0; i < 16; i +=2 )             
1184                  {
1185                          if( SystemParameter.GSMNO[i] != 0xff )
1186                          {
1187                                  if( SystemParameter.GSMNO[i + 1] != 0xff )
1188                                          OutBuffer[i/2]  = SystemParameter.GSMNO[i] * 16 + SystemParameter.GSMNO[i+1];
1189                                  else
1190                                  {
1191                                          if( ( i % 2 ) == 0 )
1192                                          {
1193                                                  OutBuffer[i/2] = SystemParameter.GSMNO[i] * 16 + 15;
1194                                                  OutBuffer[i/2+1 ] = 0xff;
1195                                                  break;
1196                                          }
1197                                          else
1198                                          {                                               
1199                                                  OutBuffer[i/2 + 1 ] = 0xff;
1200                                                  break;
1201                                          }
1202                                  }
1203                          }
1204                          else
1205                                  OutBuffer[i/2 ] = 0xff;
1206                  }       
1207                  return; 
1208          }
1209          */
1210          u_char DisplayInfo( u_char line , u_char offset , u_char * buffer )
1211          {
1212   1              u_char xdata length;
1213   1      
1214   1              length = strlen( buffer );
1215   1              DisplayStr( offset , line , 1 , buffer , length );
1216   1              return( 0 );
1217   1      }
1218          
1219          void  LoadTradeParam()
1220          {
1221   1              //uint8_t *tp2;
1222   1              //uint16_t crc;
1223   1              u_char xdata RdBuf[128]={0};
1224   1              u_int xdata num=0;
1225   1              u_int xdata len = 0;
1226   1              u_int xdata crc=0;
1227   1              //u_char xdata str[20];
1228   1              /*
1229   1              tp2 = (uint8_t *) &SystemPara;//交易数据记录            
1230   1              AT45DBReadPage(4090,tp2);
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 21  

1231   1              
1232   1      
1233   1              crc = CrcCheck(tp2,124);
1234   1              Trace("\r\n defaultsys=%d,%x,%x",124,crc/256,crc%256);
1235   1              if( (crc/256 == SystemPara.CrcCheck[0])&&(crc%256 == SystemPara.CrcCheck[1]) )
1236   1              {
1237   1                      return 1;
1238   1              }
1239   1              else
1240   1              {
1241   1                      return 0;
1242   1              }*/
1243   1              //交易记录
1244   1              //MovFlashToSram( ADDRF_TRADECOUNTER , ( unsigned char xdata * )&TradeCounter , sizeof(struct TRADECOUNTE
             -R) );
1245   1              //1.读数据到数组中
1246   1              MovFlashToSram( ADDRF_TRADECOUNTER , RdBuf , 128 );     
1247   1              len = sizeof(struct TRADECOUNTER);
1248   1              //2.数据导入到结构体中
1249   1              memcpy(( unsigned char xdata * )&TradeCounter ,RdBuf, len);
1250   1          //3.数组作CRC校验
1251   1              crc = CrcCheck(RdBuf,len);
1252   1              //Trace("\r\n defaultsys=%d,%x,%x",num,crc/256,crc%256);
1253   1              //4.结构体中存放原先读入的校验值
1254   1              //TradeCounter.CrcCheck[0] = RdBuf[126];
1255   1              //TradeCounter.CrcCheck[1] = RdBuf[127]; 
1256   1              //作比较
1257   1              if( (HUINT16(crc) == RdBuf[len])&&(LUINT16(crc) == RdBuf[len+1]) )
1258   1              {
1259   2                      //len = sprintf( str, "deng=%x,%x-%x,%x", HUINT16(crc),LUINT16(crc),RdBuf[len],RdBuf[len+1] );
1260   2                      //DisplayStr( 0, 0, 1, str, len );
1261   2                      //WaitForWork( 2000, NULL );            
1262   2              }       
1263   1              else
1264   1              {
1265   2                      //len = sprintf( str, "budeng=%x,%x-%x,%x", HUINT16(crc),LUINT16(crc),RdBuf[len],RdBuf[len+1] );
1266   2                      //DisplayStr( 0, 0, 1, str, len );
1267   2                      //WaitForWork( 2000, NULL );
1268   2                      //拷贝备份数据页
1269   2                      //1.读数据到数组中
1270   2                      MovFlashToSram( ADDRF_TRADECOUNTERCOPY , RdBuf , 128 ); 
1271   2                      len = sizeof(struct TRADECOUNTER);
1272   2                      //2.数据导入到结构体中
1273   2                      memcpy(( unsigned char xdata * )&TradeCounter ,RdBuf, len);
1274   2                  //3.数组作CRC校验
1275   2                      crc = CrcCheck(RdBuf,len);
1276   2                      //Trace("\r\n defaultsys=%d,%x,%x",num,crc/256,crc%256);
1277   2                      //4.结构体中存放原先读入的校验值
1278   2                      RdBuf[len] = HUINT16(crc);
1279   2                      RdBuf[len+1] = LUINT16(crc);
1280   2      
1281   2                      //将备份数据页覆盖主数据页
1282   2                      MovSramToFlash( ADDRF_TRADECOUNTER , RdBuf , 128 ); 
1283   2              }
1284   1              
1285   1              /*      
1286   1              TradeCounter.TrueCurrencySum    = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1287   1              TradeCounter.CoinSum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1288   1              TradeCounter.CashSum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1289   1              TradeCounter.CashSumBack = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1290   1              TradeCounter.CoinSum5j = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1291   1              TradeCounter.CoinSum5jBack = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 22  

1292   1              TradeCounter.CoinSum1y = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1293   1              TradeCounter.CoinSum1yBack = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1294   1              TradeCounter.Hopper1Sum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1295   1              TradeCounter.Hopper1SumBack = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1296   1              TradeCounter.Hopper2Sum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1297   1              TradeCounter.Hopper2SumBack = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1298   1              TradeCounter.TotalSellNum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1299   1              TradeCounter.TotalSellMoeny = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1300   1              TradeCounter.vpSuccessNum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1301   1              TradeCounter.vpSuccessMoney = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1302   1              TradeCounter.vpCashNum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1303   1              TradeCounter.vpCashMoney = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1304   1              TradeCounter.vpGameNum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1305   1              TradeCounter.vpCardNum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1306   1              TradeCounter.vpOnlineNum = (RdBuf[num++]<<24)|(RdBuf[num++]<<16)|(RdBuf[num++]<<8)|(RdBuf[num++]);
1307   1              */
1308   1      }
1309          
1310          
1311          /*从Flash中装载数据*/
1312          void   LoadGlobalParam()
1313          {
1314   1              u_char xdata i = 0;             
1315   1              
1316   1              memset( &SystemParameter, 0, sizeof( SystemParameter ) );
1317   1              memset( GoodsWaySetVal, 0, sizeof( GoodsWaySetVal ) );
1318   1              memset( &TradeCounter, 0, sizeof(struct TRADECOUNTER) ); 
1319   1              //memset( TradeLog, 0, sizeof(struct TRADELOG) * GOODSWAYNUM );         
1320   1              memset( iRackSet, 0, sizeof(struct RackSet) * RACKNUM );        
1321   1              memset( iRackColumnSet, 0, sizeof(struct RackColumnSet) * RACKNUM * RACKCOLUMNNUM );
1322   1          //memset( &sysGoodsMatrix, 0, sizeof( sysGoodsMatrix ) );
1323   1      
1324   1              //本机系统参数
1325   1              MovFlashToSram( ADDRF_SYSTEMPARAM , ( unsigned char xdata * )&SystemParameter , sizeof(struct SYSTEMPARAM
             -ETER) );        
1326   1              MovFlashToSram( ADDRF_GOODSWAYS_SET , ( unsigned char xdata * )GoodsWaySetVal , sizeof( GoodsWaySetVal ) 
             -);        
1327   1              //交易记录
1328   1              //MovFlashToSram( ADDRF_TRADECOUNTER , ( unsigned char xdata * )&TradeCounter , sizeof(struct TRADECOUNTE
             -R) );                
1329   1          LoadTradeParam();
1330   1              //货道交易LOG设置
1331   1              //MovFlashToSram( ADDRF_WAYSTARDE_LOG , ( unsigned char xdata * )TradeLog , sizeof(struct TRADELOG) * GOO
             -DSWAYNUM );        
1332   1              //货架配置
1333   1              MovFlashToSram( ADDRF_RACK_SET , ( unsigned char xdata * )iRackSet , sizeof(struct RackSet) * RACKNUM );        
             -        
1334   1              //货道配置
1335   1              MovFlashToSram( ADDRF_RACK_COLUMN_SET , ( unsigned char xdata * )iRackColumnSet , sizeof(struct RackColum
             -nSet) * RACKNUM * RACKCOLUMNNUM );    
1336   1          //Goods parameter
1337   1          ReadGoodsParSet();  
1338   1      
1339   1      }
1340          
1341          //写入货道参数
1342          void SaveGoodsSet()
1343          {       
1344   1              MovSramToFlash( ADDRF_GOODSWAYS_SET , ( unsigned char xdata * )GoodsWaySetVal , sizeof(GoodsWaySetVal) );
             -        
1345   1      }
1346          
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 23  

1347          /*把数据写到Flash中*/
1348          void   SaveGlobalParam()
1349          {
1350   1              //本机系统参数  
1351   1              u_char xdata i = 0;
1352   1              u_char xdata j = 0;
1353   1              u_char xdata z = 0;
1354   1              //本机系统参数  
1355   1              //生成系统参数的校验位  
1356   1              i = sizeof( struct SYSTEMPARAMETER ) - 1;
1357   1              j = 0;
1358   1              for( z = 0; z < i; z++ )                        
1359   1                      j ^= (( u_char* )&SystemParameter)[z];                  
1360   1              SystemParameter.Checkbyte = j;
1361   1      
1362   1              MovSramToFlash( ADDRF_SYSTEMPARAM , ( unsigned char xdata * )&SystemParameter , sizeof(struct SYSTEMPARAM
             -ETER) );        
1363   1      }
1364          
1365          void  SaveTradeParam()
1366          {
1367   1              //uint8_t *tp2;
1368   1              u_char xdata Wrbuf[128]={0},RdBuf[128]={0};
1369   1              u_int xdata num=0,i=0;
1370   1              //u_char xdata str[20];
1371   1              u_int xdata len = 0;
1372   1              u_int xdata crc=0;
1373   1              /*
1374   1              tp2 = (uint8_t *) &SystemPara;//交易数据记录    
1375   1              //crc = CrcCheck(tp2,sizeof(SystemPara)-2); 
1376   1              crc = CrcCheck(tp2,124);        
1377   1              SystemPara.CrcCheck[0] = crc/256;
1378   1              SystemPara.CrcCheck[1] = crc%256;
1379   1              Trace("\r\n defaultsys=%d,%x,%x",sizeof(SystemPara)-2,SystemPara.CrcCheck[0],SystemPara.CrcCheck[1]);   
1380   1              AT45DBWritePage(4090,tp2);
1381   1              */
1382   1              //本机运行参数
1383   1              //MovSramToFlash( ADDRF_TRADECOUNTER , ( unsigned char xdata * )&TradeCounter , sizeof(struct TRADECOUNTE
             -R) );
1384   1              /*
1385   1              Wrbuf[num++] = (TradeCounter.TrueCurrencySum>>24)&0xff;
1386   1              Wrbuf[num++] = (TradeCounter.TrueCurrencySum>>16)&0xff;
1387   1              Wrbuf[num++] = (TradeCounter.TrueCurrencySum>>8)&0xff;
1388   1              Wrbuf[num++] = (TradeCounter.TrueCurrencySum)&0xff;
1389   1              Wrbuf[num++] = (TradeCounter.CoinSum>>24)&0xff;
1390   1              Wrbuf[num++] = (TradeCounter.CoinSum>>16)&0xff;
1391   1              Wrbuf[num++] = (TradeCounter.CoinSum>>8)&0xff;
1392   1              Wrbuf[num++] = (TradeCounter.CoinSum)&0xff;
1393   1              Wrbuf[num++] = (TradeCounter.CashSum>>24)&0xff;
1394   1              Wrbuf[num++] = (TradeCounter.CashSum>>16)&0xff;
1395   1              Wrbuf[num++] = (TradeCounter.CashSum>>8)&0xff;
1396   1              Wrbuf[num++] = (TradeCounter.CashSum)&0xff;
1397   1              Wrbuf[num++] = (TradeCounter.CashSumBack>>24)&0xff;
1398   1              Wrbuf[num++] = (TradeCounter.CashSumBack>>16)&0xff;
1399   1              Wrbuf[num++] = (TradeCounter.CashSumBack>>8)&0xff;
1400   1              Wrbuf[num++] = (TradeCounter.CashSumBack)&0xff;
1401   1              Wrbuf[num++] = (TradeCounter.CoinSum5j>>24)&0xff;
1402   1              Wrbuf[num++] = (TradeCounter.CoinSum5j>>16)&0xff;
1403   1              Wrbuf[num++] = (TradeCounter.CoinSum5j>>8)&0xff;
1404   1              Wrbuf[num++] = (TradeCounter.CoinSum5j)&0xff;
1405   1              Wrbuf[num++] = (TradeCounter.CoinSum5jBack>>24)&0xff;
1406   1              Wrbuf[num++] = (TradeCounter.CoinSum5jBack>>16)&0xff;
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 24  

1407   1              Wrbuf[num++] = (TradeCounter.CoinSum5jBack>>8)&0xff;
1408   1              Wrbuf[num++] = (TradeCounter.CoinSum5jBack)&0xff;
1409   1              Wrbuf[num++] = (TradeCounter.CoinSum1y>>24)&0xff;
1410   1              Wrbuf[num++] = (TradeCounter.CoinSum1y>>16)&0xff;
1411   1              Wrbuf[num++] = (TradeCounter.CoinSum1y>>8)&0xff;
1412   1              Wrbuf[num++] = (TradeCounter.CoinSum1y)&0xff;
1413   1              Wrbuf[num++] = (TradeCounter.CoinSum1yBack>>24)&0xff;
1414   1              Wrbuf[num++] = (TradeCounter.CoinSum1yBack>>16)&0xff;
1415   1              Wrbuf[num++] = (TradeCounter.CoinSum1yBack>>8)&0xff;
1416   1              Wrbuf[num++] = (TradeCounter.CoinSum1yBack)&0xff;
1417   1              Wrbuf[num++] = (TradeCounter.Hopper1Sum>>24)&0xff;
1418   1              Wrbuf[num++] = (TradeCounter.Hopper1Sum>>16)&0xff;
1419   1              Wrbuf[num++] = (TradeCounter.Hopper1Sum>>8)&0xff;
1420   1              Wrbuf[num++] = (TradeCounter.Hopper1Sum)&0xff;
1421   1              Wrbuf[num++] = (TradeCounter.Hopper1SumBack>>24)&0xff;
1422   1              Wrbuf[num++] = (TradeCounter.Hopper1SumBack>>16)&0xff;
1423   1              Wrbuf[num++] = (TradeCounter.Hopper1SumBack>>8)&0xff;
1424   1              Wrbuf[num++] = (TradeCounter.Hopper1SumBack)&0xff;
1425   1              Wrbuf[num++] = (TradeCounter.Hopper2Sum>>24)&0xff;
1426   1              Wrbuf[num++] = (TradeCounter.Hopper2Sum>>16)&0xff;
1427   1              Wrbuf[num++] = (TradeCounter.Hopper2Sum>>8)&0xff;
1428   1              Wrbuf[num++] = (TradeCounter.Hopper2Sum)&0xff;
1429   1              Wrbuf[num++] = (TradeCounter.Hopper2SumBack>>24)&0xff;
1430   1              Wrbuf[num++] = (TradeCounter.Hopper2SumBack>>16)&0xff;
1431   1              Wrbuf[num++] = (TradeCounter.Hopper2SumBack>>8)&0xff;
1432   1              Wrbuf[num++] = (TradeCounter.Hopper2SumBack)&0xff;
1433   1              Wrbuf[num++] = (TradeCounter.TotalSellNum>>24)&0xff;
1434   1              Wrbuf[num++] = (TradeCounter.TotalSellNum>>16)&0xff;
1435   1              Wrbuf[num++] = (TradeCounter.TotalSellNum>>8)&0xff;
1436   1              Wrbuf[num++] = (TradeCounter.TotalSellNum)&0xff;
1437   1              Wrbuf[num++] = (TradeCounter.TotalSellMoeny>>24)&0xff;
1438   1              Wrbuf[num++] = (TradeCounter.TotalSellMoeny>>16)&0xff;
1439   1              Wrbuf[num++] = (TradeCounter.TotalSellMoeny>>8)&0xff;
1440   1              Wrbuf[num++] = (TradeCounter.TotalSellMoeny)&0xff;
1441   1              Wrbuf[num++] = (TradeCounter.vpSuccessNum>>24)&0xff;
1442   1              Wrbuf[num++] = (TradeCounter.vpSuccessNum>>16)&0xff;
1443   1              Wrbuf[num++] = (TradeCounter.vpSuccessNum>>8)&0xff;
1444   1              Wrbuf[num++] = (TradeCounter.vpSuccessNum)&0xff;
1445   1              Wrbuf[num++] = (TradeCounter.vpSuccessMoney>>24)&0xff;
1446   1              Wrbuf[num++] = (TradeCounter.vpSuccessMoney>>16)&0xff;
1447   1              Wrbuf[num++] = (TradeCounter.vpSuccessMoney>>8)&0xff;
1448   1              Wrbuf[num++] = (TradeCounter.vpSuccessMoney)&0xff;
1449   1              Wrbuf[num++] = (TradeCounter.vpCashNum>>24)&0xff;
1450   1              Wrbuf[num++] = (TradeCounter.vpCashNum>>16)&0xff;
1451   1              Wrbuf[num++] = (TradeCounter.vpCashNum>>8)&0xff;
1452   1              Wrbuf[num++] = (TradeCounter.vpCashNum)&0xff;   
1453   1              Wrbuf[num++] = (TradeCounter.vpCashMoney>>24)&0xff;
1454   1              Wrbuf[num++] = (TradeCounter.vpCashMoney>>16)&0xff;
1455   1              Wrbuf[num++] = (TradeCounter.vpCashMoney>>8)&0xff;
1456   1              Wrbuf[num++] = (TradeCounter.vpCashMoney)&0xff;
1457   1              Wrbuf[num++] = (TradeCounter.vpGameNum>>24)&0xff;
1458   1              Wrbuf[num++] = (TradeCounter.vpGameNum>>16)&0xff;
1459   1              Wrbuf[num++] = (TradeCounter.vpGameNum>>8)&0xff;
1460   1              Wrbuf[num++] = (TradeCounter.vpGameNum)&0xff;
1461   1              Wrbuf[num++] = (TradeCounter.vpCardNum>>24)&0xff;
1462   1              Wrbuf[num++] = (TradeCounter.vpCardNum>>16)&0xff;
1463   1              Wrbuf[num++] = (TradeCounter.vpCardNum>>8)&0xff;
1464   1              Wrbuf[num++] = (TradeCounter.vpCardNum)&0xff;   
1465   1              Wrbuf[num++] = (TradeCounter.vpOnlineNum>>24)&0xff;
1466   1              Wrbuf[num++] = (TradeCounter.vpOnlineNum>>16)&0xff;
1467   1              Wrbuf[num++] = (TradeCounter.vpOnlineNum>>8)&0xff;
1468   1              Wrbuf[num++] = (TradeCounter.vpOnlineNum)&0xff;
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 25  

1469   1              */
1470   1              for(i=0;i<5;i++)
1471   1              {
1472   2                      len = sizeof(struct TRADECOUNTER);
1473   2                  //1.存放到数组中
1474   2                      memcpy(Wrbuf,( unsigned char xdata * )&TradeCounter , len);
1475   2                      //2.作CRC校验
1476   2                      crc = CrcCheck(Wrbuf,len);      
1477   2                      Wrbuf[len] = HUINT16(crc);
1478   2                      Wrbuf[len+1] = LUINT16(crc);
1479   2                      //len = sprintf( str, "%x,%x", Wrbuf[len],Wrbuf[len+1]);
1480   2                      //DisplayStr( 0, 0, 1, str, len );
1481   2                      //len = sprintf( str, "%u,%u,%u,%u,%u,%u,%u,%u-%u,%u", Wrbuf[8],Wrbuf[9],Wrbuf[10],Wrbuf[11],Wrbuf[12],W
             -rbuf[13],Wrbuf[14],Wrbuf[15],Wrbuf[126],Wrbuf[127]);
1482   2                      //DisplayStr( 0, 1, 1, str, len );
1483   2                      //WaitForWork( 5000, NULL );
1484   2                      //3.保存到主页中
1485   2                      MovSramToFlash( ADDRF_TRADECOUNTER , Wrbuf , 128 ); 
1486   2                      //4.保存到备份页中
1487   2                      MovSramToFlash( ADDRF_TRADECOUNTERCOPY , Wrbuf , 128 ); 
1488   2                      DelayMs(5);
1489   2                      //5.反读回来,然后重新判断,如果写入成功，就退出；否则重复写5次
1490   2                      MovFlashToSram( ADDRF_TRADECOUNTER , RdBuf , 128 );     
1491   2                      
1492   2                      //len = sprintf( str, "%x,%x", RdBuf[len],RdBuf[len+1]);
1493   2                      //DisplayStr( 0, 1, 1, str, len );
1494   2                      //len = sprintf( str, "%u,%u,%u,%u,%u,%u,%u,%u-%u,%u", RdBuf[8],RdBuf[9],RdBuf[10],RdBuf[11],RdBuf[12],R
             -dBuf[13],RdBuf[14],RdBuf[15],RdBuf[126],RdBuf[127]);
1495   2                      //DisplayStr( 0, 1, 1, str, len );
1496   2                      //WaitForWork( 5000, NULL );
1497   2                      if(memcmp(Wrbuf,RdBuf,128)==0)//相等
1498   2                      {
1499   3                              //len = sprintf( str, "deng=%u,%x,%x-%x,%x", i,Wrbuf[len],Wrbuf[len+1],RdBuf[len],RdBuf[len+1] );
1500   3                              //DisplayStr( 0, 0, 1, str, len );
1501   3                              //WaitForWork( 2000, NULL );
1502   3                              break;
1503   3                      }
1504   2                      else
1505   2                      {
1506   3                              //len = sprintf( str, "budeng=%u,%x,%x-%x,%x", i,Wrbuf[len],Wrbuf[len+1],RdBuf[len],RdBuf[len+1] );
1507   3                              //DisplayStr( 0, 0, 1, str, len );
1508   3                              //WaitForWork( 2000, NULL );
1509   3                      }
1510   2                      
1511   2              }       
1512   1      }
1513          
1514          
1515          //写交易LOG
1516          void SaveTradeCounter()
1517          {
1518   1              //货道交易LOG设置
1519   1              //MovSramToFlash( ADDRF_WAYSTARDE_LOG , ( unsigned char xdata * )TradeLog , sizeof(struct TRADELOG) * GOO
             -DSWAYNUM );                
1520   1      }
1521          
1522          //货架配置
1523          void SaveRackSet()
1524          {
1525   1              //货架配置
1526   1              MovSramToFlash( ADDRF_RACK_SET , ( unsigned char xdata * )iRackSet , sizeof(struct RackSet) * RACKNUM );        
             -        
CX51 COMPILER V7.50   COMMONFUNCTION                                                       10/23/2014 09:48:23 PAGE 26  

1527   1      }
1528          
1529          //货道配置
1530          void SaveRackColumnSet()
1531          {
1532   1              //货道配置
1533   1              MovSramToFlash( ADDRF_RACK_COLUMN_SET , ( unsigned char xdata * )iRackColumnSet , sizeof(struct RackColum
             -nSet) * RACKNUM * RACKCOLUMNNUM );            
1534   1      }
1535          
1536          //Save the goods parameter
1537          void SaveGoodsParSet( void )
1538          {
1539   1              //MovSramToFlash( ADDRF_GOODSPAR_SET, ( unsigned char xdata * )&sysGoodsMatrix, sizeof( sysGoodsMatrix ) 
             -);        
1540   1      }
1541          
1542          void ReadGoodsParSet( void )
1543          {
1544   1          // MovFlashToSram( ADDRF_GOODSPAR_SET, ( unsigned char xdata * )&sysGoodsMatrix, sizeof( sysGoodsMatri
             -x ) );
1545   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6052    ----
   CONSTANT SIZE    =    469    ----
   XDATA SIZE       =    256     644
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       4
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


CX51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
